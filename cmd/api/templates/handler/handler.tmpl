// Code generated by connexions. DO NOT EDIT.

package handler

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/config"
	"github.com/cubahno/connexions/v2/pkg/typedef"
	"{{.TypesImport}}"
	"github.com/go-chi/chi/v5"
)

{{ $config := .Config }}
{{ $operations := .Operations }}

// Handler implements HTTP handlers for the API.
type Handler struct {
	service   serviceInterface
	config    *config.HandlerConfig
	routeList api.RouteDescriptions
}

// New creates a new handler instance.
// The operations and responseSchemas are built from the typedef registry at runtime.
// Only operations that have generated handlers (filtered by codegen config) are included.
func New(contextsSrc []byte, defaultContexts []map[string]map[string]any, cfg *config.HandlerConfig, registry typedef.OperationRegistry) (*Handler, error) {
	svc, err := newService(contextsSrc, defaultContexts, registry)
	if err != nil {
		return nil, err
	}

	// Build route list from registry's route info
	routeInfo := registry.GetRouteInfo()

	// Filter to only routes that have handlers generated
	handlerOps := map[string]bool{
		{{- range $operations}}
		"{{.Method}}:{{escapeGoString .Path}}": true,
		{{- end}}
	}

	routes := make(api.RouteDescriptions, 0, len(handlerOps))
	for _, ri := range routeInfo {
		key := ri.Method + ":" + ri.Path
		if handlerOps[key] {
			routes = append(routes, &api.RouteDescription{
				ID:     ri.ID,
				Method: ri.Method,
				Path:   ri.Path,
			})
		}
	}
	routes.Sort()

	return &Handler{
		service:   svc,
		config:    cfg,
		routeList: routes,
	}, nil
}

// Type returns the route type.
func (h *Handler) Type() api.RouteType {
	return api.RouteTypeOpenAPI
}

// Routes returns all route descriptions for operations that have handlers.
func (h *Handler) Routes() api.RouteDescriptions {
	return h.routeList
}

// RegisterRoutes registers all HTTP handlers with the provided Chi router.
func (h *Handler) RegisterRoutes(router chi.Router) {
	prefix := "/" + strings.TrimPrefix(h.config.SelfPrefix, "/")
	router.Post(prefix, h.Generate)

	{{- range $operations}}
	router.MethodFunc("{{.Method}}", "{{escapeGoString .Path}}", h.{{.ID | toCamel}})
	{{- end}}
}

// Generate generates a valid request from the OpenAPI spec.
func (h *Handler) Generate(w http.ResponseWriter, r *http.Request) {
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in Generate handler", "panic", rec)
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		}
	}()

	var req api.GenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		slog.Error("Failed to decode request", "error", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	res := h.service.generateRequest(&req, nil)
	slog.Debug("Generated request", "request", string(res))
	w.Header().Set("Content-Type", "application/json")
	w.Write(res)
}

func (h *Handler) getError(path, method string, err error) []byte {
	return h.service.generateError(path, method, err.Error())
}

{{range $operations}}{{$op := .}}
// {{$op.ID | toCamel}} implements {{$op.Method}} {{escapeGoString $op.Path}}
func (h *Handler) {{$op.ID | toCamel}}(w http.ResponseWriter, r *http.Request) {
	const opPath = "{{escapeGoString $op.Path}}"
	const opMethod = "{{$op.Method}}"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "{{escapeGoString $op.ID}}", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[{{if $op.Body }}types.{{$op.Body.Name}}{{else}}struct{}{{end}}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	{{ $okResp := $op.Response.Success }}

	{{- if and $okResp $okResp.ResponseName (ne $okResp.ResponseName "struct{}") }}
	res, _ := h.service.{{$op.ID | toCamel}}(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = {{$op.Response.SuccessStatusCode}}
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[{{if ne $okResp.ResponseName "any"}}types.{{$okResp.ResponseName}}{{else}}struct{}{{end}}](res.Body, "{{escapeGoString $okResp.ContentType}}"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "{{escapeGoString $okResp.ContentType}}")
	{{- if $okResp.Headers }}
	for k, vals := range res.Headers {
		for _, v := range vals {
			w.Header().Add(k, v)
		}
	}
	{{- end }}
	w.WriteHeader(statusCode)
	w.Write(resValue)
	{{- else }}
	w.WriteHeader({{$op.Response.SuccessStatusCode}})
	{{- end }}
}

{{end -}}
