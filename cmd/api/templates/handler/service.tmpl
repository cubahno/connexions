// Code generated by connexions. DO NOT EDIT.

package handler

import (
	"net/http"
	"sync"

	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/generator"
	"github.com/cubahno/connexions/v2/pkg/schema"
	"github.com/cubahno/connexions/v2/pkg/typedef"
)

{{ $operations := .Operations }}

// ResponseData wraps the generated response.
type ResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int  // 0 = use default
	IsError bool
}

// serviceInterface defines the interface for mock generation.
type serviceInterface interface {
{{- range $operations}}
	{{.ID | toCamel}}(path, method string) (*ResponseData, error)
{{- end}}
	generateRequest(req *api.GenerateRequest, op *schema.Operation) []byte
	generateError(path, method string, errMsg string) []byte
}

// operationData holds cached operation and response schema for a single endpoint.
type operationData struct {
	operation      *schema.Operation
	responseSchema *schema.ResponseSchema
}

// service implements serviceInterface with mock generation logic.
type service struct {
	generator generator.Generate
	registry  typedef.OperationRegistry

	// Cached operation data (lazy loaded)
	opCache sync.Map
}

// newService creates a new service instance.
func newService(contextsSrc []byte, defaultContexts []map[string]map[string]any, registry typedef.OperationRegistry) (*service, error) {
	orderedCtx := generator.LoadServiceContext(contextsSrc, defaultContexts)

	gen, err := generator.NewGenerator(orderedCtx)
	if err != nil {
		return nil, err
	}

	return &service{
		generator: gen,
		registry:  registry,
	}, nil
}

// Ensure service implements serviceInterface.
var _ serviceInterface = (*service)(nil)

// getOperationData returns cached operation data, loading it lazily if needed.
func (s *service) getOperationData(path, method string) *operationData {
	key := method + ":" + path

	// Check cache first
	if cached, ok := s.opCache.Load(key); ok {
		return cached.(*operationData)
	}

	// Load from registry
	op := s.registry.FindOperation(path, method)
	if op == nil {
		return nil
	}

	// Build response schema
	respSchema := &schema.ResponseSchema{}
	if successResp := op.Response.GetSuccess(); successResp != nil {
		respSchema.ContentType = successResp.ContentType
		respSchema.Body = successResp.Content
		respSchema.Headers = successResp.Headers
	}
	if errResp := op.Response.GetResponse(400); errResp != nil {
		respSchema.Error = errResp.Content
	}

	data := &operationData{
		operation:      op,
		responseSchema: respSchema,
	}

	s.opCache.Store(key, data)
	return data
}

func (s *service) generateRequest(req *api.GenerateRequest, op *schema.Operation) []byte {
	if op == nil {
		opData := s.getOperationData(req.Path, req.Method)
		if opData != nil {
			op = opData.operation
		}
	}
	return s.generator.Request(req, op)
}

func (s *service) generateError(path, method string, errMsg string) []byte {
	opData := s.getOperationData(path, method)
	if opData != nil && opData.responseSchema.Error != nil {
		opKey := method + ":" + path
		return s.generator.Error(opData.responseSchema.Error, errorPaths[opKey], errMsg)
	}
	return []byte(errMsg)
}

{{range $operations}}{{$op := .}}{{ $okResp := $op.Response.Success }}
func (s *service) {{$op.ID | toCamel}}(path, method string) (*ResponseData, error) {
{{- if and $okResp $okResp.ResponseName (ne $okResp.ResponseName "struct{}") }}
	opData := s.getOperationData(path, method)
	if opData == nil {
		return nil, nil
	}

	res := s.generator.Response(opData.responseSchema)
	return &ResponseData{
		Body:    res.Body,
		Headers: res.Headers,
		IsError: res.IsError,
	}, nil
{{- else }}
	return &ResponseData{}, nil
{{- end }}
}
{{end -}}
