// Code generated by gen-service. DO NOT EDIT.

package handler

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"example/services/spoonacular/types"

	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/config"
	"github.com/cubahno/connexions/v2/pkg/typedef"
	"github.com/go-chi/chi/v5"
)

// Handler implements HTTP handlers for the API.
type Handler struct {
	service   serviceInterface
	config    *config.HandlerConfig
	routeList api.RouteDescriptions
}

// New creates a new handler instance.
// The operations and responseSchemas are built from the typedef registry at runtime.
// Only operations that have generated handlers (filtered by codegen config) are included.
func New(contextsSrc []byte, defaultContexts []map[string]map[string]any, cfg *config.HandlerConfig, registry typedef.OperationRegistry) (*Handler, error) {
	svc, err := newService(contextsSrc, defaultContexts, registry)
	if err != nil {
		return nil, err
	}

	// Build route list from registry's route info
	routeInfo := registry.GetRouteInfo()

	// Filter to only routes that have handlers generated
	handlerOps := map[string]bool{
		"GET:/food/converse":                                                 true,
		"GET:/food/converse/suggest":                                         true,
		"GET:/food/customFoods/search":                                       true,
		"POST:/food/detect":                                                  true,
		"GET:/food/images/analyze":                                           true,
		"GET:/food/images/classify":                                          true,
		"GET:/food/ingredients/autocomplete":                                 true,
		"POST:/food/ingredients/glycemicLoad":                                true,
		"POST:/food/ingredients/map":                                         true,
		"GET:/food/ingredients/search":                                       true,
		"GET:/food/ingredients/substitutes":                                  true,
		"GET:/food/ingredients/{id}/amount":                                  true,
		"GET:/food/ingredients/{id}/information":                             true,
		"GET:/food/ingredients/{id}/substitutes":                             true,
		"GET:/food/jokes/random":                                             true,
		"GET:/food/menuItems/search":                                         true,
		"GET:/food/menuItems/suggest":                                        true,
		"GET:/food/menuItems/{id}":                                           true,
		"GET:/food/menuItems/{id}/nutritionLabel":                            true,
		"GET:/food/menuItems/{id}/nutritionLabel.png":                        true,
		"GET:/food/menuItems/{id}/nutritionWidget":                           true,
		"GET:/food/menuItems/{id}/nutritionWidget.png":                       true,
		"POST:/food/products/classify":                                       true,
		"POST:/food/products/classifyBatch":                                  true,
		"GET:/food/products/search":                                          true,
		"GET:/food/products/suggest":                                         true,
		"GET:/food/products/upc/{upc}":                                       true,
		"GET:/food/products/upc/{upc}/comparable":                            true,
		"GET:/food/products/{id}":                                            true,
		"GET:/food/products/{id}/nutritionLabel":                             true,
		"GET:/food/products/{id}/nutritionLabel.png":                         true,
		"GET:/food/products/{id}/nutritionWidget":                            true,
		"GET:/food/products/{id}/nutritionWidget.png":                        true,
		"GET:/food/restaurants/search":                                       true,
		"GET:/food/search":                                                   true,
		"GET:/food/site/search":                                              true,
		"GET:/food/trivia/random":                                            true,
		"GET:/food/videos/search":                                            true,
		"GET:/food/wine/description":                                         true,
		"GET:/food/wine/dishes":                                              true,
		"GET:/food/wine/pairing":                                             true,
		"GET:/food/wine/recommendation":                                      true,
		"GET:/mealplanner/generate":                                          true,
		"DELETE:/mealplanner/{username}/day/{date}":                          true,
		"POST:/mealplanner/{username}/items":                                 true,
		"DELETE:/mealplanner/{username}/items/{id}":                          true,
		"GET:/mealplanner/{username}/shopping-list":                          true,
		"POST:/mealplanner/{username}/shopping-list/items":                   true,
		"DELETE:/mealplanner/{username}/shopping-list/items/{id}":            true,
		"POST:/mealplanner/{username}/shopping-list/{start-date}/{end-date}": true,
		"GET:/mealplanner/{username}/templates":                              true,
		"POST:/mealplanner/{username}/templates":                             true,
		"GET:/mealplanner/{username}/templates/{id}":                         true,
		"DELETE:/mealplanner/{username}/templates/{id}":                      true,
		"GET:/mealplanner/{username}/week/{start-date}":                      true,
		"POST:/recipes/analyze":                                              true,
		"POST:/recipes/analyzeInstructions":                                  true,
		"GET:/recipes/autocomplete":                                          true,
		"GET:/recipes/complexSearch":                                         true,
		"GET:/recipes/convert":                                               true,
		"POST:/recipes/cuisine":                                              true,
		"GET:/recipes/extract":                                               true,
		"GET:/recipes/findByIngredients":                                     true,
		"GET:/recipes/findByNutrients":                                       true,
		"GET:/recipes/guessNutrition":                                        true,
		"GET:/recipes/informationBulk":                                       true,
		"POST:/recipes/parseIngredients":                                     true,
		"GET:/recipes/queries/analyze":                                       true,
		"GET:/recipes/quickAnswer":                                           true,
		"GET:/recipes/random":                                                true,
		"POST:/recipes/visualizeEquipment":                                   true,
		"POST:/recipes/visualizeIngredients":                                 true,
		"POST:/recipes/visualizeNutrition":                                   true,
		"POST:/recipes/visualizePriceEstimator":                              true,
		"POST:/recipes/visualizeRecipe":                                      true,
		"POST:/recipes/visualizeTaste":                                       true,
		"GET:/recipes/{id}/analyzedInstructions":                             true,
		"GET:/recipes/{id}/card":                                             true,
		"GET:/recipes/{id}/equipmentWidget":                                  true,
		"GET:/recipes/{id}/equipmentWidget.json":                             true,
		"GET:/recipes/{id}/equipmentWidget.png":                              true,
		"GET:/recipes/{id}/information":                                      true,
		"GET:/recipes/{id}/ingredientWidget":                                 true,
		"GET:/recipes/{id}/ingredientWidget.json":                            true,
		"GET:/recipes/{id}/ingredientWidget.png":                             true,
		"GET:/recipes/{id}/nutritionLabel":                                   true,
		"GET:/recipes/{id}/nutritionLabel.png":                               true,
		"GET:/recipes/{id}/nutritionWidget":                                  true,
		"GET:/recipes/{id}/nutritionWidget.json":                             true,
		"GET:/recipes/{id}/nutritionWidget.png":                              true,
		"GET:/recipes/{id}/priceBreakdownWidget":                             true,
		"GET:/recipes/{id}/priceBreakdownWidget.json":                        true,
		"GET:/recipes/{id}/priceBreakdownWidget.png":                         true,
		"GET:/recipes/{id}/similar":                                          true,
		"GET:/recipes/{id}/summary":                                          true,
		"GET:/recipes/{id}/tasteWidget":                                      true,
		"GET:/recipes/{id}/tasteWidget.json":                                 true,
		"GET:/recipes/{id}/tasteWidget.png":                                  true,
		"POST:/users/connect":                                                true,
	}

	routes := make(api.RouteDescriptions, 0, len(handlerOps))
	for _, ri := range routeInfo {
		key := ri.Method + ":" + ri.Path
		if handlerOps[key] {
			routes = append(routes, &api.RouteDescription{
				ID:     ri.ID,
				Method: ri.Method,
				Path:   ri.Path,
			})
		}
	}
	routes.Sort()

	return &Handler{
		service:   svc,
		config:    cfg,
		routeList: routes,
	}, nil
}

// Type returns the route type.
func (h *Handler) Type() api.RouteType {
	return api.RouteTypeOpenAPI
}

// Routes returns all route descriptions for operations that have handlers.
func (h *Handler) Routes() api.RouteDescriptions {
	return h.routeList
}

// RegisterRoutes registers all HTTP handlers with the provided Chi router.
func (h *Handler) RegisterRoutes(router chi.Router) {
	prefix := "/" + strings.TrimPrefix(h.config.SelfPrefix, "/")
	router.Post(prefix, h.Generate)
	router.MethodFunc("GET", "/food/converse", h.talkToChatbot)
	router.MethodFunc("GET", "/food/converse/suggest", h.getConversationSuggests)
	router.MethodFunc("GET", "/food/customFoods/search", h.searchCustomFoods)
	router.MethodFunc("POST", "/food/detect", h.detectFoodInText)
	router.MethodFunc("GET", "/food/images/analyze", h.imageAnalysisByURL)
	router.MethodFunc("GET", "/food/images/classify", h.imageClassificationByURL)
	router.MethodFunc("GET", "/food/ingredients/autocomplete", h.autocompleteIngredientSearch)
	router.MethodFunc("POST", "/food/ingredients/glycemicLoad", h.computeGlycemicLoad)
	router.MethodFunc("POST", "/food/ingredients/map", h.mapIngredientsToGroceryProducts)
	router.MethodFunc("GET", "/food/ingredients/search", h.ingredientSearch)
	router.MethodFunc("GET", "/food/ingredients/substitutes", h.getIngredientSubstitutes)
	router.MethodFunc("GET", "/food/ingredients/{id}/amount", h.computeIngredientAmount)
	router.MethodFunc("GET", "/food/ingredients/{id}/information", h.getIngredientInformation)
	router.MethodFunc("GET", "/food/ingredients/{id}/substitutes", h.getIngredientSubstitutesByID)
	router.MethodFunc("GET", "/food/jokes/random", h.getARandomFoodJoke)
	router.MethodFunc("GET", "/food/menuItems/search", h.searchMenuItems)
	router.MethodFunc("GET", "/food/menuItems/suggest", h.autocompleteMenuItemSearch)
	router.MethodFunc("GET", "/food/menuItems/{id}", h.getMenuItemInformation)
	router.MethodFunc("GET", "/food/menuItems/{id}/nutritionLabel", h.menuItemNutritionLabelWidget)
	router.MethodFunc("GET", "/food/menuItems/{id}/nutritionLabel.png", h.menuItemNutritionLabelImage)
	router.MethodFunc("GET", "/food/menuItems/{id}/nutritionWidget", h.visualizeMenuItemNutritionByID)
	router.MethodFunc("GET", "/food/menuItems/{id}/nutritionWidget.png", h.menuItemNutritionByIDImage)
	router.MethodFunc("POST", "/food/products/classify", h.classifyGroceryProduct)
	router.MethodFunc("POST", "/food/products/classifyBatch", h.classifyGroceryProductBulk)
	router.MethodFunc("GET", "/food/products/search", h.searchGroceryProducts)
	router.MethodFunc("GET", "/food/products/suggest", h.autocompleteProductSearch)
	router.MethodFunc("GET", "/food/products/upc/{upc}", h.searchGroceryProductsByUPC)
	router.MethodFunc("GET", "/food/products/upc/{upc}/comparable", h.getComparableProducts)
	router.MethodFunc("GET", "/food/products/{id}", h.getProductInformation)
	router.MethodFunc("GET", "/food/products/{id}/nutritionLabel", h.productNutritionLabelWidget)
	router.MethodFunc("GET", "/food/products/{id}/nutritionLabel.png", h.productNutritionLabelImage)
	router.MethodFunc("GET", "/food/products/{id}/nutritionWidget", h.visualizeProductNutritionByID)
	router.MethodFunc("GET", "/food/products/{id}/nutritionWidget.png", h.productNutritionByIDImage)
	router.MethodFunc("GET", "/food/restaurants/search", h.searchRestaurants)
	router.MethodFunc("GET", "/food/search", h.searchAllFood)
	router.MethodFunc("GET", "/food/site/search", h.searchSiteContent)
	router.MethodFunc("GET", "/food/trivia/random", h.getRandomFoodTrivia)
	router.MethodFunc("GET", "/food/videos/search", h.searchFoodVideos)
	router.MethodFunc("GET", "/food/wine/description", h.getWineDescription)
	router.MethodFunc("GET", "/food/wine/dishes", h.getDishPairingForWine)
	router.MethodFunc("GET", "/food/wine/pairing", h.getWinePairing)
	router.MethodFunc("GET", "/food/wine/recommendation", h.getWineRecommendation)
	router.MethodFunc("GET", "/mealplanner/generate", h.generateMealPlan)
	router.MethodFunc("DELETE", "/mealplanner/{username}/day/{date}", h.clearMealPlanDay)
	router.MethodFunc("POST", "/mealplanner/{username}/items", h.addToMealPlan)
	router.MethodFunc("DELETE", "/mealplanner/{username}/items/{id}", h.deleteFromMealPlan)
	router.MethodFunc("GET", "/mealplanner/{username}/shopping-list", h.getShoppingList)
	router.MethodFunc("POST", "/mealplanner/{username}/shopping-list/items", h.addToShoppingList)
	router.MethodFunc("DELETE", "/mealplanner/{username}/shopping-list/items/{id}", h.deleteFromShoppingList)
	router.MethodFunc("POST", "/mealplanner/{username}/shopping-list/{start-date}/{end-date}", h.generateShoppingList)
	router.MethodFunc("GET", "/mealplanner/{username}/templates", h.getMealPlanTemplates)
	router.MethodFunc("POST", "/mealplanner/{username}/templates", h.addMealPlanTemplate)
	router.MethodFunc("GET", "/mealplanner/{username}/templates/{id}", h.getMealPlanTemplate)
	router.MethodFunc("DELETE", "/mealplanner/{username}/templates/{id}", h.deleteMealPlanTemplate)
	router.MethodFunc("GET", "/mealplanner/{username}/week/{start-date}", h.getMealPlanWeek)
	router.MethodFunc("POST", "/recipes/analyze", h.analyzeRecipe)
	router.MethodFunc("POST", "/recipes/analyzeInstructions", h.analyzeRecipeInstructions)
	router.MethodFunc("GET", "/recipes/autocomplete", h.autocompleteRecipeSearch)
	router.MethodFunc("GET", "/recipes/complexSearch", h.searchRecipes)
	router.MethodFunc("GET", "/recipes/convert", h.convertAmounts)
	router.MethodFunc("POST", "/recipes/cuisine", h.classifyCuisine)
	router.MethodFunc("GET", "/recipes/extract", h.extractRecipeFromWebsite)
	router.MethodFunc("GET", "/recipes/findByIngredients", h.searchRecipesByIngredients)
	router.MethodFunc("GET", "/recipes/findByNutrients", h.searchRecipesByNutrients)
	router.MethodFunc("GET", "/recipes/guessNutrition", h.guessNutritionByDishName)
	router.MethodFunc("GET", "/recipes/informationBulk", h.getRecipeInformationBulk)
	router.MethodFunc("POST", "/recipes/parseIngredients", h.parseIngredients)
	router.MethodFunc("GET", "/recipes/queries/analyze", h.analyzeARecipeSearchQuery)
	router.MethodFunc("GET", "/recipes/quickAnswer", h.quickAnswer)
	router.MethodFunc("GET", "/recipes/random", h.getRandomRecipes)
	router.MethodFunc("POST", "/recipes/visualizeEquipment", h.visualizeEquipment)
	router.MethodFunc("POST", "/recipes/visualizeIngredients", h.visualizeIngredients)
	router.MethodFunc("POST", "/recipes/visualizeNutrition", h.visualizeRecipeNutrition)
	router.MethodFunc("POST", "/recipes/visualizePriceEstimator", h.visualizePriceBreakdown)
	router.MethodFunc("POST", "/recipes/visualizeRecipe", h.createRecipeCard)
	router.MethodFunc("POST", "/recipes/visualizeTaste", h.visualizeRecipeTaste)
	router.MethodFunc("GET", "/recipes/{id}/analyzedInstructions", h.getAnalyzedRecipeInstructions)
	router.MethodFunc("GET", "/recipes/{id}/card", h.createRecipeCardGet)
	router.MethodFunc("GET", "/recipes/{id}/equipmentWidget", h.visualizeRecipeEquipmentByID)
	router.MethodFunc("GET", "/recipes/{id}/equipmentWidget.json", h.getRecipeEquipmentByID)
	router.MethodFunc("GET", "/recipes/{id}/equipmentWidget.png", h.equipmentByIDImage)
	router.MethodFunc("GET", "/recipes/{id}/information", h.getRecipeInformation)
	router.MethodFunc("GET", "/recipes/{id}/ingredientWidget", h.visualizeRecipeIngredientsByID)
	router.MethodFunc("GET", "/recipes/{id}/ingredientWidget.json", h.getRecipeIngredientsByID)
	router.MethodFunc("GET", "/recipes/{id}/ingredientWidget.png", h.ingredientsByIDImage)
	router.MethodFunc("GET", "/recipes/{id}/nutritionLabel", h.recipeNutritionLabelWidget)
	router.MethodFunc("GET", "/recipes/{id}/nutritionLabel.png", h.recipeNutritionLabelImage)
	router.MethodFunc("GET", "/recipes/{id}/nutritionWidget", h.visualizeRecipeNutritionByID)
	router.MethodFunc("GET", "/recipes/{id}/nutritionWidget.json", h.getRecipeNutritionWidgetByID)
	router.MethodFunc("GET", "/recipes/{id}/nutritionWidget.png", h.recipeNutritionByIDImage)
	router.MethodFunc("GET", "/recipes/{id}/priceBreakdownWidget", h.visualizeRecipePriceBreakdownByID)
	router.MethodFunc("GET", "/recipes/{id}/priceBreakdownWidget.json", h.getRecipePriceBreakdownByID)
	router.MethodFunc("GET", "/recipes/{id}/priceBreakdownWidget.png", h.priceBreakdownByIDImage)
	router.MethodFunc("GET", "/recipes/{id}/similar", h.getSimilarRecipes)
	router.MethodFunc("GET", "/recipes/{id}/summary", h.summarizeRecipe)
	router.MethodFunc("GET", "/recipes/{id}/tasteWidget", h.visualizeRecipeTasteByID)
	router.MethodFunc("GET", "/recipes/{id}/tasteWidget.json", h.getRecipeTasteByID)
	router.MethodFunc("GET", "/recipes/{id}/tasteWidget.png", h.recipeTasteByIDImage)
	router.MethodFunc("POST", "/users/connect", h.connectUser)
}

// Generate generates a valid request from the OpenAPI spec.
func (h *Handler) Generate(w http.ResponseWriter, r *http.Request) {
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in Generate handler", "panic", rec)
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		}
	}()

	var req api.GenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		slog.Error("Failed to decode request", "error", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	res := h.service.generateRequest(&req, nil)
	slog.Debug("Generated request", "request", string(res))
	w.Header().Set("Content-Type", "application/json")
	w.Write(res)
}

func (h *Handler) getError(path, method string, err error) []byte {
	return h.service.generateError(path, method, err.Error())
}

// talkToChatbot implements GET /food/converse
func (h *Handler) talkToChatbot(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/converse"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "TalkToChatbot", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.talkToChatbot(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.TalkToChatbotResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getConversationSuggests implements GET /food/converse/suggest
func (h *Handler) getConversationSuggests(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/converse/suggest"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetConversationSuggests", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getConversationSuggests(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetConversationSuggestsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchCustomFoods implements GET /food/customFoods/search
func (h *Handler) searchCustomFoods(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/customFoods/search"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchCustomFoods", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchCustomFoods(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchCustomFoodsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// detectFoodInText implements POST /food/detect
func (h *Handler) detectFoodInText(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/detect"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "DetectFoodInText", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.DetectFoodInTextBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.detectFoodInText(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.DetectFoodInTextResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// imageAnalysisByURL implements GET /food/images/analyze
func (h *Handler) imageAnalysisByURL(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/images/analyze"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ImageAnalysisByURL", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.imageAnalysisByURL(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ImageAnalysisByURLResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// imageClassificationByURL implements GET /food/images/classify
func (h *Handler) imageClassificationByURL(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/images/classify"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ImageClassificationByURL", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.imageClassificationByURL(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ImageClassificationByURLResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// autocompleteIngredientSearch implements GET /food/ingredients/autocomplete
func (h *Handler) autocompleteIngredientSearch(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/ingredients/autocomplete"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AutocompleteIngredientSearch", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.autocompleteIngredientSearch(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AutocompleteIngredientSearchResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// computeGlycemicLoad implements POST /food/ingredients/glycemicLoad
func (h *Handler) computeGlycemicLoad(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/ingredients/glycemicLoad"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ComputeGlycemicLoad", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.ComputeGlycemicLoadBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.computeGlycemicLoad(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ComputeGlycemicLoadResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// mapIngredientsToGroceryProducts implements POST /food/ingredients/map
func (h *Handler) mapIngredientsToGroceryProducts(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/ingredients/map"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "MapIngredientsToGroceryProducts", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.MapIngredientsToGroceryProductsBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.mapIngredientsToGroceryProducts(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.MapIngredientsToGroceryProductsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// ingredientSearch implements GET /food/ingredients/search
func (h *Handler) ingredientSearch(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/ingredients/search"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "IngredientSearch", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.ingredientSearch(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.IngredientSearchResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getIngredientSubstitutes implements GET /food/ingredients/substitutes
func (h *Handler) getIngredientSubstitutes(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/ingredients/substitutes"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetIngredientSubstitutes", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getIngredientSubstitutes(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetIngredientSubstitutesResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// computeIngredientAmount implements GET /food/ingredients/{id}/amount
func (h *Handler) computeIngredientAmount(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/ingredients/{id}/amount"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ComputeIngredientAmount", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.computeIngredientAmount(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ComputeIngredientAmountResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getIngredientInformation implements GET /food/ingredients/{id}/information
func (h *Handler) getIngredientInformation(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/ingredients/{id}/information"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetIngredientInformation", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getIngredientInformation(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetIngredientInformationResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getIngredientSubstitutesByID implements GET /food/ingredients/{id}/substitutes
func (h *Handler) getIngredientSubstitutesByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/ingredients/{id}/substitutes"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetIngredientSubstitutesByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getIngredientSubstitutesByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetIngredientSubstitutesByIDResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getARandomFoodJoke implements GET /food/jokes/random
func (h *Handler) getARandomFoodJoke(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/jokes/random"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetARandomFoodJoke", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getARandomFoodJoke(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetARandomFoodJokeResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchMenuItems implements GET /food/menuItems/search
func (h *Handler) searchMenuItems(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/menuItems/search"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchMenuItems", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchMenuItems(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchMenuItemsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// autocompleteMenuItemSearch implements GET /food/menuItems/suggest
func (h *Handler) autocompleteMenuItemSearch(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/menuItems/suggest"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AutocompleteMenuItemSearch", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.autocompleteMenuItemSearch(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AutocompleteMenuItemSearchResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getMenuItemInformation implements GET /food/menuItems/{id}
func (h *Handler) getMenuItemInformation(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/menuItems/{id}"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetMenuItemInformation", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getMenuItemInformation(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetMenuItemInformationResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// menuItemNutritionLabelWidget implements GET /food/menuItems/{id}/nutritionLabel
func (h *Handler) menuItemNutritionLabelWidget(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/menuItems/{id}/nutritionLabel"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "MenuItemNutritionLabelWidget", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.menuItemNutritionLabelWidget(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.MenuItemNutritionLabelWidgetResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// menuItemNutritionLabelImage implements GET /food/menuItems/{id}/nutritionLabel.png
func (h *Handler) menuItemNutritionLabelImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/menuItems/{id}/nutritionLabel.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "MenuItemNutritionLabelImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.menuItemNutritionLabelImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.MenuItemNutritionLabelImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeMenuItemNutritionByID implements GET /food/menuItems/{id}/nutritionWidget
func (h *Handler) visualizeMenuItemNutritionByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/menuItems/{id}/nutritionWidget"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeMenuItemNutritionByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeMenuItemNutritionByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeMenuItemNutritionByIDResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// menuItemNutritionByIDImage implements GET /food/menuItems/{id}/nutritionWidget.png
func (h *Handler) menuItemNutritionByIDImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/menuItems/{id}/nutritionWidget.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "MenuItemNutritionByIDImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.menuItemNutritionByIDImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.MenuItemNutritionByIDImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// classifyGroceryProduct implements POST /food/products/classify
func (h *Handler) classifyGroceryProduct(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/classify"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ClassifyGroceryProduct", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.ClassifyGroceryProductBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.classifyGroceryProduct(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ClassifyGroceryProductResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// classifyGroceryProductBulk implements POST /food/products/classifyBatch
func (h *Handler) classifyGroceryProductBulk(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/classifyBatch"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ClassifyGroceryProductBulk", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.ClassifyGroceryProductBulkBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.classifyGroceryProductBulk(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ClassifyGroceryProductBulkResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchGroceryProducts implements GET /food/products/search
func (h *Handler) searchGroceryProducts(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/search"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchGroceryProducts", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchGroceryProducts(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchGroceryProductsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// autocompleteProductSearch implements GET /food/products/suggest
func (h *Handler) autocompleteProductSearch(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/suggest"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AutocompleteProductSearch", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.autocompleteProductSearch(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AutocompleteProductSearchResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchGroceryProductsByUPC implements GET /food/products/upc/{upc}
func (h *Handler) searchGroceryProductsByUPC(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/upc/{upc}"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchGroceryProductsByUPC", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchGroceryProductsByUPC(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchGroceryProductsByUPCResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getComparableProducts implements GET /food/products/upc/{upc}/comparable
func (h *Handler) getComparableProducts(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/upc/{upc}/comparable"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetComparableProducts", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getComparableProducts(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetComparableProductsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getProductInformation implements GET /food/products/{id}
func (h *Handler) getProductInformation(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/{id}"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetProductInformation", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getProductInformation(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetProductInformationResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// productNutritionLabelWidget implements GET /food/products/{id}/nutritionLabel
func (h *Handler) productNutritionLabelWidget(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/{id}/nutritionLabel"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ProductNutritionLabelWidget", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.productNutritionLabelWidget(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ProductNutritionLabelWidgetResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// productNutritionLabelImage implements GET /food/products/{id}/nutritionLabel.png
func (h *Handler) productNutritionLabelImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/{id}/nutritionLabel.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ProductNutritionLabelImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.productNutritionLabelImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ProductNutritionLabelImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeProductNutritionByID implements GET /food/products/{id}/nutritionWidget
func (h *Handler) visualizeProductNutritionByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/{id}/nutritionWidget"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeProductNutritionByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeProductNutritionByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeProductNutritionByIDResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// productNutritionByIDImage implements GET /food/products/{id}/nutritionWidget.png
func (h *Handler) productNutritionByIDImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/products/{id}/nutritionWidget.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ProductNutritionByIDImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.productNutritionByIDImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ProductNutritionByIDImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchRestaurants implements GET /food/restaurants/search
func (h *Handler) searchRestaurants(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/restaurants/search"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchRestaurants", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchRestaurants(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchRestaurantsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchAllFood implements GET /food/search
func (h *Handler) searchAllFood(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/search"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchAllFood", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchAllFood(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchAllFoodResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchSiteContent implements GET /food/site/search
func (h *Handler) searchSiteContent(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/site/search"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchSiteContent", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchSiteContent(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchSiteContentResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRandomFoodTrivia implements GET /food/trivia/random
func (h *Handler) getRandomFoodTrivia(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/trivia/random"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRandomFoodTrivia", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRandomFoodTrivia(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRandomFoodTriviaResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchFoodVideos implements GET /food/videos/search
func (h *Handler) searchFoodVideos(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/videos/search"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchFoodVideos", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchFoodVideos(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchFoodVideosResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getWineDescription implements GET /food/wine/description
func (h *Handler) getWineDescription(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/wine/description"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetWineDescription", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getWineDescription(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetWineDescriptionResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getDishPairingForWine implements GET /food/wine/dishes
func (h *Handler) getDishPairingForWine(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/wine/dishes"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetDishPairingForWine", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getDishPairingForWine(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetDishPairingForWineResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getWinePairing implements GET /food/wine/pairing
func (h *Handler) getWinePairing(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/wine/pairing"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetWinePairing", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getWinePairing(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetWinePairingResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getWineRecommendation implements GET /food/wine/recommendation
func (h *Handler) getWineRecommendation(w http.ResponseWriter, r *http.Request) {
	const opPath = "/food/wine/recommendation"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetWineRecommendation", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getWineRecommendation(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetWineRecommendationResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// generateMealPlan implements GET /mealplanner/generate
func (h *Handler) generateMealPlan(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/generate"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GenerateMealPlan", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.generateMealPlan(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GenerateMealPlanResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// clearMealPlanDay implements DELETE /mealplanner/{username}/day/{date}
func (h *Handler) clearMealPlanDay(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/day/{date}"
	const opMethod = "DELETE"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ClearMealPlanDay", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.ClearMealPlanDayBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.clearMealPlanDay(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ClearMealPlanDayResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// addToMealPlan implements POST /mealplanner/{username}/items
func (h *Handler) addToMealPlan(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/items"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AddToMealPlan", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.AddToMealPlanBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.addToMealPlan(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AddToMealPlanResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// deleteFromMealPlan implements DELETE /mealplanner/{username}/items/{id}
func (h *Handler) deleteFromMealPlan(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/items/{id}"
	const opMethod = "DELETE"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "DeleteFromMealPlan", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.DeleteFromMealPlanBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.deleteFromMealPlan(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.DeleteFromMealPlanResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getShoppingList implements GET /mealplanner/{username}/shopping-list
func (h *Handler) getShoppingList(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/shopping-list"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetShoppingList", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getShoppingList(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetShoppingListResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// addToShoppingList implements POST /mealplanner/{username}/shopping-list/items
func (h *Handler) addToShoppingList(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/shopping-list/items"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AddToShoppingList", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.AddToShoppingListBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.addToShoppingList(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AddToShoppingListResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// deleteFromShoppingList implements DELETE /mealplanner/{username}/shopping-list/items/{id}
func (h *Handler) deleteFromShoppingList(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/shopping-list/items/{id}"
	const opMethod = "DELETE"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "DeleteFromShoppingList", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.DeleteFromShoppingListBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.deleteFromShoppingList(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.DeleteFromShoppingListResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// generateShoppingList implements POST /mealplanner/{username}/shopping-list/{start-date}/{end-date}
func (h *Handler) generateShoppingList(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/shopping-list/{start-date}/{end-date}"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GenerateShoppingList", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.GenerateShoppingListBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.generateShoppingList(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GenerateShoppingListResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getMealPlanTemplates implements GET /mealplanner/{username}/templates
func (h *Handler) getMealPlanTemplates(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/templates"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetMealPlanTemplates", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getMealPlanTemplates(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetMealPlanTemplatesResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// addMealPlanTemplate implements POST /mealplanner/{username}/templates
func (h *Handler) addMealPlanTemplate(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/templates"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AddMealPlanTemplate", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.AddMealPlanTemplateBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.addMealPlanTemplate(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AddMealPlanTemplateResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getMealPlanTemplate implements GET /mealplanner/{username}/templates/{id}
func (h *Handler) getMealPlanTemplate(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/templates/{id}"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetMealPlanTemplate", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getMealPlanTemplate(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetMealPlanTemplateResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// deleteMealPlanTemplate implements DELETE /mealplanner/{username}/templates/{id}
func (h *Handler) deleteMealPlanTemplate(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/templates/{id}"
	const opMethod = "DELETE"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "DeleteMealPlanTemplate", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.DeleteMealPlanTemplateBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.deleteMealPlanTemplate(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.DeleteMealPlanTemplateResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getMealPlanWeek implements GET /mealplanner/{username}/week/{start-date}
func (h *Handler) getMealPlanWeek(w http.ResponseWriter, r *http.Request) {
	const opPath = "/mealplanner/{username}/week/{start-date}"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetMealPlanWeek", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getMealPlanWeek(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetMealPlanWeekResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// analyzeRecipe implements POST /recipes/analyze
func (h *Handler) analyzeRecipe(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/analyze"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AnalyzeRecipe", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.AnalyzeRecipeBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.analyzeRecipe(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AnalyzeRecipeResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// analyzeRecipeInstructions implements POST /recipes/analyzeInstructions
func (h *Handler) analyzeRecipeInstructions(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/analyzeInstructions"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AnalyzeRecipeInstructions", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.AnalyzeRecipeInstructionsBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.analyzeRecipeInstructions(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AnalyzeRecipeInstructionsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// autocompleteRecipeSearch implements GET /recipes/autocomplete
func (h *Handler) autocompleteRecipeSearch(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/autocomplete"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AutocompleteRecipeSearch", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.autocompleteRecipeSearch(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AutocompleteRecipeSearchResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchRecipes implements GET /recipes/complexSearch
func (h *Handler) searchRecipes(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/complexSearch"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchRecipes", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchRecipes(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchRecipesResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// convertAmounts implements GET /recipes/convert
func (h *Handler) convertAmounts(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/convert"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ConvertAmounts", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.convertAmounts(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ConvertAmountsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// classifyCuisine implements POST /recipes/cuisine
func (h *Handler) classifyCuisine(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/cuisine"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ClassifyCuisine", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.ClassifyCuisineBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.classifyCuisine(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ClassifyCuisineResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// extractRecipeFromWebsite implements GET /recipes/extract
func (h *Handler) extractRecipeFromWebsite(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/extract"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ExtractRecipeFromWebsite", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.extractRecipeFromWebsite(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ExtractRecipeFromWebsiteResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchRecipesByIngredients implements GET /recipes/findByIngredients
func (h *Handler) searchRecipesByIngredients(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/findByIngredients"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchRecipesByIngredients", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchRecipesByIngredients(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchRecipesByIngredientsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// searchRecipesByNutrients implements GET /recipes/findByNutrients
func (h *Handler) searchRecipesByNutrients(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/findByNutrients"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SearchRecipesByNutrients", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.searchRecipesByNutrients(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SearchRecipesByNutrientsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// guessNutritionByDishName implements GET /recipes/guessNutrition
func (h *Handler) guessNutritionByDishName(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/guessNutrition"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GuessNutritionByDishName", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.guessNutritionByDishName(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GuessNutritionByDishNameResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRecipeInformationBulk implements GET /recipes/informationBulk
func (h *Handler) getRecipeInformationBulk(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/informationBulk"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRecipeInformationBulk", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRecipeInformationBulk(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRecipeInformationBulkResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// parseIngredients implements POST /recipes/parseIngredients
func (h *Handler) parseIngredients(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/parseIngredients"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ParseIngredients", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.ParseIngredientsBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.parseIngredients(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ParseIngredientsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// analyzeARecipeSearchQuery implements GET /recipes/queries/analyze
func (h *Handler) analyzeARecipeSearchQuery(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/queries/analyze"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AnalyzeARecipeSearchQuery", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.analyzeARecipeSearchQuery(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AnalyzeARecipeSearchQueryResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// quickAnswer implements GET /recipes/quickAnswer
func (h *Handler) quickAnswer(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/quickAnswer"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "QuickAnswer", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.quickAnswer(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.QuickAnswerResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRandomRecipes implements GET /recipes/random
func (h *Handler) getRandomRecipes(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/random"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRandomRecipes", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRandomRecipes(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRandomRecipesResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeEquipment implements POST /recipes/visualizeEquipment
func (h *Handler) visualizeEquipment(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/visualizeEquipment"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeEquipment", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.VisualizeEquipmentBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeEquipment(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeEquipmentResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeIngredients implements POST /recipes/visualizeIngredients
func (h *Handler) visualizeIngredients(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/visualizeIngredients"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeIngredients", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.VisualizeIngredientsBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeIngredients(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeIngredientsResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeRecipeNutrition implements POST /recipes/visualizeNutrition
func (h *Handler) visualizeRecipeNutrition(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/visualizeNutrition"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeRecipeNutrition", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.VisualizeRecipeNutritionBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeRecipeNutrition(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeRecipeNutritionResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizePriceBreakdown implements POST /recipes/visualizePriceEstimator
func (h *Handler) visualizePriceBreakdown(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/visualizePriceEstimator"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizePriceBreakdown", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.VisualizePriceBreakdownBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizePriceBreakdown(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizePriceBreakdownResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// createRecipeCard implements POST /recipes/visualizeRecipe
func (h *Handler) createRecipeCard(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/visualizeRecipe"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "CreateRecipeCard", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.CreateRecipeCardBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.createRecipeCard(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.CreateRecipeCardResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeRecipeTaste implements POST /recipes/visualizeTaste
func (h *Handler) visualizeRecipeTaste(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/visualizeTaste"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeRecipeTaste", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.VisualizeRecipeTasteBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeRecipeTaste(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeRecipeTasteResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getAnalyzedRecipeInstructions implements GET /recipes/{id}/analyzedInstructions
func (h *Handler) getAnalyzedRecipeInstructions(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/analyzedInstructions"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetAnalyzedRecipeInstructions", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getAnalyzedRecipeInstructions(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetAnalyzedRecipeInstructionsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// createRecipeCardGet implements GET /recipes/{id}/card
func (h *Handler) createRecipeCardGet(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/card"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "CreateRecipeCardGet", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.createRecipeCardGet(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.CreateRecipeCardGetResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeRecipeEquipmentByID implements GET /recipes/{id}/equipmentWidget
func (h *Handler) visualizeRecipeEquipmentByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/equipmentWidget"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeRecipeEquipmentByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeRecipeEquipmentByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeRecipeEquipmentByIDResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRecipeEquipmentByID implements GET /recipes/{id}/equipmentWidget.json
func (h *Handler) getRecipeEquipmentByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/equipmentWidget.json"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRecipeEquipmentByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRecipeEquipmentByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRecipeEquipmentByIDResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// equipmentByIDImage implements GET /recipes/{id}/equipmentWidget.png
func (h *Handler) equipmentByIDImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/equipmentWidget.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "EquipmentByIDImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.equipmentByIDImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.EquipmentByIDImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRecipeInformation implements GET /recipes/{id}/information
func (h *Handler) getRecipeInformation(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/information"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRecipeInformation", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRecipeInformation(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRecipeInformationResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeRecipeIngredientsByID implements GET /recipes/{id}/ingredientWidget
func (h *Handler) visualizeRecipeIngredientsByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/ingredientWidget"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeRecipeIngredientsByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeRecipeIngredientsByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeRecipeIngredientsByIDResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRecipeIngredientsByID implements GET /recipes/{id}/ingredientWidget.json
func (h *Handler) getRecipeIngredientsByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/ingredientWidget.json"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRecipeIngredientsByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRecipeIngredientsByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRecipeIngredientsByIDResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// ingredientsByIDImage implements GET /recipes/{id}/ingredientWidget.png
func (h *Handler) ingredientsByIDImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/ingredientWidget.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "IngredientsByIDImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.ingredientsByIDImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.IngredientsByIDImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// recipeNutritionLabelWidget implements GET /recipes/{id}/nutritionLabel
func (h *Handler) recipeNutritionLabelWidget(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/nutritionLabel"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "RecipeNutritionLabelWidget", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.recipeNutritionLabelWidget(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.RecipeNutritionLabelWidgetResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// recipeNutritionLabelImage implements GET /recipes/{id}/nutritionLabel.png
func (h *Handler) recipeNutritionLabelImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/nutritionLabel.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "RecipeNutritionLabelImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.recipeNutritionLabelImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.RecipeNutritionLabelImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeRecipeNutritionByID implements GET /recipes/{id}/nutritionWidget
func (h *Handler) visualizeRecipeNutritionByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/nutritionWidget"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeRecipeNutritionByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeRecipeNutritionByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeRecipeNutritionByIDResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRecipeNutritionWidgetByID implements GET /recipes/{id}/nutritionWidget.json
func (h *Handler) getRecipeNutritionWidgetByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/nutritionWidget.json"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRecipeNutritionWidgetByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRecipeNutritionWidgetByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRecipeNutritionWidgetByIDResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// recipeNutritionByIDImage implements GET /recipes/{id}/nutritionWidget.png
func (h *Handler) recipeNutritionByIDImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/nutritionWidget.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "RecipeNutritionByIDImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.recipeNutritionByIDImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.RecipeNutritionByIDImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeRecipePriceBreakdownByID implements GET /recipes/{id}/priceBreakdownWidget
func (h *Handler) visualizeRecipePriceBreakdownByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/priceBreakdownWidget"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeRecipePriceBreakdownByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeRecipePriceBreakdownByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeRecipePriceBreakdownByIDResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRecipePriceBreakdownByID implements GET /recipes/{id}/priceBreakdownWidget.json
func (h *Handler) getRecipePriceBreakdownByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/priceBreakdownWidget.json"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRecipePriceBreakdownByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRecipePriceBreakdownByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRecipePriceBreakdownByIDResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// priceBreakdownByIDImage implements GET /recipes/{id}/priceBreakdownWidget.png
func (h *Handler) priceBreakdownByIDImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/priceBreakdownWidget.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "PriceBreakdownByIDImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.priceBreakdownByIDImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.PriceBreakdownByIDImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getSimilarRecipes implements GET /recipes/{id}/similar
func (h *Handler) getSimilarRecipes(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/similar"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetSimilarRecipes", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getSimilarRecipes(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetSimilarRecipesResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// summarizeRecipe implements GET /recipes/{id}/summary
func (h *Handler) summarizeRecipe(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/summary"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "SummarizeRecipe", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.summarizeRecipe(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.SummarizeRecipeResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// visualizeRecipeTasteByID implements GET /recipes/{id}/tasteWidget
func (h *Handler) visualizeRecipeTasteByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/tasteWidget"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "VisualizeRecipeTasteByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.visualizeRecipeTasteByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.VisualizeRecipeTasteByIDResponse](res.Body, "text/html"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getRecipeTasteByID implements GET /recipes/{id}/tasteWidget.json
func (h *Handler) getRecipeTasteByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/tasteWidget.json"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetRecipeTasteByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getRecipeTasteByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetRecipeTasteByIDResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// recipeTasteByIDImage implements GET /recipes/{id}/tasteWidget.png
func (h *Handler) recipeTasteByIDImage(w http.ResponseWriter, r *http.Request) {
	const opPath = "/recipes/{id}/tasteWidget.png"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "RecipeTasteByIDImage", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.recipeTasteByIDImage(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.RecipeTasteByIDImageResponse](res.Body, "image/png"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "image/png")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// connectUser implements POST /users/connect
func (h *Handler) connectUser(w http.ResponseWriter, r *http.Request) {
	const opPath = "/users/connect"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "ConnectUser", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.ConnectUserBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.connectUser(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := 200
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.ConnectUserResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}
