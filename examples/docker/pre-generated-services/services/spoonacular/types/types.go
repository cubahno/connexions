// Code generated by oapi-codegen. DO NOT EDIT.

package types

import (
	"fmt"

	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
)

type SearchRecipes_Response_Results []SearchRecipes_Response_Results_Item

func (s SearchRecipes_Response_Results) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipes_Response_Results_Item struct {
	ID        int64   `json:"id" validate:"required"`
	Title     string  `json:"title" validate:"required,min=1"`
	Calories  float32 `json:"calories" validate:"required"`
	Carbs     string  `json:"carbs" validate:"required,min=1"`
	Fat       string  `json:"fat" validate:"required,min=1"`
	Image     string  `json:"image" validate:"required,min=1"`
	ImageType string  `json:"imageType" validate:"required,min=1"`
	Protein   string  `json:"protein" validate:"required,min=1"`
}

func (s SearchRecipes_Response_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByIngredients_Response []SearchRecipesByIngredients_Response_Item

func (s SearchRecipesByIngredients_Response) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByIngredients_Response_MissedIngredients []SearchRecipesByIngredients_Response_MissedIngredients_Item

func (s SearchRecipesByIngredients_Response_MissedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByIngredients_Response_MissedIngredients_Item struct {
	Aisle        string   `json:"aisle" validate:"required,min=1"`
	Amount       float32  `json:"amount" validate:"required"`
	ID           int64    `json:"id" validate:"required"`
	Image        string   `json:"image" validate:"required,min=1"`
	Meta         []string `json:"meta,omitempty"`
	Name         string   `json:"name" validate:"required,min=1"`
	Original     string   `json:"original" validate:"required,min=1"`
	OriginalName string   `json:"originalName" validate:"required,min=1"`
	Unit         string   `json:"unit" validate:"required,min=0"`
	UnitLong     string   `json:"unitLong" validate:"required,min=0"`
	UnitShort    string   `json:"unitShort" validate:"required,min=0"`
}

func (s SearchRecipesByIngredients_Response_MissedIngredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByIngredients_Response_UsedIngredients []SearchRecipesByIngredients_Response_UsedIngredients_Item

func (s SearchRecipesByIngredients_Response_UsedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByIngredients_Response_UsedIngredients_Item struct {
	Aisle        string   `json:"aisle" validate:"required,min=1"`
	Amount       float32  `json:"amount" validate:"required"`
	ID           int64    `json:"id" validate:"required"`
	Image        string   `json:"image" validate:"required,min=1"`
	Meta         []string `json:"meta,omitempty"`
	Name         string   `json:"name" validate:"required,min=1"`
	Original     string   `json:"original" validate:"required,min=1"`
	OriginalName string   `json:"originalName" validate:"required,min=1"`
	Unit         string   `json:"unit" validate:"required,min=0"`
	UnitLong     string   `json:"unitLong" validate:"required,min=0"`
	UnitShort    string   `json:"unitShort" validate:"required,min=0"`
}

func (s SearchRecipesByIngredients_Response_UsedIngredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByIngredients_Response_Item struct {
	ID                    int64                                                 `json:"id" validate:"required"`
	Image                 string                                                `json:"image" validate:"required,min=1"`
	ImageType             string                                                `json:"imageType" validate:"required,min=1"`
	Likes                 int64                                                 `json:"likes" validate:"required"`
	MissedIngredientCount int64                                                 `json:"missedIngredientCount" validate:"required"`
	MissedIngredients     SearchRecipesByIngredients_Response_MissedIngredients `json:"missedIngredients" validate:"required"`
	Title                 string                                                `json:"title" validate:"required,min=1"`
	UnusedIngredients     []map[string]any                                      `json:"unusedIngredients" validate:"required"`
	UsedIngredientCount   float32                                               `json:"usedIngredientCount" validate:"required"`
	UsedIngredients       SearchRecipesByIngredients_Response_UsedIngredients   `json:"usedIngredients" validate:"required"`
}

func (s SearchRecipesByIngredients_Response_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(s.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if err := typesValidator.Var(s.MissedIngredientCount, "required"); err != nil {
		errors = errors.Append("MissedIngredientCount", err)
	}
	if v, ok := any(s.MissedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("MissedIngredients", err)
		}
	}
	if err := typesValidator.Var(s.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(s.UnusedIngredients, "required"); err != nil {
		errors = errors.Append("UnusedIngredients", err)
	}
	if err := typesValidator.Var(s.UsedIngredientCount, "required"); err != nil {
		errors = errors.Append("UsedIngredientCount", err)
	}
	if v, ok := any(s.UsedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UsedIngredients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByNutrients_Response []SearchRecipesByNutrients_Response_Item

func (s SearchRecipesByNutrients_Response) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByNutrients_Response_Item struct {
	Calories  float32 `json:"calories" validate:"required"`
	Carbs     string  `json:"carbs" validate:"required,min=1"`
	Fat       string  `json:"fat" validate:"required,min=1"`
	ID        int64   `json:"id" validate:"required"`
	Image     string  `json:"image" validate:"required,min=1"`
	ImageType string  `json:"imageType" validate:"required,min=1"`
	Protein   string  `json:"protein" validate:"required,min=1"`
	Title     string  `json:"title" validate:"required,min=1"`
}

func (s SearchRecipesByNutrients_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetRecipeInformation_Response_ExtendedIngredients []GetRecipeInformation_Response_ExtendedIngredients_Item

func (g GetRecipeInformation_Response_ExtendedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_ExtendedIngredients_Measures struct {
	Metric GetRecipeInformation_Response_ExtendedIngredients_Measures_Metric `json:"metric"`
	Us     GetRecipeInformation_Response_ExtendedIngredients_Measures_Us     `json:"us"`
}

func (g GetRecipeInformation_Response_ExtendedIngredients_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_ExtendedIngredients_Measures_Metric struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRecipeInformation_Response_ExtendedIngredients_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformation_Response_ExtendedIngredients_Measures_Us struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRecipeInformation_Response_ExtendedIngredients_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformation_Response_ExtendedIngredients_Item struct {
	Aisle        string                                                      `json:"aisle" validate:"required,min=1"`
	Amount       float32                                                     `json:"amount" validate:"required"`
	Consitency   string                                                      `json:"consitency" validate:"required,min=1"`
	ID           int64                                                       `json:"id" validate:"required"`
	Image        string                                                      `json:"image" validate:"required,min=1"`
	Measures     *GetRecipeInformation_Response_ExtendedIngredients_Measures `json:"measures,omitempty"`
	Meta         []string                                                    `json:"meta,omitempty"`
	Name         string                                                      `json:"name" validate:"required,min=1"`
	Original     string                                                      `json:"original" validate:"required,min=1"`
	OriginalName string                                                      `json:"originalName" validate:"required,min=1"`
	Unit         string                                                      `json:"unit" validate:"required,min=0"`
}

func (g GetRecipeInformation_Response_ExtendedIngredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(g.Consitency, "required,min=1"); err != nil {
		errors = errors.Append("Consitency", err)
	}
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(g.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=0"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_WinePairing struct {
	PairedWines    []string                                                 `json:"pairedWines" validate:"required"`
	PairingText    string                                                   `json:"pairingText" validate:"required,min=1"`
	ProductMatches GetRecipeInformation_Response_WinePairing_ProductMatches `json:"productMatches" validate:"required"`
}

func (g GetRecipeInformation_Response_WinePairing) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(g.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(g.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_WinePairing_ProductMatches []GetRecipeInformation_Response_WinePairing_ProductMatches_Item

func (g GetRecipeInformation_Response_WinePairing_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_WinePairing_ProductMatches_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	Description   string  `json:"description" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
	Link          string  `json:"link" validate:"required,min=1"`
}

func (g GetRecipeInformation_Response_WinePairing_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformationBulk_Response []GetRecipeInformationBulk_Response_Item

func (g GetRecipeInformationBulk_Response) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_ExtendedIngredients []GetRecipeInformationBulk_Response_ExtendedIngredients_Item

func (g GetRecipeInformationBulk_Response_ExtendedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_ExtendedIngredients_Measures struct {
	Metric GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Metric `json:"metric"`
	Us     GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Us     `json:"us"`
}

func (g GetRecipeInformationBulk_Response_ExtendedIngredients_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Metric struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Us struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformationBulk_Response_ExtendedIngredients_Item struct {
	Aisle        string                                                          `json:"aisle" validate:"required,min=1"`
	Amount       float32                                                         `json:"amount" validate:"required"`
	Consitency   string                                                          `json:"consitency" validate:"required,min=1"`
	ID           int64                                                           `json:"id" validate:"required"`
	Image        string                                                          `json:"image" validate:"required,min=1"`
	Measures     *GetRecipeInformationBulk_Response_ExtendedIngredients_Measures `json:"measures,omitempty"`
	Meta         []string                                                        `json:"meta,omitempty"`
	Name         string                                                          `json:"name" validate:"required,min=1"`
	Original     string                                                          `json:"original" validate:"required,min=1"`
	OriginalName string                                                          `json:"originalName" validate:"required,min=1"`
	Unit         string                                                          `json:"unit" validate:"required,min=0"`
}

func (g GetRecipeInformationBulk_Response_ExtendedIngredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(g.Consitency, "required,min=1"); err != nil {
		errors = errors.Append("Consitency", err)
	}
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(g.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=0"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_WinePairing struct {
	PairedWines    []string                                                     `json:"pairedWines" validate:"required"`
	PairingText    string                                                       `json:"pairingText" validate:"required,min=1"`
	ProductMatches GetRecipeInformationBulk_Response_WinePairing_ProductMatches `json:"productMatches" validate:"required"`
}

func (g GetRecipeInformationBulk_Response_WinePairing) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(g.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(g.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_WinePairing_ProductMatches []GetRecipeInformationBulk_Response_WinePairing_ProductMatches_Item

func (g GetRecipeInformationBulk_Response_WinePairing_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_WinePairing_ProductMatches_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	Description   string  `json:"description" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
	Link          string  `json:"link" validate:"required,min=1"`
}

func (g GetRecipeInformationBulk_Response_WinePairing_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformationBulk_Response_Item struct {
	ID                       int64                                                 `json:"id" validate:"required"`
	Title                    string                                                `json:"title" validate:"required,min=1"`
	Image                    string                                                `json:"image" validate:"required,min=1"`
	ImageType                string                                                `json:"imageType" validate:"required,min=1"`
	Servings                 float32                                               `json:"servings" validate:"required"`
	ReadyInMinutes           int64                                                 `json:"readyInMinutes" validate:"required"`
	License                  string                                                `json:"license" validate:"required,min=1"`
	SourceName               string                                                `json:"sourceName" validate:"required,min=1"`
	SourceURL                string                                                `json:"sourceUrl" validate:"required,min=1"`
	SpoonacularSourceURL     string                                                `json:"spoonacularSourceUrl" validate:"required,min=1"`
	AggregateLikes           int64                                                 `json:"aggregateLikes" validate:"required"`
	HealthScore              float32                                               `json:"healthScore" validate:"required"`
	SpoonacularScore         float32                                               `json:"spoonacularScore" validate:"required"`
	PricePerServing          float32                                               `json:"pricePerServing" validate:"required"`
	AnalyzedInstructions     []string                                              `json:"analyzedInstructions" validate:"required"`
	Cheap                    bool                                                  `json:"cheap"`
	CreditsText              string                                                `json:"creditsText" validate:"required,min=1"`
	Cuisines                 []string                                              `json:"cuisines" validate:"required"`
	DairyFree                bool                                                  `json:"dairyFree"`
	Diets                    []string                                              `json:"diets" validate:"required"`
	Gaps                     string                                                `json:"gaps" validate:"required,min=1"`
	GlutenFree               bool                                                  `json:"glutenFree"`
	Instructions             string                                                `json:"instructions" validate:"required"`
	Ketogenic                bool                                                  `json:"ketogenic"`
	LowFodmap                bool                                                  `json:"lowFodmap"`
	Occasions                []string                                              `json:"occasions" validate:"required"`
	Sustainable              bool                                                  `json:"sustainable"`
	Vegan                    bool                                                  `json:"vegan"`
	Vegetarian               bool                                                  `json:"vegetarian"`
	VeryHealthy              bool                                                  `json:"veryHealthy"`
	VeryPopular              bool                                                  `json:"veryPopular"`
	Whole30                  bool                                                  `json:"whole30"`
	WeightWatcherSmartPoints float32                                               `json:"weightWatcherSmartPoints" validate:"required"`
	DishTypes                []string                                              `json:"dishTypes" validate:"required"`
	ExtendedIngredients      GetRecipeInformationBulk_Response_ExtendedIngredients `json:"extendedIngredients" validate:"required"`
	Summary                  string                                                `json:"summary" validate:"required,min=1"`
	WinePairing              GetRecipeInformationBulk_Response_WinePairing         `json:"winePairing"`
}

func (g GetRecipeInformationBulk_Response_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Servings, "required"); err != nil {
		errors = errors.Append("Servings", err)
	}
	if err := typesValidator.Var(g.ReadyInMinutes, "required"); err != nil {
		errors = errors.Append("ReadyInMinutes", err)
	}
	if err := typesValidator.Var(g.License, "required,min=1"); err != nil {
		errors = errors.Append("License", err)
	}
	if err := typesValidator.Var(g.SourceName, "required,min=1"); err != nil {
		errors = errors.Append("SourceName", err)
	}
	if err := typesValidator.Var(g.SourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SourceURL", err)
	}
	if err := typesValidator.Var(g.SpoonacularSourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SpoonacularSourceURL", err)
	}
	if err := typesValidator.Var(g.AggregateLikes, "required"); err != nil {
		errors = errors.Append("AggregateLikes", err)
	}
	if err := typesValidator.Var(g.HealthScore, "required"); err != nil {
		errors = errors.Append("HealthScore", err)
	}
	if err := typesValidator.Var(g.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if err := typesValidator.Var(g.PricePerServing, "required"); err != nil {
		errors = errors.Append("PricePerServing", err)
	}
	if err := typesValidator.Var(g.AnalyzedInstructions, "required"); err != nil {
		errors = errors.Append("AnalyzedInstructions", err)
	}
	if err := typesValidator.Var(g.CreditsText, "required,min=1"); err != nil {
		errors = errors.Append("CreditsText", err)
	}
	if err := typesValidator.Var(g.Cuisines, "required"); err != nil {
		errors = errors.Append("Cuisines", err)
	}
	if err := typesValidator.Var(g.Diets, "required"); err != nil {
		errors = errors.Append("Diets", err)
	}
	if err := typesValidator.Var(g.Gaps, "required,min=1"); err != nil {
		errors = errors.Append("Gaps", err)
	}
	if err := typesValidator.Var(g.Instructions, "required"); err != nil {
		errors = errors.Append("Instructions", err)
	}
	if err := typesValidator.Var(g.Occasions, "required"); err != nil {
		errors = errors.Append("Occasions", err)
	}
	if err := typesValidator.Var(g.WeightWatcherSmartPoints, "required"); err != nil {
		errors = errors.Append("WeightWatcherSmartPoints", err)
	}
	if err := typesValidator.Var(g.DishTypes, "required"); err != nil {
		errors = errors.Append("DishTypes", err)
	}
	if v, ok := any(g.ExtendedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ExtendedIngredients", err)
		}
	}
	if err := typesValidator.Var(g.Summary, "required,min=1"); err != nil {
		errors = errors.Append("Summary", err)
	}
	if v, ok := any(g.WinePairing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WinePairing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSimilarRecipes_Response []GetSimilarRecipes_Response_Item

func (g GetSimilarRecipes_Response) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSimilarRecipes_Response_Item struct {
	ID             int64   `json:"id" validate:"required"`
	Title          string  `json:"title" validate:"required,min=1"`
	ImageType      string  `json:"imageType" validate:"required,min=1"`
	ReadyInMinutes int64   `json:"readyInMinutes" validate:"required"`
	Servings       float32 `json:"servings" validate:"required"`
	SourceURL      string  `json:"sourceUrl" validate:"required,min=1"`
}

func (g GetSimilarRecipes_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipes_Response_Recipes []GetRandomRecipes_Response_Recipes_Item

func (g GetRandomRecipes_Response_Recipes) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients []GetRandomRecipes_Response_Recipes_ExtendedIngredients_Item

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures struct {
	Metric GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Metric `json:"metric"`
	Us     GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Us     `json:"us"`
}

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Metric struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Us struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients_Item struct {
	Aisle        string                                                          `json:"aisle" validate:"required,min=1"`
	Amount       float32                                                         `json:"amount" validate:"required"`
	Consitency   string                                                          `json:"consitency" validate:"required,min=1"`
	ID           int64                                                           `json:"id" validate:"required"`
	Image        string                                                          `json:"image" validate:"required,min=1"`
	Measures     *GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures `json:"measures,omitempty"`
	Meta         []string                                                        `json:"meta,omitempty"`
	Name         string                                                          `json:"name" validate:"required,min=1"`
	Original     string                                                          `json:"original" validate:"required,min=1"`
	OriginalName string                                                          `json:"originalName" validate:"required,min=1"`
	Unit         string                                                          `json:"unit" validate:"required,min=0"`
}

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(g.Consitency, "required,min=1"); err != nil {
		errors = errors.Append("Consitency", err)
	}
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(g.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=0"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_WinePairing struct {
	PairedWines    []string                                                     `json:"pairedWines" validate:"required"`
	PairingText    string                                                       `json:"pairingText" validate:"required,min=1"`
	ProductMatches GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches `json:"productMatches" validate:"required"`
}

func (g GetRandomRecipes_Response_Recipes_WinePairing) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(g.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(g.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches []GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches_Item

func (g GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	Description   string  `json:"description" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
	Link          string  `json:"link" validate:"required,min=1"`
}

func (g GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipes_Response_Recipes_Item struct {
	ID                       int64                                                  `json:"id" validate:"required"`
	Title                    string                                                 `json:"title" validate:"required,min=1"`
	Image                    string                                                 `json:"image" validate:"required,min=1"`
	ImageType                string                                                 `json:"imageType" validate:"required,min=1"`
	Servings                 float32                                                `json:"servings" validate:"required"`
	ReadyInMinutes           int64                                                  `json:"readyInMinutes" validate:"required"`
	License                  string                                                 `json:"license" validate:"required,min=1"`
	SourceName               string                                                 `json:"sourceName" validate:"required,min=1"`
	SourceURL                string                                                 `json:"sourceUrl" validate:"required,min=1"`
	SpoonacularSourceURL     string                                                 `json:"spoonacularSourceUrl" validate:"required,min=1"`
	AggregateLikes           float32                                                `json:"aggregateLikes" validate:"required"`
	HealthScore              float32                                                `json:"healthScore" validate:"required"`
	SpoonacularScore         float32                                                `json:"spoonacularScore" validate:"required"`
	PricePerServing          float32                                                `json:"pricePerServing" validate:"required"`
	AnalyzedInstructions     []map[string]any                                       `json:"analyzedInstructions,omitempty"`
	Cheap                    bool                                                   `json:"cheap"`
	CreditsText              string                                                 `json:"creditsText" validate:"required,min=1"`
	Cuisines                 []string                                               `json:"cuisines,omitempty"`
	DairyFree                bool                                                   `json:"dairyFree"`
	Diets                    []string                                               `json:"diets,omitempty"`
	Gaps                     string                                                 `json:"gaps" validate:"required,min=1"`
	GlutenFree               bool                                                   `json:"glutenFree"`
	Instructions             string                                                 `json:"instructions" validate:"required"`
	Ketogenic                bool                                                   `json:"ketogenic"`
	LowFodmap                bool                                                   `json:"lowFodmap"`
	Occasions                []string                                               `json:"occasions,omitempty"`
	Sustainable              bool                                                   `json:"sustainable"`
	Vegan                    bool                                                   `json:"vegan"`
	Vegetarian               bool                                                   `json:"vegetarian"`
	VeryHealthy              bool                                                   `json:"veryHealthy"`
	VeryPopular              bool                                                   `json:"veryPopular"`
	Whole30                  bool                                                   `json:"whole30"`
	WeightWatcherSmartPoints float32                                                `json:"weightWatcherSmartPoints" validate:"required"`
	DishTypes                []string                                               `json:"dishTypes,omitempty"`
	ExtendedIngredients      *GetRandomRecipes_Response_Recipes_ExtendedIngredients `json:"extendedIngredients,omitempty"`
	Summary                  string                                                 `json:"summary" validate:"required,min=1"`
	WinePairing              *GetRandomRecipes_Response_Recipes_WinePairing         `json:"winePairing,omitempty"`
}

func (g GetRandomRecipes_Response_Recipes_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Servings, "required"); err != nil {
		errors = errors.Append("Servings", err)
	}
	if err := typesValidator.Var(g.ReadyInMinutes, "required"); err != nil {
		errors = errors.Append("ReadyInMinutes", err)
	}
	if err := typesValidator.Var(g.License, "required,min=1"); err != nil {
		errors = errors.Append("License", err)
	}
	if err := typesValidator.Var(g.SourceName, "required,min=1"); err != nil {
		errors = errors.Append("SourceName", err)
	}
	if err := typesValidator.Var(g.SourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SourceURL", err)
	}
	if err := typesValidator.Var(g.SpoonacularSourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SpoonacularSourceURL", err)
	}
	if err := typesValidator.Var(g.AggregateLikes, "required"); err != nil {
		errors = errors.Append("AggregateLikes", err)
	}
	if err := typesValidator.Var(g.HealthScore, "required"); err != nil {
		errors = errors.Append("HealthScore", err)
	}
	if err := typesValidator.Var(g.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if err := typesValidator.Var(g.PricePerServing, "required"); err != nil {
		errors = errors.Append("PricePerServing", err)
	}
	if err := typesValidator.Var(g.CreditsText, "required,min=1"); err != nil {
		errors = errors.Append("CreditsText", err)
	}
	if err := typesValidator.Var(g.Gaps, "required,min=1"); err != nil {
		errors = errors.Append("Gaps", err)
	}
	if err := typesValidator.Var(g.Instructions, "required"); err != nil {
		errors = errors.Append("Instructions", err)
	}
	if err := typesValidator.Var(g.WeightWatcherSmartPoints, "required"); err != nil {
		errors = errors.Append("WeightWatcherSmartPoints", err)
	}
	if g.ExtendedIngredients != nil {
		if v, ok := any(g.ExtendedIngredients).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("ExtendedIngredients", err)
			}
		}
	}
	if err := typesValidator.Var(g.Summary, "required,min=1"); err != nil {
		errors = errors.Append("Summary", err)
	}
	if g.WinePairing != nil {
		if v, ok := any(g.WinePairing).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("WinePairing", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteRecipeSearch_Response []AutocompleteRecipeSearch_Response_Item

func (a AutocompleteRecipeSearch_Response) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteRecipeSearch_Response_Item struct {
	ID        int64  `json:"id" validate:"required"`
	Title     string `json:"title" validate:"required,min=1"`
	ImageType string `json:"imageType" validate:"required,min=1"`
}

func (a AutocompleteRecipeSearch_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type GetRecipeEquipmentByID_Response_Equipment []GetRecipeEquipmentByID_Response_Equipment_Item

func (g GetRecipeEquipmentByID_Response_Equipment) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeEquipmentByID_Response_Equipment_Item struct {
	Image string `json:"image" validate:"required,min=1"`
	Name  string `json:"name" validate:"required,min=1"`
}

func (g GetRecipeEquipmentByID_Response_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipePriceBreakdownByID_Response_Ingredients []GetRecipePriceBreakdownByID_Response_Ingredients_Item

func (g GetRecipePriceBreakdownByID_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipePriceBreakdownByID_Response_Ingredients_Amount struct {
	Metric GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Metric `json:"metric"`
	Us     GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Us     `json:"us"`
}

func (g GetRecipePriceBreakdownByID_Response_Ingredients_Amount) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Metric struct {
	Unit  string  `json:"unit" validate:"required,min=0"`
	Value float32 `json:"value" validate:"required"`
}

func (g GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Us struct {
	Unit  string  `json:"unit" validate:"required,min=0"`
	Value float32 `json:"value" validate:"required"`
}

func (g GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipePriceBreakdownByID_Response_Ingredients_Item struct {
	Amount *GetRecipePriceBreakdownByID_Response_Ingredients_Amount `json:"amount,omitempty"`
	Image  string                                                   `json:"image" validate:"required,min=1"`
	Name   string                                                   `json:"name" validate:"required,min=1"`
	Price  float32                                                  `json:"price" validate:"required"`
}

func (g GetRecipePriceBreakdownByID_Response_Ingredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if g.Amount != nil {
		if v, ok := any(g.Amount).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Amount", err)
			}
		}
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Price, "required"); err != nil {
		errors = errors.Append("Price", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeIngredientsByID_Response_Ingredients []GetRecipeIngredientsByID_Response_Ingredients_Item

func (g GetRecipeIngredientsByID_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeIngredientsByID_Response_Ingredients_Amount struct {
	Metric GetRecipeIngredientsByID_Response_Ingredients_Amount_Metric `json:"metric"`
	Us     GetRecipeIngredientsByID_Response_Ingredients_Amount_Us     `json:"us"`
}

func (g GetRecipeIngredientsByID_Response_Ingredients_Amount) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeIngredientsByID_Response_Ingredients_Amount_Metric struct {
	Unit  string  `json:"unit" validate:"required,min=0"`
	Value float32 `json:"value" validate:"required"`
}

func (g GetRecipeIngredientsByID_Response_Ingredients_Amount_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeIngredientsByID_Response_Ingredients_Amount_Us struct {
	Unit  string  `json:"unit" validate:"required,min=0"`
	Value float32 `json:"value" validate:"required"`
}

func (g GetRecipeIngredientsByID_Response_Ingredients_Amount_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeIngredientsByID_Response_Ingredients_Item struct {
	Amount *GetRecipeIngredientsByID_Response_Ingredients_Amount `json:"amount,omitempty"`
	Image  string                                                `json:"image" validate:"required,min=1"`
	Name   string                                                `json:"name" validate:"required,min=1"`
}

func (g GetRecipeIngredientsByID_Response_Ingredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if g.Amount != nil {
		if v, ok := any(g.Amount).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Amount", err)
			}
		}
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeNutritionWidgetByID_Response_Bad []GetRecipeNutritionWidgetByID_Response_Bad_Item

func (g GetRecipeNutritionWidgetByID_Response_Bad) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeNutritionWidgetByID_Response_Bad_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              string  `json:"amount" validate:"required,min=1"`
	Indented            bool    `json:"indented"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (g GetRecipeNutritionWidgetByID_Response_Bad_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeNutritionWidgetByID_Response_Good []GetRecipeNutritionWidgetByID_Response_Good_Item

func (g GetRecipeNutritionWidgetByID_Response_Good) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeNutritionWidgetByID_Response_Good_Item struct {
	Amount              string  `json:"amount" validate:"required,min=1"`
	Indented            bool    `json:"indented"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
	Name                string  `json:"name" validate:"required,min=1"`
}

func (g GetRecipeNutritionWidgetByID_Response_Good_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions []GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Item

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps []GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Item

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients []GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item struct {
	ID            int64  `json:"id" validate:"required"`
	Name          string `json:"name" validate:"required,min=1"`
	LocalizedName string `json:"localizedName" validate:"required,min=1"`
	Image         string `json:"image" validate:"required,min=1"`
}

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment []GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item struct {
	ID            int64  `json:"id" validate:"required"`
	Name          string `json:"name" validate:"required,min=1"`
	LocalizedName string `json:"localizedName" validate:"required,min=1"`
	Image         string `json:"image" validate:"required,min=1"`
}

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Item struct {
	Number      float32                                                                      `json:"number" validate:"required"`
	Step        string                                                                       `json:"step" validate:"required,min=1"`
	Ingredients *GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients `json:"ingredients,omitempty"`
	Equipment   *GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment   `json:"equipment,omitempty"`
}

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if err := typesValidator.Var(g.Step, "required,min=1"); err != nil {
		errors = errors.Append("Step", err)
	}
	if g.Ingredients != nil {
		if v, ok := any(g.Ingredients).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Ingredients", err)
			}
		}
	}
	if g.Equipment != nil {
		if v, ok := any(g.Equipment).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Equipment", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Item struct {
	Name  string                                                           `json:"name" validate:"required"`
	Steps *GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps `json:"steps,omitempty"`
}

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if g.Steps != nil {
		if v, ok := any(g.Steps).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Steps", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_Ingredients []GetAnalyzedRecipeInstructions_Response_Ingredients_Item

func (g GetAnalyzedRecipeInstructions_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_Ingredients_Item struct {
	ID   int64  `json:"id" validate:"required"`
	Name string `json:"name" validate:"required,min=1"`
}

func (g GetAnalyzedRecipeInstructions_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAnalyzedRecipeInstructions_Response_Equipment []GetAnalyzedRecipeInstructions_Response_Equipment_Item

func (g GetAnalyzedRecipeInstructions_Response_Equipment) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_Equipment_Item struct {
	ID   int64  `json:"id" validate:"required"`
	Name string `json:"name" validate:"required,min=1"`
}

func (g GetAnalyzedRecipeInstructions_Response_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients []ExtractRecipeFromWebsite_Response_ExtendedIngredients_Item

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(e) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(e)))
	}
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures struct {
	Metric ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Metric `json:"metric"`
	Us     ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Us     `json:"us"`
}

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(e.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Metric struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Us struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients_Item struct {
	Aisle        string                                                          `json:"aisle" validate:"required,min=1"`
	Amount       float32                                                         `json:"amount" validate:"required"`
	Consitency   string                                                          `json:"consitency" validate:"required,min=1"`
	ID           int64                                                           `json:"id" validate:"required"`
	Image        string                                                          `json:"image" validate:"required,min=1"`
	Measures     *ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures `json:"measures,omitempty"`
	Meta         []string                                                        `json:"meta,omitempty"`
	Name         string                                                          `json:"name" validate:"required,min=1"`
	Original     string                                                          `json:"original" validate:"required,min=1"`
	OriginalName string                                                          `json:"originalName" validate:"required,min=1"`
	Unit         string                                                          `json:"unit" validate:"required,min=0"`
}

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(e.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(e.Consitency, "required,min=1"); err != nil {
		errors = errors.Append("Consitency", err)
	}
	if err := typesValidator.Var(e.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(e.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if e.Measures != nil {
		if v, ok := any(e.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(e.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(e.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(e.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(e.Unit, "required,min=0"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_WinePairing struct {
	PairedWines    []string                                                     `json:"pairedWines" validate:"required"`
	PairingText    string                                                       `json:"pairingText" validate:"required,min=1"`
	ProductMatches ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches `json:"productMatches" validate:"required"`
}

func (e ExtractRecipeFromWebsite_Response_WinePairing) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(e.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(e.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches []ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches_Item

func (e ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(e) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(e)))
	}
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	Description   string  `json:"description" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
	Link          string  `json:"link" validate:"required,min=1"`
}

func (e ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions []AnalyzeRecipeInstructions_Response_ParsedInstructions_Item

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps []AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Item

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients []AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item struct {
	ID            float32 `json:"id" validate:"required"`
	Name          string  `json:"name" validate:"required,min=1"`
	LocalizedName string  `json:"localizedName" validate:"required,min=1"`
	Image         string  `json:"image" validate:"required,min=1"`
}

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment []AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item struct {
	ID            float32 `json:"id" validate:"required"`
	Name          string  `json:"name" validate:"required,min=1"`
	LocalizedName string  `json:"localizedName" validate:"required,min=1"`
	Image         string  `json:"image" validate:"required,min=1"`
}

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Item struct {
	Number      float32                                                                  `json:"number" validate:"required"`
	Step        string                                                                   `json:"step" validate:"required,min=1"`
	Ingredients *AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients `json:"ingredients,omitempty"`
	Equipment   *AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment   `json:"equipment,omitempty"`
}

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if err := typesValidator.Var(a.Step, "required,min=1"); err != nil {
		errors = errors.Append("Step", err)
	}
	if a.Ingredients != nil {
		if v, ok := any(a.Ingredients).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Ingredients", err)
			}
		}
	}
	if a.Equipment != nil {
		if v, ok := any(a.Equipment).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Equipment", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Item struct {
	Name  string                                                       `json:"name" validate:"required"`
	Steps *AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps `json:"steps,omitempty"`
}

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if a.Steps != nil {
		if v, ok := any(a.Steps).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Steps", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_Ingredients []AnalyzeRecipeInstructions_Response_Ingredients_Item

func (a AnalyzeRecipeInstructions_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_Ingredients_Item struct {
	ID   float32 `json:"id" validate:"required"`
	Name string  `json:"name" validate:"required,min=1"`
}

func (a AnalyzeRecipeInstructions_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeRecipeInstructions_Response_Equipment []AnalyzeRecipeInstructions_Response_Equipment_Item

func (a AnalyzeRecipeInstructions_Response_Equipment) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_Equipment_Item struct {
	ID   float32 `json:"id" validate:"required"`
	Name string  `json:"name" validate:"required,min=1"`
}

func (a AnalyzeRecipeInstructions_Response_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeARecipeSearchQuery_Response_Dishes []AnalyzeARecipeSearchQuery_Response_Dishes_Item

func (a AnalyzeARecipeSearchQuery_Response_Dishes) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeARecipeSearchQuery_Response_Dishes_Item struct {
	Image string `json:"image" validate:"required,min=1"`
	Name  string `json:"name" validate:"required,min=1"`
}

func (a AnalyzeARecipeSearchQuery_Response_Dishes_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeARecipeSearchQuery_Response_Ingredients []AnalyzeARecipeSearchQuery_Response_Ingredients_Item

func (a AnalyzeARecipeSearchQuery_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeARecipeSearchQuery_Response_Ingredients_Item struct {
	Image   string `json:"image" validate:"required,min=1"`
	Include bool   `json:"include"`
	Name    string `json:"name" validate:"required,min=1"`
}

func (a AnalyzeARecipeSearchQuery_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type ParseIngredients_Response []ParseIngredients_Response_Item

func (p ParseIngredients_Response) Validate() error {
	if p == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(p) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(p)))
	}
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_EstimatedCost struct {
	Value float32 `json:"value" validate:"required"`
	Unit  string  `json:"unit" validate:"required,min=1"`
}

func (p ParseIngredients_Response_EstimatedCost) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition struct {
	Nutrients        ParseIngredients_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	Properties       ParseIngredients_Response_Nutrition_Properties       `json:"properties" validate:"required"`
	Flavonoids       ParseIngredients_Response_Nutrition_Flavonoids       `json:"flavonoids" validate:"required"`
	CaloricBreakdown ParseIngredients_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
	WeightPerServing ParseIngredients_Response_Nutrition_WeightPerServing `json:"weightPerServing"`
}

func (p ParseIngredients_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(p.Properties).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Properties", err)
		}
	}
	if v, ok := any(p.Flavonoids).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Flavonoids", err)
		}
	}
	if v, ok := any(p.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if v, ok := any(p.WeightPerServing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WeightPerServing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_Nutrition_Nutrients []ParseIngredients_Response_Nutrition_Nutrients_Item

func (p ParseIngredients_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(p) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(p)))
	}
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (p ParseIngredients_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition_Properties []ParseIngredients_Response_Nutrition_Properties_Item

func (p ParseIngredients_Response_Nutrition_Properties) Validate() error {
	var errors runtime.ValidationErrors
	if len(p) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(p)))
	}
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_Nutrition_Properties_Item struct {
	Name   string  `json:"name" validate:"required,min=1"`
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required"`
}

func (p ParseIngredients_Response_Nutrition_Properties_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition_Flavonoids []ParseIngredients_Response_Nutrition_Flavonoids_Item

func (p ParseIngredients_Response_Nutrition_Flavonoids) Validate() error {
	var errors runtime.ValidationErrors
	if len(p) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(p)))
	}
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_Nutrition_Flavonoids_Item struct {
	Name   string  `json:"name" validate:"required,min=1"`
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required"`
}

func (p ParseIngredients_Response_Nutrition_Flavonoids_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (p ParseIngredients_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition_WeightPerServing struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (p ParseIngredients_Response_Nutrition_WeightPerServing) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Item struct {
	ID            int64                                   `json:"id" validate:"required"`
	Original      string                                  `json:"original" validate:"required,min=1"`
	OriginalName  string                                  `json:"originalName" validate:"required,min=1"`
	Name          string                                  `json:"name" validate:"required,min=1"`
	NameClean     string                                  `json:"nameClean" validate:"required,min=1"`
	Amount        float32                                 `json:"amount" validate:"required"`
	Unit          string                                  `json:"unit" validate:"required,min=1"`
	UnitShort     string                                  `json:"unitShort" validate:"required,min=1"`
	UnitLong      string                                  `json:"unitLong" validate:"required,min=1"`
	PossibleUnits []string                                `json:"possibleUnits" validate:"required"`
	EstimatedCost ParseIngredients_Response_EstimatedCost `json:"estimatedCost"`
	Consistency   string                                  `json:"consistency" validate:"required,min=1"`
	Aisle         string                                  `json:"aisle" validate:"required,min=1"`
	Image         string                                  `json:"image" validate:"required,min=1"`
	Meta          []string                                `json:"meta" validate:"required"`
	Nutrition     ParseIngredients_Response_Nutrition     `json:"nutrition"`
}

func (p ParseIngredients_Response_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(p.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(p.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(p.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(p.NameClean, "required,min=1"); err != nil {
		errors = errors.Append("NameClean", err)
	}
	if err := typesValidator.Var(p.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(p.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(p.UnitShort, "required,min=1"); err != nil {
		errors = errors.Append("UnitShort", err)
	}
	if err := typesValidator.Var(p.UnitLong, "required,min=1"); err != nil {
		errors = errors.Append("UnitLong", err)
	}
	if err := typesValidator.Var(p.PossibleUnits, "required"); err != nil {
		errors = errors.Append("PossibleUnits", err)
	}
	if v, ok := any(p.EstimatedCost).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EstimatedCost", err)
		}
	}
	if err := typesValidator.Var(p.Consistency, "required,min=1"); err != nil {
		errors = errors.Append("Consistency", err)
	}
	if err := typesValidator.Var(p.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(p.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(p.Meta, "required"); err != nil {
		errors = errors.Append("Meta", err)
	}
	if v, ok := any(p.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Calories struct {
	ConfidenceRange95Percent GuessNutritionByDishName_Response_Calories_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                             `json:"standardDeviation" validate:"required"`
	Unit                     string                                                              `json:"unit" validate:"required,min=1"`
	Value                    float32                                                             `json:"value" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Calories) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(g.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Calories_ConfidenceRange95Percent struct {
	Max float32 `json:"max" validate:"required"`
	Min float32 `json:"min" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Calories_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GuessNutritionByDishName_Response_Carbs struct {
	ConfidenceRange95Percent GuessNutritionByDishName_Response_Carbs_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                          `json:"standardDeviation" validate:"required"`
	Unit                     string                                                           `json:"unit" validate:"required,min=1"`
	Value                    float32                                                          `json:"value" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Carbs) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(g.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Carbs_ConfidenceRange95Percent struct {
	Max float32 `json:"max" validate:"required"`
	Min float32 `json:"min" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Carbs_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GuessNutritionByDishName_Response_Fat struct {
	ConfidenceRange95Percent GuessNutritionByDishName_Response_Fat_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                        `json:"standardDeviation" validate:"required"`
	Unit                     string                                                         `json:"unit" validate:"required,min=1"`
	Value                    float32                                                        `json:"value" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Fat) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(g.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Fat_ConfidenceRange95Percent struct {
	Max float32 `json:"max" validate:"required"`
	Min float32 `json:"min" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Fat_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GuessNutritionByDishName_Response_Protein struct {
	ConfidenceRange95Percent GuessNutritionByDishName_Response_Protein_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                            `json:"standardDeviation" validate:"required"`
	Unit                     string                                                             `json:"unit" validate:"required,min=1"`
	Value                    float32                                                            `json:"value" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Protein) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(g.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Protein_ConfidenceRange95Percent struct {
	Max float32 `json:"max" validate:"required"`
	Min float32 `json:"min" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Protein_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_EstimatedCost struct {
	Value float32 `json:"value" validate:"required"`
	Unit  string  `json:"unit" validate:"required,min=1"`
}

func (g GetIngredientInformation_Response_EstimatedCost) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_Nutrition struct {
	Nutrients        GetIngredientInformation_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	Properties       GetIngredientInformation_Response_Nutrition_Properties       `json:"properties" validate:"required"`
	CaloricBreakdown GetIngredientInformation_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
	WeightPerServing GetIngredientInformation_Response_Nutrition_WeightPerServing `json:"weightPerServing"`
}

func (g GetIngredientInformation_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(g.Properties).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Properties", err)
		}
	}
	if v, ok := any(g.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if v, ok := any(g.WeightPerServing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WeightPerServing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientInformation_Response_Nutrition_Nutrients []GetIngredientInformation_Response_Nutrition_Nutrients_Item

func (g GetIngredientInformation_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientInformation_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (g GetIngredientInformation_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_Nutrition_Properties []GetIngredientInformation_Response_Nutrition_Properties_Item

func (g GetIngredientInformation_Response_Nutrition_Properties) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientInformation_Response_Nutrition_Properties_Item struct {
	Name   string  `json:"name" validate:"required,min=1"`
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required"`
}

func (g GetIngredientInformation_Response_Nutrition_Properties_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (g GetIngredientInformation_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_Nutrition_WeightPerServing struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetIngredientInformation_Response_Nutrition_WeightPerServing) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ComputeGlycemicLoad_Response_Ingredients []ComputeGlycemicLoad_Response_Ingredients_Item

func (c ComputeGlycemicLoad_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(c) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(c)))
	}
	for i, item := range c {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ComputeGlycemicLoad_Response_Ingredients_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Original      string  `json:"original" validate:"required,min=1"`
	GlycemicIndex float32 `json:"glycemicIndex" validate:"required"`
	GlycemicLoad  float32 `json:"glycemicLoad" validate:"required"`
}

func (c ComputeGlycemicLoad_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AutocompleteIngredientSearch_Response []AutocompleteIngredientSearch_Response_Item

func (a AutocompleteIngredientSearch_Response) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteIngredientSearch_Response_Item struct {
	Name          string   `json:"name" validate:"required,min=1"`
	Image         string   `json:"image" validate:"required,min=1"`
	ID            *int64   `json:"id,omitempty"`
	Aisle         *string  `json:"aisle,omitempty" validate:"omitempty,min=1"`
	PossibleUnits []string `json:"possibleUnits,omitempty"`
}

func (a AutocompleteIngredientSearch_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type IngredientSearch_Response_Results []IngredientSearch_Response_Results_Item

func (i IngredientSearch_Response_Results) Validate() error {
	var errors runtime.ValidationErrors
	if len(i) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(i)))
	}
	for i, item := range i {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type IngredientSearch_Response_Results_Item struct {
	ID    int64  `json:"id" validate:"required"`
	Name  string `json:"name" validate:"required,min=1"`
	Image string `json:"image" validate:"required,min=1"`
}

func (i IngredientSearch_Response_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type SearchGroceryProducts_Response_Products []SearchGroceryProducts_Response_Products_Item

func (s SearchGroceryProducts_Response_Products) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProducts_Response_Products_Item struct {
	ID        int64  `json:"id" validate:"required"`
	Title     string `json:"title" validate:"required,min=1"`
	ImageType string `json:"imageType" validate:"required,min=1"`
}

func (s SearchGroceryProducts_Response_Products_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchGroceryProductsByUPC_Response_Ingredients []SearchGroceryProductsByUPC_Response_Ingredients_Item

func (s SearchGroceryProductsByUPC_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProductsByUPC_Response_Ingredients_Item struct {
	Description *struct{} `json:"description,omitempty"`
	Name        string    `json:"name" validate:"required"`
	SafetyLevel *struct{} `json:"safety_level,omitempty"`
}

func (s SearchGroceryProductsByUPC_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchGroceryProductsByUPC_Response_Nutrition struct {
	Nutrients        SearchGroceryProductsByUPC_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	CaloricBreakdown SearchGroceryProductsByUPC_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
}

func (s SearchGroceryProductsByUPC_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(s.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProductsByUPC_Response_Nutrition_Nutrients []SearchGroceryProductsByUPC_Response_Nutrition_Nutrients_Item

func (s SearchGroceryProductsByUPC_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProductsByUPC_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (s SearchGroceryProductsByUPC_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchGroceryProductsByUPC_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (s SearchGroceryProductsByUPC_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchGroceryProductsByUPC_Response_Servings struct {
	Number float32 `json:"number" validate:"required"`
	Size   float32 `json:"size" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (s SearchGroceryProductsByUPC_Response_Servings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchCustomFoods_Response_CustomFoods []SearchCustomFoods_Response_CustomFoods_Item

func (s SearchCustomFoods_Response_CustomFoods) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchCustomFoods_Response_CustomFoods_Item struct {
	ID       int64   `json:"id" validate:"required"`
	Title    string  `json:"title" validate:"required,min=1"`
	Servings float32 `json:"servings" validate:"required"`
	ImageURL string  `json:"imageUrl" validate:"required,min=1"`
	Price    float32 `json:"price" validate:"required"`
}

func (s SearchCustomFoods_Response_CustomFoods_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetProductInformation_Response_Ingredients []GetProductInformation_Response_Ingredients_Item

func (g GetProductInformation_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetProductInformation_Response_Ingredients_Item struct {
	Description *struct{} `json:"description,omitempty"`
	Name        string    `json:"name" validate:"required,min=1"`
	SafetyLevel *struct{} `json:"safety_level,omitempty"`
}

func (g GetProductInformation_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetProductInformation_Response_Nutrition struct {
	Nutrients        GetProductInformation_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	CaloricBreakdown GetProductInformation_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
}

func (g GetProductInformation_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(g.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetProductInformation_Response_Nutrition_Nutrients []GetProductInformation_Response_Nutrition_Nutrients_Item

func (g GetProductInformation_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetProductInformation_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (g GetProductInformation_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetProductInformation_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (g GetProductInformation_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetProductInformation_Response_Servings struct {
	Number float32 `json:"number" validate:"required"`
	Size   float32 `json:"size" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetProductInformation_Response_Servings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetComparableProducts_Response_ComparableProducts struct {
	Calories         []map[string]any                                                   `json:"calories" validate:"required"`
	Likes            []map[string]any                                                   `json:"likes" validate:"required"`
	Price            []map[string]any                                                   `json:"price" validate:"required"`
	Protein          GetComparableProducts_Response_ComparableProducts_Protein          `json:"protein" validate:"required"`
	SpoonacularScore GetComparableProducts_Response_ComparableProducts_SpoonacularScore `json:"spoonacularScore" validate:"required"`
	Sugar            []map[string]any                                                   `json:"sugar" validate:"required"`
}

func (g GetComparableProducts_Response_ComparableProducts) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Calories, "required"); err != nil {
		errors = errors.Append("Calories", err)
	}
	if err := typesValidator.Var(g.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if err := typesValidator.Var(g.Price, "required"); err != nil {
		errors = errors.Append("Price", err)
	}
	if v, ok := any(g.Protein).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Protein", err)
		}
	}
	if v, ok := any(g.SpoonacularScore).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SpoonacularScore", err)
		}
	}
	if err := typesValidator.Var(g.Sugar, "required"); err != nil {
		errors = errors.Append("Sugar", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetComparableProducts_Response_ComparableProducts_Protein []GetComparableProducts_Response_ComparableProducts_Protein_Item

func (g GetComparableProducts_Response_ComparableProducts_Protein) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetComparableProducts_Response_ComparableProducts_Protein_Item struct {
	Difference float32 `json:"difference" validate:"required"`
	ID         int64   `json:"id" validate:"required"`
	Image      string  `json:"image" validate:"required,min=1"`
	Title      string  `json:"title" validate:"required,min=1"`
}

func (g GetComparableProducts_Response_ComparableProducts_Protein_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetComparableProducts_Response_ComparableProducts_SpoonacularScore []GetComparableProducts_Response_ComparableProducts_SpoonacularScore_Item

func (g GetComparableProducts_Response_ComparableProducts_SpoonacularScore) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetComparableProducts_Response_ComparableProducts_SpoonacularScore_Item struct {
	Difference float32 `json:"difference" validate:"required"`
	ID         int64   `json:"id" validate:"required"`
	Image      string  `json:"image" validate:"required,min=1"`
	Title      string  `json:"title" validate:"required,min=1"`
}

func (g GetComparableProducts_Response_ComparableProducts_SpoonacularScore_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AutocompleteProductSearch_Response_Results []AutocompleteProductSearch_Response_Results_Item

func (a AutocompleteProductSearch_Response_Results) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteProductSearch_Response_Results_Item struct {
	ID    int64  `json:"id" validate:"required"`
	Title string `json:"title" validate:"required,min=1"`
}

func (a AutocompleteProductSearch_Response_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type ClassifyGroceryProductBulkBody_Item struct {
	Title   string `json:"title" validate:"required,min=1"`
	Upc     string `json:"upc" validate:"required"`
	PluCode string `json:"plu_code" validate:"required"`
}

func (c ClassifyGroceryProductBulkBody_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ClassifyGroceryProductBulk_Response []ClassifyGroceryProductBulk_Response_Item

func (c ClassifyGroceryProductBulk_Response) Validate() error {
	if c == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(c) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(c)))
	}
	for i, item := range c {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ClassifyGroceryProductBulk_Response_Item struct {
	CleanTitle  string   `json:"cleanTitle" validate:"required,min=1"`
	Image       string   `json:"image" validate:"required,min=1"`
	Category    string   `json:"category" validate:"required,min=1"`
	Breadcrumbs []string `json:"breadcrumbs" validate:"required"`
	UsdaCode    int64    `json:"usdaCode" validate:"required"`
}

func (c ClassifyGroceryProductBulk_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type MapIngredientsToGroceryProducts_Response []MapIngredientsToGroceryProducts_Response_Item

func (m MapIngredientsToGroceryProducts_Response) Validate() error {
	if m == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(m) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(m)))
	}
	for i, item := range m {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MapIngredientsToGroceryProducts_Response_Products []MapIngredientsToGroceryProducts_Response_Products_Item

func (m MapIngredientsToGroceryProducts_Response_Products) Validate() error {
	var errors runtime.ValidationErrors
	if len(m) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(m)))
	}
	for i, item := range m {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MapIngredientsToGroceryProducts_Response_Products_Item struct {
	ID    int64  `json:"id" validate:"required"`
	Title string `json:"title" validate:"required,min=1"`
	Upc   string `json:"upc" validate:"required,min=1"`
}

func (m MapIngredientsToGroceryProducts_Response_Products_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type MapIngredientsToGroceryProducts_Response_Item struct {
	Original        string                                            `json:"original" validate:"required,min=1"`
	OriginalName    string                                            `json:"originalName" validate:"required,min=1"`
	IngredientImage string                                            `json:"ingredientImage" validate:"required,min=1"`
	Meta            []string                                          `json:"meta" validate:"required"`
	Products        MapIngredientsToGroceryProducts_Response_Products `json:"products" validate:"required"`
}

func (m MapIngredientsToGroceryProducts_Response_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(m.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(m.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(m.IngredientImage, "required,min=1"); err != nil {
		errors = errors.Append("IngredientImage", err)
	}
	if err := typesValidator.Var(m.Meta, "required"); err != nil {
		errors = errors.Append("Meta", err)
	}
	if v, ok := any(m.Products).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Products", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteMenuItemSearch_Response_Results []AutocompleteMenuItemSearch_Response_Results_Item

func (a AutocompleteMenuItemSearch_Response_Results) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteMenuItemSearch_Response_Results_Item struct {
	ID    int64  `json:"id" validate:"required"`
	Title string `json:"title" validate:"required,min=1"`
}

func (a AutocompleteMenuItemSearch_Response_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type SearchMenuItems_Response_MenuItems []SearchMenuItems_Response_MenuItems_Item

func (s SearchMenuItems_Response_MenuItems) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchMenuItems_Response_MenuItems_Servings struct {
	Number float32 `json:"number" validate:"required"`
	Size   float32 `json:"size" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (s SearchMenuItems_Response_MenuItems_Servings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchMenuItems_Response_MenuItems_Item struct {
	ID              int64                                        `json:"id" validate:"required"`
	Title           string                                       `json:"title" validate:"required,min=1"`
	RestaurantChain string                                       `json:"restaurantChain" validate:"required,min=1"`
	Image           string                                       `json:"image" validate:"required,min=1"`
	ImageType       string                                       `json:"imageType" validate:"required,min=1"`
	Servings        *SearchMenuItems_Response_MenuItems_Servings `json:"servings,omitempty"`
}

func (s SearchMenuItems_Response_MenuItems_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(s.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(s.RestaurantChain, "required,min=1"); err != nil {
		errors = errors.Append("RestaurantChain", err)
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if s.Servings != nil {
		if v, ok := any(s.Servings).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Servings", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMenuItemInformation_Response_Nutrition struct {
	Nutrients        GetMenuItemInformation_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	CaloricBreakdown GetMenuItemInformation_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
}

func (g GetMenuItemInformation_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(g.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMenuItemInformation_Response_Nutrition_Nutrients []GetMenuItemInformation_Response_Nutrition_Nutrients_Item

func (g GetMenuItemInformation_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMenuItemInformation_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (g GetMenuItemInformation_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMenuItemInformation_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (g GetMenuItemInformation_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMenuItemInformation_Response_Servings struct {
	Number float32 `json:"number" validate:"required"`
	Size   float32 `json:"size" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetMenuItemInformation_Response_Servings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateMealPlan_Response_Meals []GenerateMealPlan_Response_Meals_Item

func (g GenerateMealPlan_Response_Meals) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateMealPlan_Response_Meals_Item struct {
	ID             int64   `json:"id" validate:"required"`
	Title          string  `json:"title" validate:"required,min=1"`
	ImageType      string  `json:"imageType" validate:"required,min=1"`
	ReadyInMinutes int64   `json:"readyInMinutes" validate:"required"`
	Servings       float32 `json:"servings" validate:"required"`
	SourceURL      string  `json:"sourceUrl" validate:"required,min=1"`
}

func (g GenerateMealPlan_Response_Meals_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateMealPlan_Response_Nutrients struct {
	Calories      float32 `json:"calories" validate:"required"`
	Carbohydrates float32 `json:"carbohydrates" validate:"required"`
	Fat           float32 `json:"fat" validate:"required"`
	Protein       float32 `json:"protein" validate:"required"`
}

func (g GenerateMealPlan_Response_Nutrients) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days []GetMealPlanWeek_Response_Days_Item

func (g GetMealPlanWeek_Response_Days) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummary struct {
	Nutrients GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummary) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients []GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients_Item

func (g GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast struct {
	Nutrients GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients []GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients_Item

func (g GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_NutritionSummaryLunch struct {
	Nutrients GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryLunch) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients []GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients_Item

func (g GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_NutritionSummaryDinner struct {
	Nutrients GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryDinner) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients []GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients_Item

func (g GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_Items []GetMealPlanWeek_Response_Days_Items_Item

func (g GetMealPlanWeek_Response_Days_Items) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_Items_Value struct {
	Servings  float32 `json:"servings" validate:"required"`
	ID        float32 `json:"id" validate:"required"`
	Title     string  `json:"title" validate:"required,min=1"`
	ImageType string  `json:"imageType" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_Items_Value) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_Items_Item struct {
	ID       int64                                      `json:"id" validate:"required"`
	Slot     int64                                      `json:"slot" validate:"required"`
	Position int64                                      `json:"position" validate:"required"`
	Type     string                                     `json:"type" validate:"required,min=1"`
	Value    *GetMealPlanWeek_Response_Days_Items_Value `json:"value,omitempty"`
}

func (g GetMealPlanWeek_Response_Days_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Slot, "required"); err != nil {
		errors = errors.Append("Slot", err)
	}
	if err := typesValidator.Var(g.Position, "required"); err != nil {
		errors = errors.Append("Position", err)
	}
	if err := typesValidator.Var(g.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if g.Value != nil {
		if v, ok := any(g.Value).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Value", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_Item struct {
	NutritionSummary          *GetMealPlanWeek_Response_Days_NutritionSummary          `json:"nutritionSummary,omitempty"`
	NutritionSummaryBreakfast *GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast `json:"nutritionSummaryBreakfast,omitempty"`
	NutritionSummaryLunch     *GetMealPlanWeek_Response_Days_NutritionSummaryLunch     `json:"nutritionSummaryLunch,omitempty"`
	NutritionSummaryDinner    *GetMealPlanWeek_Response_Days_NutritionSummaryDinner    `json:"nutritionSummaryDinner,omitempty"`
	Date                      float32                                                  `json:"date" validate:"required"`
	Day                       string                                                   `json:"day" validate:"required,min=1"`
	Items                     *GetMealPlanWeek_Response_Days_Items                     `json:"items,omitempty"`
}

func (g GetMealPlanWeek_Response_Days_Item) Validate() error {
	var errors runtime.ValidationErrors
	if g.NutritionSummary != nil {
		if v, ok := any(g.NutritionSummary).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummary", err)
			}
		}
	}
	if g.NutritionSummaryBreakfast != nil {
		if v, ok := any(g.NutritionSummaryBreakfast).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryBreakfast", err)
			}
		}
	}
	if g.NutritionSummaryLunch != nil {
		if v, ok := any(g.NutritionSummaryLunch).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryLunch", err)
			}
		}
	}
	if g.NutritionSummaryDinner != nil {
		if v, ok := any(g.NutritionSummaryDinner).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryDinner", err)
			}
		}
	}
	if err := typesValidator.Var(g.Date, "required"); err != nil {
		errors = errors.Append("Date", err)
	}
	if err := typesValidator.Var(g.Day, "required,min=1"); err != nil {
		errors = errors.Append("Day", err)
	}
	if g.Items != nil {
		if v, ok := any(g.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplates_Response_Templates []GetMealPlanTemplates_Response_Templates_Item

func (g GetMealPlanTemplates_Response_Templates) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplates_Response_Templates_Item struct {
	ID   int64  `json:"id" validate:"required"`
	Name string `json:"name" validate:"required,min=1"`
}

func (g GetMealPlanTemplates_Response_Templates_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AddMealPlanTemplate_Response_Items []AddMealPlanTemplate_Response_Items_Item

func (a AddMealPlanTemplate_Response_Items) Validate() error {
	if a == nil {
		return runtime.NewValidationError("Array", "must have at least 1 items, got 0")
	}
	var errors runtime.ValidationErrors
	if len(a) < 1 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 1 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddMealPlanTemplate_Response_Items_Value struct {
	ID        *int64   `json:"id,omitempty"`
	Servings  *float32 `json:"servings,omitempty"`
	Title     *string  `json:"title,omitempty" validate:"omitempty,min=1"`
	ImageType *string  `json:"imageType,omitempty" validate:"omitempty,min=1"`
}

func (a AddMealPlanTemplate_Response_Items_Value) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AddMealPlanTemplate_Response_Items_Item struct {
	Day      int64                                     `json:"day" validate:"required"`
	Slot     int64                                     `json:"slot" validate:"required"`
	Position int64                                     `json:"position" validate:"required"`
	Type     string                                    `json:"type" validate:"required,min=1"`
	Value    *AddMealPlanTemplate_Response_Items_Value `json:"value,omitempty"`
}

func (a AddMealPlanTemplate_Response_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Day, "required"); err != nil {
		errors = errors.Append("Day", err)
	}
	if err := typesValidator.Var(a.Slot, "required"); err != nil {
		errors = errors.Append("Slot", err)
	}
	if err := typesValidator.Var(a.Position, "required"); err != nil {
		errors = errors.Append("Position", err)
	}
	if err := typesValidator.Var(a.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if a.Value != nil {
		if v, ok := any(a.Value).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Value", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days []GetMealPlanTemplate_Response_Days_Item

func (g GetMealPlanTemplate_Response_Days) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummary struct {
	Nutrients GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummary) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients []GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients_Item

func (g GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast struct {
	Nutrients GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients []GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients_Item

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryLunch struct {
	Nutrients GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryLunch) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients []GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients_Item

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryDinner struct {
	Nutrients GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryDinner) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients []GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients_Item

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_Items []GetMealPlanTemplate_Response_Days_Items_Item

func (g GetMealPlanTemplate_Response_Days_Items) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_Items_Value struct {
	ID        float32 `json:"id" validate:"required"`
	Title     string  `json:"title" validate:"required,min=1"`
	ImageType string  `json:"imageType" validate:"required,min=1"`
}

func (g GetMealPlanTemplate_Response_Days_Items_Value) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_Items_Item struct {
	ID       int64                                          `json:"id" validate:"required"`
	Slot     int64                                          `json:"slot" validate:"required"`
	Position int64                                          `json:"position" validate:"required"`
	Type     string                                         `json:"type" validate:"required,min=1"`
	Value    *GetMealPlanTemplate_Response_Days_Items_Value `json:"value,omitempty"`
}

func (g GetMealPlanTemplate_Response_Days_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Slot, "required"); err != nil {
		errors = errors.Append("Slot", err)
	}
	if err := typesValidator.Var(g.Position, "required"); err != nil {
		errors = errors.Append("Position", err)
	}
	if err := typesValidator.Var(g.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if g.Value != nil {
		if v, ok := any(g.Value).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Value", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_Item struct {
	NutritionSummary          *GetMealPlanTemplate_Response_Days_NutritionSummary          `json:"nutritionSummary,omitempty"`
	NutritionSummaryBreakfast *GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast `json:"nutritionSummaryBreakfast,omitempty"`
	NutritionSummaryLunch     *GetMealPlanTemplate_Response_Days_NutritionSummaryLunch     `json:"nutritionSummaryLunch,omitempty"`
	NutritionSummaryDinner    *GetMealPlanTemplate_Response_Days_NutritionSummaryDinner    `json:"nutritionSummaryDinner,omitempty"`
	Day                       string                                                       `json:"day" validate:"required,min=1"`
	Items                     *GetMealPlanTemplate_Response_Days_Items                     `json:"items,omitempty"`
}

func (g GetMealPlanTemplate_Response_Days_Item) Validate() error {
	var errors runtime.ValidationErrors
	if g.NutritionSummary != nil {
		if v, ok := any(g.NutritionSummary).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummary", err)
			}
		}
	}
	if g.NutritionSummaryBreakfast != nil {
		if v, ok := any(g.NutritionSummaryBreakfast).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryBreakfast", err)
			}
		}
	}
	if g.NutritionSummaryLunch != nil {
		if v, ok := any(g.NutritionSummaryLunch).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryLunch", err)
			}
		}
	}
	if g.NutritionSummaryDinner != nil {
		if v, ok := any(g.NutritionSummaryDinner).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryDinner", err)
			}
		}
	}
	if err := typesValidator.Var(g.Day, "required,min=1"); err != nil {
		errors = errors.Append("Day", err)
	}
	if g.Items != nil {
		if v, ok := any(g.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles []GetShoppingList_Response_Aisles_Item

func (g GetShoppingList_Response_Aisles) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles_Items []GetShoppingList_Response_Aisles_Items_Item

func (g GetShoppingList_Response_Aisles_Items) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles_Items_Measures struct {
	Original GetShoppingList_Response_Aisles_Items_Measures_Original `json:"original"`
	Metric   GetShoppingList_Response_Aisles_Items_Measures_Metric   `json:"metric"`
	Us       GetShoppingList_Response_Aisles_Items_Measures_Us       `json:"us"`
}

func (g GetShoppingList_Response_Aisles_Items_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Original).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Original", err)
		}
	}
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles_Items_Measures_Original struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetShoppingList_Response_Aisles_Items_Measures_Original) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetShoppingList_Response_Aisles_Items_Measures_Metric struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetShoppingList_Response_Aisles_Items_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetShoppingList_Response_Aisles_Items_Measures_Us struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetShoppingList_Response_Aisles_Items_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetShoppingList_Response_Aisles_Items_Item struct {
	ID           int64                                           `json:"id" validate:"required"`
	Name         string                                          `json:"name" validate:"required,min=1"`
	Measures     *GetShoppingList_Response_Aisles_Items_Measures `json:"measures,omitempty"`
	PantryItem   bool                                            `json:"pantryItem"`
	Aisle        string                                          `json:"aisle" validate:"required,min=1"`
	Cost         float32                                         `json:"cost" validate:"required"`
	IngredientID int64                                           `json:"ingredientId" validate:"required"`
}

func (g GetShoppingList_Response_Aisles_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(g.IngredientID, "required"); err != nil {
		errors = errors.Append("IngredientID", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles_Item struct {
	Aisle string                                 `json:"aisle" validate:"required,min=1"`
	Items *GetShoppingList_Response_Aisles_Items `json:"items,omitempty"`
}

func (g GetShoppingList_Response_Aisles_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if g.Items != nil {
		if v, ok := any(g.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles []GenerateShoppingList_Response_Aisles_Item

func (g GenerateShoppingList_Response_Aisles) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles_Items []GenerateShoppingList_Response_Aisles_Items_Item

func (g GenerateShoppingList_Response_Aisles_Items) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles_Items_Measures struct {
	Original GenerateShoppingList_Response_Aisles_Items_Measures_Original `json:"original"`
	Metric   GenerateShoppingList_Response_Aisles_Items_Measures_Metric   `json:"metric"`
	Us       GenerateShoppingList_Response_Aisles_Items_Measures_Us       `json:"us"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Original).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Original", err)
		}
	}
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles_Items_Measures_Original struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Measures_Original) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingList_Response_Aisles_Items_Measures_Metric struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingList_Response_Aisles_Items_Measures_Us struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingList_Response_Aisles_Items_Item struct {
	ID           int64                                                `json:"id" validate:"required"`
	Name         string                                               `json:"name" validate:"required,min=1"`
	Measures     *GenerateShoppingList_Response_Aisles_Items_Measures `json:"measures,omitempty"`
	PantryItem   bool                                                 `json:"pantryItem"`
	Aisle        string                                               `json:"aisle" validate:"required,min=1"`
	Cost         float32                                              `json:"cost" validate:"required"`
	IngredientID int64                                                `json:"ingredientId" validate:"required"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(g.IngredientID, "required"); err != nil {
		errors = errors.Append("IngredientID", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles_Item struct {
	Aisle string                                      `json:"aisle" validate:"required,min=1"`
	Items *GenerateShoppingList_Response_Aisles_Items `json:"items,omitempty"`
}

func (g GenerateShoppingList_Response_Aisles_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if g.Items != nil {
		if v, ok := any(g.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles []AddToShoppingList_Response_Aisles_Item

func (a AddToShoppingList_Response_Aisles) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles_Items []AddToShoppingList_Response_Aisles_Items_Item

func (a AddToShoppingList_Response_Aisles_Items) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles_Items_Measures struct {
	Original AddToShoppingList_Response_Aisles_Items_Measures_Original `json:"original"`
	Metric   AddToShoppingList_Response_Aisles_Items_Measures_Metric   `json:"metric"`
	Us       AddToShoppingList_Response_Aisles_Items_Measures_Us       `json:"us"`
}

func (a AddToShoppingList_Response_Aisles_Items_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Original).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Original", err)
		}
	}
	if v, ok := any(a.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(a.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles_Items_Measures_Original struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (a AddToShoppingList_Response_Aisles_Items_Measures_Original) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AddToShoppingList_Response_Aisles_Items_Measures_Metric struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (a AddToShoppingList_Response_Aisles_Items_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AddToShoppingList_Response_Aisles_Items_Measures_Us struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (a AddToShoppingList_Response_Aisles_Items_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AddToShoppingList_Response_Aisles_Items_Item struct {
	ID           int64                                             `json:"id" validate:"required"`
	Name         string                                            `json:"name" validate:"required,min=1"`
	Measures     *AddToShoppingList_Response_Aisles_Items_Measures `json:"measures,omitempty"`
	PantryItem   bool                                              `json:"pantryItem"`
	Aisle        string                                            `json:"aisle" validate:"required,min=1"`
	Cost         float32                                           `json:"cost" validate:"required"`
	IngredientID int64                                             `json:"ingredientId" validate:"required"`
}

func (a AddToShoppingList_Response_Aisles_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(a.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if a.Measures != nil {
		if v, ok := any(a.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(a.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(a.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(a.IngredientID, "required"); err != nil {
		errors = errors.Append("IngredientID", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles_Item struct {
	Aisle string                                   `json:"aisle" validate:"required,min=1"`
	Items *AddToShoppingList_Response_Aisles_Items `json:"items,omitempty"`
}

func (a AddToShoppingList_Response_Aisles_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if a.Items != nil {
		if v, ok := any(a.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRestaurants_Response_Restaurants []SearchRestaurants_Response_Restaurants_Item

func (s SearchRestaurants_Response_Restaurants) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRestaurants_Response_Restaurants_Address struct {
	StreetAddr  *string  `json:"street_addr,omitempty"`
	City        *string  `json:"city,omitempty"`
	State       *string  `json:"state,omitempty"`
	Zipcode     *string  `json:"zipcode,omitempty"`
	Country     *string  `json:"country,omitempty"`
	Lat         *float32 `json:"lat,omitempty"`
	Lon         *float32 `json:"lon,omitempty"`
	StreetAddr2 *string  `json:"street_addr_2,omitempty"`
	Latitude    *float32 `json:"latitude,omitempty"`
	Longitude   *float32 `json:"longitude,omitempty"`
}

type SearchRestaurants_Response_Restaurants_LocalHours struct {
	Operational *SearchRestaurants_Response_Restaurants_LocalHours_Operational `json:"operational,omitempty"`
	Delivery    *SearchRestaurants_Response_Restaurants_LocalHours_Delivery    `json:"delivery,omitempty"`
	Pickup      *SearchRestaurants_Response_Restaurants_LocalHours_Pickup      `json:"pickup,omitempty"`
	DineIn      *SearchRestaurants_Response_Restaurants_LocalHours_DineIn      `json:"dine_in,omitempty"`
}

func (s SearchRestaurants_Response_Restaurants_LocalHours) Validate() error {
	var errors runtime.ValidationErrors
	if s.Operational != nil {
		if v, ok := any(s.Operational).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Operational", err)
			}
		}
	}
	if s.Delivery != nil {
		if v, ok := any(s.Delivery).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Delivery", err)
			}
		}
	}
	if s.Pickup != nil {
		if v, ok := any(s.Pickup).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Pickup", err)
			}
		}
	}
	if s.DineIn != nil {
		if v, ok := any(s.DineIn).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DineIn", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRestaurants_Response_Restaurants_LocalHours_Operational struct {
	Monday    *string `json:"Monday,omitempty"`
	Tuesday   *string `json:"Tuesday,omitempty"`
	Wednesday *string `json:"Wednesday,omitempty"`
	Thursday  *string `json:"Thursday,omitempty"`
	Friday    *string `json:"Friday,omitempty"`
	Saturday  *string `json:"Saturday,omitempty"`
	Sunday    *string `json:"Sunday,omitempty"`
}

type SearchRestaurants_Response_Restaurants_LocalHours_Delivery struct {
	Monday    *string `json:"Monday,omitempty"`
	Tuesday   *string `json:"Tuesday,omitempty"`
	Wednesday *string `json:"Wednesday,omitempty"`
	Thursday  *string `json:"Thursday,omitempty"`
	Friday    *string `json:"Friday,omitempty"`
	Saturday  *string `json:"Saturday,omitempty"`
	Sunday    *string `json:"Sunday,omitempty"`
}

type SearchRestaurants_Response_Restaurants_LocalHours_Pickup struct {
	Monday    *string `json:"Monday,omitempty"`
	Tuesday   *string `json:"Tuesday,omitempty"`
	Wednesday *string `json:"Wednesday,omitempty"`
	Thursday  *string `json:"Thursday,omitempty"`
	Friday    *string `json:"Friday,omitempty"`
	Saturday  *string `json:"Saturday,omitempty"`
	Sunday    *string `json:"Sunday,omitempty"`
}

type SearchRestaurants_Response_Restaurants_LocalHours_DineIn struct {
	Monday    *string `json:"Monday,omitempty"`
	Tuesday   *string `json:"Tuesday,omitempty"`
	Wednesday *string `json:"Wednesday,omitempty"`
	Thursday  *string `json:"Thursday,omitempty"`
	Friday    *string `json:"Friday,omitempty"`
	Saturday  *string `json:"Saturday,omitempty"`
	Sunday    *string `json:"Sunday,omitempty"`
}

type SearchRestaurants_Response_Restaurants_Item struct {
	UnderscoreID             *string                                            `json:"_id,omitempty"`
	Name                     *string                                            `json:"name,omitempty"`
	PhoneNumber              *int64                                             `json:"phone_number,omitempty"`
	Address                  *SearchRestaurants_Response_Restaurants_Address    `json:"address,omitempty"`
	Type                     *string                                            `json:"type,omitempty"`
	Description              *string                                            `json:"description,omitempty"`
	LocalHours               *SearchRestaurants_Response_Restaurants_LocalHours `json:"local_hours,omitempty"`
	Cuisines                 []string                                           `json:"cuisines,omitempty"`
	FoodPhotos               []string                                           `json:"food_photos,omitempty"`
	LogoPhotos               []string                                           `json:"logo_photos,omitempty"`
	StorePhotos              []map[string]any                                   `json:"store_photos,omitempty"`
	DollarSigns              *int64                                             `json:"dollar_signs,omitempty"`
	PickupEnabled            *bool                                              `json:"pickup_enabled,omitempty"`
	DeliveryEnabled          *bool                                              `json:"delivery_enabled,omitempty"`
	IsOpen                   *bool                                              `json:"is_open,omitempty"`
	OffersFirstPartyDelivery *bool                                              `json:"offers_first_party_delivery,omitempty"`
	OffersThirdPartyDelivery *bool                                              `json:"offers_third_party_delivery,omitempty"`
	Miles                    *float32                                           `json:"miles,omitempty"`
	WeightedRatingValue      *float32                                           `json:"weighted_rating_value,omitempty"`
	AggregatedRatingCount    *int64                                             `json:"aggregated_rating_count,omitempty"`
}

func (s SearchRestaurants_Response_Restaurants_Item) Validate() error {
	var errors runtime.ValidationErrors
	if s.Address != nil {
		if v, ok := any(s.Address).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Address", err)
			}
		}
	}
	if s.LocalHours != nil {
		if v, ok := any(s.LocalHours).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LocalHours", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetWinePairing_Response_ProductMatches []GetWinePairing_Response_ProductMatches_Item

func (g GetWinePairing_Response_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetWinePairing_Response_ProductMatches_Item struct {
	ID            int64     `json:"id" validate:"required"`
	Title         string    `json:"title" validate:"required,min=1"`
	AverageRating float32   `json:"averageRating" validate:"required"`
	Description   *struct{} `json:"description,omitempty"`
	ImageURL      string    `json:"imageUrl" validate:"required,min=1"`
	Link          string    `json:"link" validate:"required,min=1"`
	Price         string    `json:"price" validate:"required,min=1"`
	RatingCount   int64     `json:"ratingCount" validate:"required"`
	Score         float32   `json:"score" validate:"required"`
}

func (g GetWinePairing_Response_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWineRecommendation_Response_RecommendedWines []GetWineRecommendation_Response_RecommendedWines_Item

func (g GetWineRecommendation_Response_RecommendedWines) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetWineRecommendation_Response_RecommendedWines_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	Description   string  `json:"description" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	Link          string  `json:"link" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
}

func (g GetWineRecommendation_Response_RecommendedWines_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ImageAnalysisByURL_Response_Nutrition struct {
	RecipesUsed int64                                          `json:"recipesUsed" validate:"required"`
	Calories    ImageAnalysisByURL_Response_Nutrition_Calories `json:"calories"`
	Fat         ImageAnalysisByURL_Response_Nutrition_Fat      `json:"fat"`
	Protein     ImageAnalysisByURL_Response_Nutrition_Protein  `json:"protein"`
	Carbs       ImageAnalysisByURL_Response_Nutrition_Carbs    `json:"carbs"`
}

func (i ImageAnalysisByURL_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.RecipesUsed, "required"); err != nil {
		errors = errors.Append("RecipesUsed", err)
	}
	if v, ok := any(i.Calories).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Calories", err)
		}
	}
	if v, ok := any(i.Fat).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Fat", err)
		}
	}
	if v, ok := any(i.Protein).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Protein", err)
		}
	}
	if v, ok := any(i.Carbs).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Carbs", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Calories struct {
	Value                    float32                                                                 `json:"value" validate:"required"`
	Unit                     string                                                                  `json:"unit" validate:"required,min=1"`
	ConfidenceRange95Percent ImageAnalysisByURL_Response_Nutrition_Calories_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                                 `json:"standardDeviation" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Calories) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(i.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if v, ok := any(i.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(i.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Calories_ConfidenceRange95Percent struct {
	Min float32 `json:"min" validate:"required"`
	Max float32 `json:"max" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Calories_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Nutrition_Fat struct {
	Value                    float32                                                            `json:"value" validate:"required"`
	Unit                     string                                                             `json:"unit" validate:"required,min=1"`
	ConfidenceRange95Percent ImageAnalysisByURL_Response_Nutrition_Fat_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                            `json:"standardDeviation" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Fat) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(i.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if v, ok := any(i.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(i.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Fat_ConfidenceRange95Percent struct {
	Min float32 `json:"min" validate:"required"`
	Max float32 `json:"max" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Fat_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Nutrition_Protein struct {
	Value                    float32                                                                `json:"value" validate:"required"`
	Unit                     string                                                                 `json:"unit" validate:"required,min=1"`
	ConfidenceRange95Percent ImageAnalysisByURL_Response_Nutrition_Protein_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                                `json:"standardDeviation" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Protein) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(i.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if v, ok := any(i.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(i.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Protein_ConfidenceRange95Percent struct {
	Min float32 `json:"min" validate:"required"`
	Max float32 `json:"max" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Protein_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Nutrition_Carbs struct {
	Value                    float32                                                              `json:"value" validate:"required"`
	Unit                     string                                                               `json:"unit" validate:"required,min=1"`
	ConfidenceRange95Percent ImageAnalysisByURL_Response_Nutrition_Carbs_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                              `json:"standardDeviation" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Carbs) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(i.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if v, ok := any(i.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(i.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Carbs_ConfidenceRange95Percent struct {
	Min float32 `json:"min" validate:"required"`
	Max float32 `json:"max" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Carbs_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Category struct {
	Name        string  `json:"name" validate:"required,min=1"`
	Probability float32 `json:"probability" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Category) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Recipes []ImageAnalysisByURL_Response_Recipes_Item

func (i ImageAnalysisByURL_Response_Recipes) Validate() error {
	var errors runtime.ValidationErrors
	if len(i) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(i)))
	}
	for i, item := range i {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Recipes_Item struct {
	ID        int64  `json:"id" validate:"required"`
	Title     string `json:"title" validate:"required,min=1"`
	ImageType string `json:"imageType" validate:"required,min=1"`
	URL       string `json:"url" validate:"required,min=1"`
}

func (i ImageAnalysisByURL_Response_Recipes_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type DetectFoodInText_Response_Annotations []DetectFoodInText_Response_Annotations_Item

func (d DetectFoodInText_Response_Annotations) Validate() error {
	var errors runtime.ValidationErrors
	if len(d) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(d)))
	}
	for i, item := range d {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DetectFoodInText_Response_Annotations_Item struct {
	Annotation string `json:"annotation" validate:"required,min=1"`
	Image      string `json:"image" validate:"required,min=1"`
	Tag        string `json:"tag" validate:"required,min=1"`
}

func (d DetectFoodInText_Response_Annotations_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type SearchSiteContent_Response_Articles []SearchSiteContent_Response_Articles_Item

func (s SearchSiteContent_Response_Articles) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_Articles_Item struct {
	DataPoints []struct{} `json:"dataPoints,omitempty"`
	Image      string     `json:"image" validate:"required,min=1"`
	Link       string     `json:"link" validate:"required,min=1"`
	Name       string     `json:"name" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_Articles_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchSiteContent_Response_GroceryProducts []SearchSiteContent_Response_GroceryProducts_Item

func (s SearchSiteContent_Response_GroceryProducts) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_GroceryProducts_DataPoints []SearchSiteContent_Response_GroceryProducts_DataPoints_Item

func (s SearchSiteContent_Response_GroceryProducts_DataPoints) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_GroceryProducts_DataPoints_Item struct {
	Key   string `json:"key" validate:"required,min=1"`
	Value string `json:"value" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_GroceryProducts_DataPoints_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchSiteContent_Response_GroceryProducts_Item struct {
	DataPoints *SearchSiteContent_Response_GroceryProducts_DataPoints `json:"dataPoints,omitempty"`
	Image      string                                                 `json:"image" validate:"required,min=1"`
	Link       string                                                 `json:"link" validate:"required,min=1"`
	Name       string                                                 `json:"name" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_GroceryProducts_Item) Validate() error {
	var errors runtime.ValidationErrors
	if s.DataPoints != nil {
		if v, ok := any(s.DataPoints).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataPoints", err)
			}
		}
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.Link, "required,min=1"); err != nil {
		errors = errors.Append("Link", err)
	}
	if err := typesValidator.Var(s.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_MenuItems []SearchSiteContent_Response_MenuItems_Item

func (s SearchSiteContent_Response_MenuItems) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_MenuItems_DataPoints []SearchSiteContent_Response_MenuItems_DataPoints_Item

func (s SearchSiteContent_Response_MenuItems_DataPoints) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_MenuItems_DataPoints_Item struct {
	Key   string `json:"key" validate:"required,min=1"`
	Value string `json:"value" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_MenuItems_DataPoints_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchSiteContent_Response_MenuItems_Item struct {
	DataPoints *SearchSiteContent_Response_MenuItems_DataPoints `json:"dataPoints,omitempty"`
	Image      string                                           `json:"image" validate:"required,min=1"`
	Link       string                                           `json:"link" validate:"required,min=1"`
	Name       string                                           `json:"name" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_MenuItems_Item) Validate() error {
	var errors runtime.ValidationErrors
	if s.DataPoints != nil {
		if v, ok := any(s.DataPoints).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataPoints", err)
			}
		}
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.Link, "required,min=1"); err != nil {
		errors = errors.Append("Link", err)
	}
	if err := typesValidator.Var(s.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_Recipes []SearchSiteContent_Response_Recipes_Item

func (s SearchSiteContent_Response_Recipes) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_Recipes_DataPoints []SearchSiteContent_Response_Recipes_DataPoints_Item

func (s SearchSiteContent_Response_Recipes_DataPoints) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_Recipes_DataPoints_Item struct {
	Key   string `json:"key" validate:"required,min=1"`
	Value string `json:"value" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_Recipes_DataPoints_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchSiteContent_Response_Recipes_Item struct {
	DataPoints *SearchSiteContent_Response_Recipes_DataPoints `json:"dataPoints,omitempty"`
	Image      string                                         `json:"image" validate:"required,min=1"`
	Link       string                                         `json:"link" validate:"required,min=1"`
	Name       string                                         `json:"name" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_Recipes_Item) Validate() error {
	var errors runtime.ValidationErrors
	if s.DataPoints != nil {
		if v, ok := any(s.DataPoints).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataPoints", err)
			}
		}
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.Link, "required,min=1"); err != nil {
		errors = errors.Append("Link", err)
	}
	if err := typesValidator.Var(s.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchAllFood_Response_SearchResults []SearchAllFood_Response_SearchResults_Item

func (s SearchAllFood_Response_SearchResults) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchAllFood_Response_SearchResults_Results []SearchAllFood_Response_SearchResults_Results_Item

func (s SearchAllFood_Response_SearchResults_Results) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchAllFood_Response_SearchResults_Results_Item struct {
	ID        string  `json:"id" validate:"required"`
	Name      string  `json:"name" validate:"required,min=1"`
	Image     *string `json:"image,omitempty" validate:"required,min=1"`
	Link      *string `json:"link,omitempty" validate:"required,min=1"`
	Type      string  `json:"type" validate:"required,min=1"`
	Relevance float32 `json:"relevance" validate:"required"`
	Content   *string `json:"content,omitempty" validate:"required,min=0"`
}

func (s SearchAllFood_Response_SearchResults_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchAllFood_Response_SearchResults_Item struct {
	Name         string                                        `json:"name" validate:"required,min=1"`
	TotalResults int64                                         `json:"totalResults" validate:"required"`
	Results      *SearchAllFood_Response_SearchResults_Results `json:"results,omitempty"`
}

func (s SearchAllFood_Response_SearchResults_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(s.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if s.Results != nil {
		if v, ok := any(s.Results).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Results", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchFoodVideos_Response_Videos []SearchFoodVideos_Response_Videos_Item

func (s SearchFoodVideos_Response_Videos) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchFoodVideos_Response_Videos_Item struct {
	Title      string  `json:"title" validate:"required,min=1"`
	Length     int64   `json:"length" validate:"required"`
	Rating     float32 `json:"rating" validate:"required"`
	ShortTitle string  `json:"shortTitle" validate:"required,min=1"`
	Thumbnail  string  `json:"thumbnail" validate:"required,min=1"`
	Views      int64   `json:"views" validate:"required"`
	YouTubeID  string  `json:"youTubeId" validate:"required,min=1"`
}

func (s SearchFoodVideos_Response_Videos_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetConversationSuggests_Response_Suggests struct {
	Underscore GetConversationSuggests_Response_Suggests_Underscore `json:"_" validate:"required"`
}

func (g GetConversationSuggests_Response_Suggests) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Underscore).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Underscore", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConversationSuggests_Response_Suggests_Underscore []GetConversationSuggests_Response_Suggests_Underscore_Item

func (g GetConversationSuggests_Response_Suggests_Underscore) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConversationSuggests_Response_Suggests_Underscore_Item struct {
	Name string `json:"name" validate:"required,min=1"`
}

func (g GetConversationSuggests_Response_Suggests_Underscore_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}
