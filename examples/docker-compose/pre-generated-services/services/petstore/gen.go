// Code generated by oapi-codegen. DO NOT EDIT.

package petstore

import (
	"context"
	"embed"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"path"
	"strings"
	"time"

	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/config"
	"github.com/cubahno/connexions/v2/pkg/db"
	"github.com/cubahno/connexions/v2/pkg/generator"
	"github.com/cubahno/connexions/v2/pkg/loader"
	"github.com/cubahno/connexions/v2/pkg/typedef"
	oapicodegen "github.com/doordash-oss/oapi-codegen-dd/v3/pkg/codegen"
	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
	yamlv4 "go.yaml.in/yaml/v4"
)

type OrderStatus string

const (
	OrderStatusApproved  OrderStatus = "approved"
	OrderStatusDelivered OrderStatus = "delivered"
	OrderStatusPlaced    OrderStatus = "placed"
)

// Validate checks if the OrderStatus value is valid
func (o OrderStatus) Validate() error {
	switch o {
	case OrderStatusApproved, OrderStatusDelivered, OrderStatusPlaced:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid OrderStatus value, got: %v", o))
	}
}

type PetStatus string

const (
	PetStatusAvailable PetStatus = "available"
	PetStatusPending   PetStatus = "pending"
	PetStatusSold      PetStatus = "sold"
)

// Validate checks if the PetStatus value is valid
func (p PetStatus) Validate() error {
	switch p {
	case PetStatusAvailable, PetStatusPending, PetStatusSold:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid PetStatus value, got: %v", p))
	}
}

type FindPetsByStatusQueryStatus string

const (
	FindPetsByStatusQueryStatusAvailable FindPetsByStatusQueryStatus = "available"
	FindPetsByStatusQueryStatusPending   FindPetsByStatusQueryStatus = "pending"
	FindPetsByStatusQueryStatusSold      FindPetsByStatusQueryStatus = "sold"
)

// Validate checks if the FindPetsByStatusQueryStatus value is valid
func (f FindPetsByStatusQueryStatus) Validate() error {
	switch f {
	case FindPetsByStatusQueryStatusAvailable, FindPetsByStatusQueryStatusPending, FindPetsByStatusQueryStatusSold:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid FindPetsByStatusQueryStatus value, got: %v", f))
	}
}

// OapiErrorKind represents the type of error that occurred during request processing.
type OapiErrorKind int

const (
	// OapiErrorKindParse indicates a parameter parsing error (invalid path/query/header parameter).
	OapiErrorKindParse OapiErrorKind = iota

	// OapiErrorKindDecode indicates a request body decoding error (invalid JSON, form data, etc.).
	OapiErrorKindDecode

	// OapiErrorKindValidation indicates a request validation error (failed schema validation).
	OapiErrorKindValidation

	// OapiErrorKindService indicates a service/business logic error returned by the service implementation.
	OapiErrorKindService
)

// OapiHandlerError represents an error that occurred during request handling (parse, decode, validation).
// When no typed error response is configured in the OpenAPI spec, this error type is used.
// Custom error handlers can type-assert to this type to access error details.
type OapiHandlerError struct {
	Kind          OapiErrorKind
	OperationID   string
	Message       string
	ParamName     string
	ParamLocation string
}

func (e OapiHandlerError) Error() string {
	return e.Message
}

// OapiErrorResponse is the default JSON error response structure used by OapiDefaultErrorHandler.
type OapiErrorResponse struct {
	Error         string `json:"error"`
	OperationID   string `json:"operation_id,omitempty"`
	ParamName     string `json:"param_name,omitempty"`
	ParamLocation string `json:"param_location,omitempty"`
}

// OapiErrorHandler handles errors that occur during request processing.
// Implement this interface to customize error responses, logging, and metrics.
type OapiErrorHandler interface {
	// HandleError writes an error response to w with the given status code.
	// The err is either an OapiHandlerError (for parse/decode/validation errors)
	// or a typed error matching the OpenAPI spec's error response schema.
	HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error)
}

// OapiDefaultErrorHandler provides the default error handling behavior.
// It writes JSON error responses. For OapiHandlerError, it uses OapiErrorResponse.
// For typed errors (from OpenAPI spec), it encodes them directly.
type OapiDefaultErrorHandler struct{}

// HandleError implements OapiErrorHandler with default JSON error responses.
func (h *OapiDefaultErrorHandler) HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)

	if handlerErr, ok := err.(OapiHandlerError); ok {
		_ = json.NewEncoder(w).Encode(OapiErrorResponse{
			Error:         handlerErr.Message,
			OperationID:   handlerErr.OperationID,
			ParamName:     handlerErr.ParamName,
			ParamLocation: handlerErr.ParamLocation,
		})
		return
	}

	// Typed error from OpenAPI spec - encode directly
	_ = json.NewEncoder(w).Encode(err)
}

// ServiceInterface defines the service interface for business logic.
type ServiceInterface interface {
	// UpdatePet Update an existing pet.
	UpdatePet(ctx context.Context, opts *UpdatePetServiceRequestOptions) (*UpdatePetResponseData, error)
	// AddPet Add a new pet to the store.
	AddPet(ctx context.Context, opts *AddPetServiceRequestOptions) (*AddPetResponseData, error)
	// FindPetsByStatus Finds Pets by status.
	FindPetsByStatus(ctx context.Context, opts *FindPetsByStatusServiceRequestOptions) (*FindPetsByStatusResponseData, error)
	// FindPetsByTags Finds Pets by tags.
	FindPetsByTags(ctx context.Context, opts *FindPetsByTagsServiceRequestOptions) (*FindPetsByTagsResponseData, error)
	// GetPetByID Find pet by ID.
	GetPetByID(ctx context.Context, opts *GetPetByIDServiceRequestOptions) (*GetPetByIDResponseData, error)
	// UpdatePetWithForm Updates a pet in the store with form data.
	UpdatePetWithForm(ctx context.Context, opts *UpdatePetWithFormServiceRequestOptions) (*UpdatePetWithFormResponseData, error)
	// DeletePet Deletes a pet.
	DeletePet(ctx context.Context, opts *DeletePetServiceRequestOptions) (*DeletePetResponseData, error)
	// UploadFile Uploads an image.
	UploadFile(ctx context.Context, opts *UploadFileServiceRequestOptions) (*UploadFileResponseData, error)
	// GetInventory Returns pet inventories by status.
	GetInventory(ctx context.Context) (*GetInventoryResponseData, error)
	// PlaceOrder Place an order for a pet.
	PlaceOrder(ctx context.Context, opts *PlaceOrderServiceRequestOptions) (*PlaceOrderResponseData, error)
	// GetOrderByID Find purchase order by ID.
	GetOrderByID(ctx context.Context, opts *GetOrderByIDServiceRequestOptions) (*GetOrderByIDResponseData, error)
	// DeleteOrder Delete purchase order by identifier.
	DeleteOrder(ctx context.Context, opts *DeleteOrderServiceRequestOptions) (*DeleteOrderResponseData, error)
	// CreateUser Create user.
	CreateUser(ctx context.Context, opts *CreateUserServiceRequestOptions) (*CreateUserResponseData, error)
	// CreateUsersWithListInput Creates list of users with given input array.
	CreateUsersWithListInput(ctx context.Context, opts *CreateUsersWithListInputServiceRequestOptions) (*CreateUsersWithListInputResponseData, error)
	// LoginUser Logs user into the system.
	LoginUser(ctx context.Context, opts *LoginUserServiceRequestOptions) (*LoginUserResponseData, error)
	// LogoutUser Logs out current logged in user session.
	LogoutUser(ctx context.Context) (*LogoutUserResponseData, error)
	// GetUserByName Get user by user name.
	GetUserByName(ctx context.Context, opts *GetUserByNameServiceRequestOptions) (*GetUserByNameResponseData, error)
	// UpdateUser Update user resource.
	UpdateUser(ctx context.Context, opts *UpdateUserServiceRequestOptions) (*UpdateUserResponseData, error)
	// DeleteUser Delete user resource.
	DeleteUser(ctx context.Context, opts *DeleteUserServiceRequestOptions) (*DeleteUserResponseData, error)
}

// HTTPAdapter adapts the ServiceInterface to HTTP handlers.
// This struct is generated and should not be modified.
type HTTPAdapter struct {
	svc        ServiceInterface
	errHandler OapiErrorHandler
}

// NewHTTPAdapter creates a new HTTPAdapter wrapping the given service.
// If errHandler is nil, OapiDefaultErrorHandler is used.
func NewHTTPAdapter(svc ServiceInterface, errHandler OapiErrorHandler) *HTTPAdapter {
	if errHandler == nil {
		errHandler = &OapiDefaultErrorHandler{}
	}
	return &HTTPAdapter{svc: svc, errHandler: errHandler}
}

// UpdatePet handles PUT /pet
func (a *HTTPAdapter) UpdatePet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &UpdatePetServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()
	var body UpdatePetBody
	if err := runtime.DecodeJSONBody(r.Body, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "UpdatePet",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.UpdatePet(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AddPet handles POST /pet
func (a *HTTPAdapter) AddPet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AddPetServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()
	var body AddPetBody
	if err := runtime.DecodeJSONBody(r.Body, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "AddPet",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.AddPet(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// FindPetsByStatus handles GET /pet/findByStatus
func (a *HTTPAdapter) FindPetsByStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &FindPetsByStatusServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &FindPetsByStatusQuery{}
	query := r.URL.Query()
	if queryParamStatusStr := query.Get("status"); queryParamStatusStr != "" {

		queryParamStatus := FindPetsByStatusQueryStatus(queryParamStatusStr)
		queryParams.Status = queryParamStatus
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.FindPetsByStatus(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// FindPetsByTags handles GET /pet/findByTags
func (a *HTTPAdapter) FindPetsByTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &FindPetsByTagsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &FindPetsByTagsQuery{}
	query := r.URL.Query()

	if values, ok := query["tags"]; ok {
		queryParams.Tags = values
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.FindPetsByTags(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetPetByID handles GET /pet/{petId}
func (a *HTTPAdapter) GetPetByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetPetByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetPetByIDPath{}
	pathParamPetIDStr := chi.URLParam(r, "petId")

	pathParamPetID, err := runtime.ParseString[int64](pathParamPetIDStr, "int64")
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetPetByID",
			Message:       err.Error(),
			ParamName:     "petId",
			ParamLocation: "path",
		})
		return
	}
	pathParams.PetID = pathParamPetID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetPetByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// UpdatePetWithForm handles POST /pet/{petId}
func (a *HTTPAdapter) UpdatePetWithForm(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &UpdatePetWithFormServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &UpdatePetWithFormPath{}
	pathParamPetIDStr := chi.URLParam(r, "petId")

	pathParamPetID, err := runtime.ParseString[int64](pathParamPetIDStr, "int64")
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "UpdatePetWithForm",
			Message:       err.Error(),
			ParamName:     "petId",
			ParamLocation: "path",
		})
		return
	}
	pathParams.PetID = pathParamPetID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &UpdatePetWithFormQuery{}
	query := r.URL.Query()
	if queryParamNameStr := query.Get("name"); queryParamNameStr != "" {
		queryParamName := queryParamNameStr
		queryParams.Name = &queryParamName
	}
	if queryParamStatusStr := query.Get("status"); queryParamStatusStr != "" {
		queryParamStatus := queryParamStatusStr
		queryParams.Status = &queryParamStatus
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.UpdatePetWithForm(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// DeletePet handles DELETE /pet/{petId}
func (a *HTTPAdapter) DeletePet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DeletePetServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &DeletePetPath{}
	pathParamPetIDStr := chi.URLParam(r, "petId")

	pathParamPetID, err := runtime.ParseString[int64](pathParamPetIDStr, "int64")
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "DeletePet",
			Message:       err.Error(),
			ParamName:     "petId",
			ParamLocation: "path",
		})
		return
	}
	pathParams.PetID = pathParamPetID
	opts.PathParams = pathParams

	// Parse header parameters
	headerParams := &DeletePetHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("api_key")]; len(headerValues) > 0 {
		headerParamAPIKey := headerValues[0]
		headerParams.APIKey = &headerParamAPIKey
	}
	opts.Header = headerParams

	// Call business logic
	resp, err := a.svc.DeletePet(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.WriteHeader(status)
}

// UploadFile handles POST /pet/{petId}/uploadImage
func (a *HTTPAdapter) UploadFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &UploadFileServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &UploadFilePath{}
	pathParamPetIDStr := chi.URLParam(r, "petId")

	pathParamPetID, err := runtime.ParseString[int64](pathParamPetIDStr, "int64")
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "UploadFile",
			Message:       err.Error(),
			ParamName:     "petId",
			ParamLocation: "path",
		})
		return
	}
	pathParams.PetID = pathParamPetID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &UploadFileQuery{}
	query := r.URL.Query()
	if queryParamAdditionalMetadataStr := query.Get("additionalMetadata"); queryParamAdditionalMetadataStr != "" {
		queryParamAdditionalMetadata := queryParamAdditionalMetadataStr
		queryParams.AdditionalMetadata = &queryParamAdditionalMetadata
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.UploadFile(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetInventory handles GET /store/inventory
func (a *HTTPAdapter) GetInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.GetInventory(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// PlaceOrder handles POST /store/order
func (a *HTTPAdapter) PlaceOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &PlaceOrderServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()
	var body PlaceOrderBody
	if err := runtime.DecodeJSONBody(r.Body, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "PlaceOrder",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.PlaceOrder(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetOrderByID handles GET /store/order/{orderId}
func (a *HTTPAdapter) GetOrderByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetOrderByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetOrderByIDPath{}
	pathParamOrderIDStr := chi.URLParam(r, "orderId")

	pathParamOrderID, err := runtime.ParseString[int64](pathParamOrderIDStr, "int64")
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetOrderByID",
			Message:       err.Error(),
			ParamName:     "orderId",
			ParamLocation: "path",
		})
		return
	}
	pathParams.OrderID = pathParamOrderID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetOrderByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// DeleteOrder handles DELETE /store/order/{orderId}
func (a *HTTPAdapter) DeleteOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DeleteOrderServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &DeleteOrderPath{}
	pathParamOrderIDStr := chi.URLParam(r, "orderId")

	pathParamOrderID, err := runtime.ParseString[int64](pathParamOrderIDStr, "int64")
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "DeleteOrder",
			Message:       err.Error(),
			ParamName:     "orderId",
			ParamLocation: "path",
		})
		return
	}
	pathParams.OrderID = pathParamOrderID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.DeleteOrder(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.WriteHeader(status)
}

// CreateUser handles POST /user
func (a *HTTPAdapter) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &CreateUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()
	var body CreateUserBody
	if err := runtime.DecodeJSONBody(r.Body, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "CreateUser",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.CreateUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// CreateUsersWithListInput handles POST /user/createWithList
func (a *HTTPAdapter) CreateUsersWithListInput(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &CreateUsersWithListInputServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()
	var body CreateUsersWithListInputBody
	if err := runtime.DecodeJSONBody(r.Body, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "CreateUsersWithListInput",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.CreateUsersWithListInput(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// LoginUser handles GET /user/login
func (a *HTTPAdapter) LoginUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &LoginUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &LoginUserQuery{}
	query := r.URL.Query()
	if queryParamUsernameStr := query.Get("username"); queryParamUsernameStr != "" {
		queryParamUsername := queryParamUsernameStr
		queryParams.Username = &queryParamUsername
	}
	if queryParamPasswordStr := query.Get("password"); queryParamPasswordStr != "" {
		queryParamPassword := queryParamPasswordStr
		queryParams.Password = &queryParamPassword
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.LoginUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// LogoutUser handles GET /user/logout
func (a *HTTPAdapter) LogoutUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.LogoutUser(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.WriteHeader(status)
}

// GetUserByName handles GET /user/{username}
func (a *HTTPAdapter) GetUserByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserByNameServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserByNamePath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUserByName(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// UpdateUser handles PUT /user/{username}
func (a *HTTPAdapter) UpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &UpdateUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &UpdateUserPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	opts.PathParams = pathParams
	// Parse request body
	defer r.Body.Close()
	var body UpdateUserBody
	if err := runtime.DecodeJSONBody(r.Body, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "UpdateUser",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.UpdateUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.WriteHeader(status)
}

// DeleteUser handles DELETE /user/{username}
func (a *HTTPAdapter) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DeleteUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &DeleteUserPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.DeleteUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.WriteHeader(status)
}

// RouterOption is a function that configures the router.
type RouterOption func(*routerConfig)

type routerConfig struct {
	middlewares []func(http.Handler) http.Handler
	errHandler  OapiErrorHandler
}

// WithMiddleware adds middleware to the router.
func WithMiddleware(mw func(http.Handler) http.Handler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.middlewares = append(cfg.middlewares, mw)
	}
}

// WithErrorHandler sets a custom error handler for the router.
// If not set, OapiOapiDefaultErrorHandler is used.
func WithErrorHandler(h OapiErrorHandler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.errHandler = h
	}
}

// NewRouter creates a new chi.Router with the given service implementation.
func NewRouter(svc ServiceInterface, opts ...RouterOption) chi.Router {
	cfg := &routerConfig{}
	for _, opt := range opts {
		opt(cfg)
	}

	r := chi.NewRouter()
	for _, mw := range cfg.middlewares {
		r.Use(mw)
	}
	adapter := NewHTTPAdapter(svc, cfg.errHandler)
	r.Method("PUT", "/pet", http.HandlerFunc(adapter.UpdatePet))
	r.Method("POST", "/pet", http.HandlerFunc(adapter.AddPet))
	r.Method("GET", "/pet/findByStatus", http.HandlerFunc(adapter.FindPetsByStatus))
	r.Method("GET", "/pet/findByTags", http.HandlerFunc(adapter.FindPetsByTags))
	r.Method("GET", "/pet/{petId}", http.HandlerFunc(adapter.GetPetByID))
	r.Method("POST", "/pet/{petId}", http.HandlerFunc(adapter.UpdatePetWithForm))
	r.Method("DELETE", "/pet/{petId}", http.HandlerFunc(adapter.DeletePet))
	r.Method("POST", "/pet/{petId}/uploadImage", http.HandlerFunc(adapter.UploadFile))
	r.Method("GET", "/store/inventory", http.HandlerFunc(adapter.GetInventory))
	r.Method("POST", "/store/order", http.HandlerFunc(adapter.PlaceOrder))
	r.Method("GET", "/store/order/{orderId}", http.HandlerFunc(adapter.GetOrderByID))
	r.Method("DELETE", "/store/order/{orderId}", http.HandlerFunc(adapter.DeleteOrder))
	r.Method("POST", "/user", http.HandlerFunc(adapter.CreateUser))
	r.Method("POST", "/user/createWithList", http.HandlerFunc(adapter.CreateUsersWithListInput))
	r.Method("GET", "/user/login", http.HandlerFunc(adapter.LoginUser))
	r.Method("GET", "/user/logout", http.HandlerFunc(adapter.LogoutUser))
	r.Method("GET", "/user/{username}", http.HandlerFunc(adapter.GetUserByName))
	r.Method("PUT", "/user/{username}", http.HandlerFunc(adapter.UpdateUser))
	r.Method("DELETE", "/user/{username}", http.HandlerFunc(adapter.DeleteUser))

	return r
}

// ============================================================================
// Connexions Service Registration
// ============================================================================

//go:embed setup/config.yml
var configSrc []byte

//go:embed setup/openapi.*
var openapiSpecFS embed.FS

//go:embed setup/codegen.yml
var codegenConfigSrc []byte

//go:embed setup/context.yml
var contextSrc []byte

var cfg *config.ServiceConfig

func init() {
	var err error
	cfg, err = config.NewServiceConfigFromBytes(configSrc)
	if err != nil {
		slog.Error("Failed to parse service config", "error", err)
		return
	}
	loader.Register(cfg.Name, RegisterAPIRouter)
}

// Register registers the service with the central router.
func RegisterAPIRouter(router *api.Router) {
	serviceName := cfg.Name

	// Read OpenAPI spec from embedded FS
	openapiSpec, err := readFirstEmbeddedFile(openapiSpecFS)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to read OpenAPI spec for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}

	// Load codegen config
	var codegenCfg oapicodegen.Configuration
	if err := yamlv4.Unmarshal(codegenConfigSrc, &codegenCfg); err != nil {
		slog.Error(fmt.Sprintf("Failed to parse codegen config for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}
	codegenCfg = codegenCfg.Merge(oapicodegen.NewDefaultConfiguration())

	// Create the typedef registry from the OpenAPI spec
	registry := typedef.NewRegistryFromSpec(openapiSpec, codegenCfg, cfg.SpecOptions)

	// Create the generator with service contexts
	orderedCtx := generator.LoadServiceContext(contextSrc, router.GetContexts())
	gen, err := generator.NewGenerator(orderedCtx)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to create generator for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}

	// Register with connexions using handler factory
	router.RegisterHTTPHandler(cfg, func(serviceDB db.DB) api.Handler {
		userSvc := &service{db: serviceDB}
		genSvc := &generatorService{service: userSvc, generator: gen, registry: registry}
		return newServiceHandler(genSvc, gen, registry)
	}, api.WithMiddleware(getMiddleware()))

	slog.Info(fmt.Sprintf("Registered %s service", serviceName),
		"service", serviceName,
	)
}

// readFirstEmbeddedFile reads the first file from an embedded filesystem.
func readFirstEmbeddedFile(fsys embed.FS) ([]byte, error) {
	entries, err := fsys.ReadDir("setup")
	if err != nil {
		return nil, fmt.Errorf("reading embedded directory: %w", err)
	}
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasPrefix(entry.Name(), "openapi.") {
			return fsys.ReadFile(path.Join("setup", entry.Name()))
		}
	}
	return nil, errors.New("no openapi spec file found in embedded filesystem")
}

// ============================================================================
// Service Handler
// ============================================================================

// serviceHandler wraps the chi router and service to implement api.Handler.
type serviceHandler struct {
	router   chi.Router
	service  ServiceInterface
	gen      generator.Generate
	registry typedef.OperationRegistry
}

// newServiceHandler creates a new serviceHandler.
func newServiceHandler(svc ServiceInterface, gen generator.Generate, registry typedef.OperationRegistry) api.Handler {
	return &serviceHandler{
		router:   NewRouter(svc),
		service:  svc,
		gen:      gen,
		registry: registry,
	}
}

func (h *serviceHandler) Routes() api.RouteDescriptions {
	routes := h.router.Routes()
	descriptions := make(api.RouteDescriptions, 0, len(routes))
	for _, route := range routes {
		for method := range route.Handlers {
			descriptions = append(descriptions, &api.RouteDescription{
				Method: method,
				Path:   route.Pattern,
			})
		}
	}
	return descriptions
}

func (h *serviceHandler) RegisterRoutes(router chi.Router) {
	router.Mount("/", h.router)
}

func (h *serviceHandler) Generate(w http.ResponseWriter, r *http.Request) {
	var req api.GenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		message := err.Error()
		if errors.Is(err, io.EOF) {
			message = "request body is empty or incomplete"
		}
		slog.Error("Failed to decode request", "error", err)
		http.Error(w, message, http.StatusBadRequest)
		return
	}

	op := h.registry.FindOperation(req.Path, req.Method)
	res := h.gen.Request(&req, op)
	api.NewJSONResponse(w).Send(res)
}

// ============================================================================
// Generator Service (fallback to mock responses)
// ============================================================================

// generatorService implements ServiceInterface with generator fallback.
// It delegates to the user's service first; if that returns nil, it generates a mock response.
type generatorService struct {
	service   *service
	generator generator.Generate
	registry  typedef.OperationRegistry
}

// Ensure generatorService implements ServiceInterface.
var _ ServiceInterface = (*generatorService)(nil)

// UpdatePet handles PUT /pet
func (s *generatorService) UpdatePet(ctx context.Context, opts *UpdatePetServiceRequestOptions) (*UpdatePetResponseData, error) {
	// Call user's service first
	if resp, err := s.service.UpdatePet(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/pet", "PUT")
	if respSchema == nil {
		return NewUpdatePetResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body UpdatePetResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewUpdatePetResponseData(&body).WithHeaders(res.Headers), nil
}

// AddPet handles POST /pet
func (s *generatorService) AddPet(ctx context.Context, opts *AddPetServiceRequestOptions) (*AddPetResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AddPet(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/pet", "POST")
	if respSchema == nil {
		return NewAddPetResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AddPetResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAddPetResponseData(&body).WithHeaders(res.Headers), nil
}

// FindPetsByStatus handles GET /pet/findByStatus
func (s *generatorService) FindPetsByStatus(ctx context.Context, opts *FindPetsByStatusServiceRequestOptions) (*FindPetsByStatusResponseData, error) {
	// Call user's service first
	if resp, err := s.service.FindPetsByStatus(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/pet/findByStatus", "GET")
	if respSchema == nil {
		return NewFindPetsByStatusResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body FindPetsByStatusResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewFindPetsByStatusResponseData(&body).WithHeaders(res.Headers), nil
}

// FindPetsByTags handles GET /pet/findByTags
func (s *generatorService) FindPetsByTags(ctx context.Context, opts *FindPetsByTagsServiceRequestOptions) (*FindPetsByTagsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.FindPetsByTags(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/pet/findByTags", "GET")
	if respSchema == nil {
		return NewFindPetsByTagsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body FindPetsByTagsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewFindPetsByTagsResponseData(&body).WithHeaders(res.Headers), nil
}

// GetPetByID handles GET /pet/{petId}
func (s *generatorService) GetPetByID(ctx context.Context, opts *GetPetByIDServiceRequestOptions) (*GetPetByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetPetByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/pet/{petId}", "GET")
	if respSchema == nil {
		return NewGetPetByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetPetByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetPetByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// UpdatePetWithForm handles POST /pet/{petId}
func (s *generatorService) UpdatePetWithForm(ctx context.Context, opts *UpdatePetWithFormServiceRequestOptions) (*UpdatePetWithFormResponseData, error) {
	// Call user's service first
	if resp, err := s.service.UpdatePetWithForm(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/pet/{petId}", "POST")
	if respSchema == nil {
		return NewUpdatePetWithFormResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body UpdatePetWithFormResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewUpdatePetWithFormResponseData(&body).WithHeaders(res.Headers), nil
}

// DeletePet handles DELETE /pet/{petId}
func (s *generatorService) DeletePet(ctx context.Context, opts *DeletePetServiceRequestOptions) (*DeletePetResponseData, error) {
	// Call user's service first
	if resp, err := s.service.DeletePet(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/pet/{petId}", "DELETE")
	if respSchema == nil {
		return NewDeletePetResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewDeletePetResponseData(nil).WithHeaders(res.Headers), nil
}

// UploadFile handles POST /pet/{petId}/uploadImage
func (s *generatorService) UploadFile(ctx context.Context, opts *UploadFileServiceRequestOptions) (*UploadFileResponseData, error) {
	// Call user's service first
	if resp, err := s.service.UploadFile(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/pet/{petId}/uploadImage", "POST")
	if respSchema == nil {
		return NewUploadFileResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body UploadFileResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewUploadFileResponseData(&body).WithHeaders(res.Headers), nil
}

// GetInventory handles GET /store/inventory
func (s *generatorService) GetInventory(ctx context.Context) (*GetInventoryResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetInventory(ctx); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/store/inventory", "GET")
	if respSchema == nil {
		return NewGetInventoryResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetInventoryResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetInventoryResponseData(&body).WithHeaders(res.Headers), nil
}

// PlaceOrder handles POST /store/order
func (s *generatorService) PlaceOrder(ctx context.Context, opts *PlaceOrderServiceRequestOptions) (*PlaceOrderResponseData, error) {
	// Call user's service first
	if resp, err := s.service.PlaceOrder(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/store/order", "POST")
	if respSchema == nil {
		return NewPlaceOrderResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body PlaceOrderResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewPlaceOrderResponseData(&body).WithHeaders(res.Headers), nil
}

// GetOrderByID handles GET /store/order/{orderId}
func (s *generatorService) GetOrderByID(ctx context.Context, opts *GetOrderByIDServiceRequestOptions) (*GetOrderByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetOrderByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/store/order/{orderId}", "GET")
	if respSchema == nil {
		return NewGetOrderByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetOrderByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetOrderByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// DeleteOrder handles DELETE /store/order/{orderId}
func (s *generatorService) DeleteOrder(ctx context.Context, opts *DeleteOrderServiceRequestOptions) (*DeleteOrderResponseData, error) {
	// Call user's service first
	if resp, err := s.service.DeleteOrder(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/store/order/{orderId}", "DELETE")
	if respSchema == nil {
		return NewDeleteOrderResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewDeleteOrderResponseData(nil).WithHeaders(res.Headers), nil
}

// CreateUser handles POST /user
func (s *generatorService) CreateUser(ctx context.Context, opts *CreateUserServiceRequestOptions) (*CreateUserResponseData, error) {
	// Call user's service first
	if resp, err := s.service.CreateUser(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/user", "POST")
	if respSchema == nil {
		return NewCreateUserResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body CreateUserResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewCreateUserResponseData(&body).WithHeaders(res.Headers), nil
}

// CreateUsersWithListInput handles POST /user/createWithList
func (s *generatorService) CreateUsersWithListInput(ctx context.Context, opts *CreateUsersWithListInputServiceRequestOptions) (*CreateUsersWithListInputResponseData, error) {
	// Call user's service first
	if resp, err := s.service.CreateUsersWithListInput(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/user/createWithList", "POST")
	if respSchema == nil {
		return NewCreateUsersWithListInputResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body CreateUsersWithListInputResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewCreateUsersWithListInputResponseData(&body).WithHeaders(res.Headers), nil
}

// LoginUser handles GET /user/login
func (s *generatorService) LoginUser(ctx context.Context, opts *LoginUserServiceRequestOptions) (*LoginUserResponseData, error) {
	// Call user's service first
	if resp, err := s.service.LoginUser(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/user/login", "GET")
	if respSchema == nil {
		return NewLoginUserResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body LoginUserResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewLoginUserResponseData(&body).WithHeaders(res.Headers), nil
}

// LogoutUser handles GET /user/logout
func (s *generatorService) LogoutUser(ctx context.Context) (*LogoutUserResponseData, error) {
	// Call user's service first
	if resp, err := s.service.LogoutUser(ctx); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/user/logout", "GET")
	if respSchema == nil {
		return NewLogoutUserResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewLogoutUserResponseData(nil).WithHeaders(res.Headers), nil
}

// GetUserByName handles GET /user/{username}
func (s *generatorService) GetUserByName(ctx context.Context, opts *GetUserByNameServiceRequestOptions) (*GetUserByNameResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUserByName(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/user/{username}", "GET")
	if respSchema == nil {
		return NewGetUserByNameResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetUserByNameResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetUserByNameResponseData(&body).WithHeaders(res.Headers), nil
}

// UpdateUser handles PUT /user/{username}
func (s *generatorService) UpdateUser(ctx context.Context, opts *UpdateUserServiceRequestOptions) (*UpdateUserResponseData, error) {
	// Call user's service first
	if resp, err := s.service.UpdateUser(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/user/{username}", "PUT")
	if respSchema == nil {
		return NewUpdateUserResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewUpdateUserResponseData(nil).WithHeaders(res.Headers), nil
}

// DeleteUser handles DELETE /user/{username}
func (s *generatorService) DeleteUser(ctx context.Context, opts *DeleteUserServiceRequestOptions) (*DeleteUserResponseData, error) {
	// Call user's service first
	if resp, err := s.service.DeleteUser(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/user/{username}", "DELETE")
	if respSchema == nil {
		return NewDeleteUserResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewDeleteUserResponseData(nil).WithHeaders(res.Headers), nil
}

type DeletePetHeaders struct {
	APIKey *string `json:"api_key,omitempty"`
}

type GetPetByIDPath struct {
	PetID int64 `json:"petId" validate:"required"`
}

func (g GetPetByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type UpdatePetWithFormPath struct {
	PetID int64 `json:"petId" validate:"required"`
}

func (u UpdatePetWithFormPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(u))
}

type DeletePetPath struct {
	PetID int64 `json:"petId" validate:"required"`
}

func (d DeletePetPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type UploadFilePath struct {
	PetID int64 `json:"petId" validate:"required"`
}

func (u UploadFilePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(u))
}

type GetOrderByIDPath struct {
	OrderID int64 `json:"orderId" validate:"required"`
}

func (g GetOrderByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type DeleteOrderPath struct {
	OrderID int64 `json:"orderId" validate:"required"`
}

func (d DeleteOrderPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetUserByNamePath struct {
	Username string `json:"username" validate:"required"`
}

func (g GetUserByNamePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type UpdateUserPath struct {
	Username string `json:"username" validate:"required"`
}

func (u UpdateUserPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(u))
}

type DeleteUserPath struct {
	Username string `json:"username" validate:"required"`
}

func (d DeleteUserPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type UpdatePetBody = Pet

type AddPetBody = Pet

type UploadFileBody = runtime.File

type PlaceOrderBody = Order

type CreateUserBody = User

type CreateUsersWithListInputBody []User

func (c CreateUsersWithListInputBody) Validate() error {
	if c == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range c {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateUserBody = User

type FindPetsByStatusQuery struct {
	Status FindPetsByStatusQueryStatus `json:"status" validate:"required"`
}

func (f FindPetsByStatusQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(f.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type FindPetsByTagsQuery struct {
	Tags []string `json:"tags" validate:"required"`
}

func (f FindPetsByTagsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(f))
}

type UpdatePetWithFormQuery struct {
	Name   *string `json:"name,omitempty"`
	Status *string `json:"status,omitempty"`
}

type UploadFileQuery struct {
	AdditionalMetadata *string `json:"additionalMetadata,omitempty"`
}

type LoginUserQuery struct {
	Username *string `json:"username,omitempty"`
	Password *string `json:"password,omitempty"`
}

// UpdatePetResponseData wraps the success response with optional headers and status override.
type UpdatePetResponseData struct {
	Body    *UpdatePetResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewUpdatePetResponseData creates a new UpdatePetResponseData with the given body.
func NewUpdatePetResponseData(body *UpdatePetResponse) *UpdatePetResponseData {
	return &UpdatePetResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *UpdatePetResponseData) WithHeaders(h http.Header) *UpdatePetResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *UpdatePetResponseData) WithStatus(code int) *UpdatePetResponseData {
	r.Status = code
	return r
}

// AddPetResponseData wraps the success response with optional headers and status override.
type AddPetResponseData struct {
	Body    *AddPetResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAddPetResponseData creates a new AddPetResponseData with the given body.
func NewAddPetResponseData(body *AddPetResponse) *AddPetResponseData {
	return &AddPetResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AddPetResponseData) WithHeaders(h http.Header) *AddPetResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AddPetResponseData) WithStatus(code int) *AddPetResponseData {
	r.Status = code
	return r
}

// FindPetsByStatusResponseData wraps the success response with optional headers and status override.
type FindPetsByStatusResponseData struct {
	Body    *FindPetsByStatusResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewFindPetsByStatusResponseData creates a new FindPetsByStatusResponseData with the given body.
func NewFindPetsByStatusResponseData(body *FindPetsByStatusResponse) *FindPetsByStatusResponseData {
	return &FindPetsByStatusResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *FindPetsByStatusResponseData) WithHeaders(h http.Header) *FindPetsByStatusResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *FindPetsByStatusResponseData) WithStatus(code int) *FindPetsByStatusResponseData {
	r.Status = code
	return r
}

// FindPetsByTagsResponseData wraps the success response with optional headers and status override.
type FindPetsByTagsResponseData struct {
	Body    *FindPetsByTagsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewFindPetsByTagsResponseData creates a new FindPetsByTagsResponseData with the given body.
func NewFindPetsByTagsResponseData(body *FindPetsByTagsResponse) *FindPetsByTagsResponseData {
	return &FindPetsByTagsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *FindPetsByTagsResponseData) WithHeaders(h http.Header) *FindPetsByTagsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *FindPetsByTagsResponseData) WithStatus(code int) *FindPetsByTagsResponseData {
	r.Status = code
	return r
}

// GetPetByIDResponseData wraps the success response with optional headers and status override.
type GetPetByIDResponseData struct {
	Body    *GetPetByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetPetByIDResponseData creates a new GetPetByIDResponseData with the given body.
func NewGetPetByIDResponseData(body *GetPetByIDResponse) *GetPetByIDResponseData {
	return &GetPetByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetPetByIDResponseData) WithHeaders(h http.Header) *GetPetByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetPetByIDResponseData) WithStatus(code int) *GetPetByIDResponseData {
	r.Status = code
	return r
}

// UpdatePetWithFormResponseData wraps the success response with optional headers and status override.
type UpdatePetWithFormResponseData struct {
	Body    *UpdatePetWithFormResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewUpdatePetWithFormResponseData creates a new UpdatePetWithFormResponseData with the given body.
func NewUpdatePetWithFormResponseData(body *UpdatePetWithFormResponse) *UpdatePetWithFormResponseData {
	return &UpdatePetWithFormResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *UpdatePetWithFormResponseData) WithHeaders(h http.Header) *UpdatePetWithFormResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *UpdatePetWithFormResponseData) WithStatus(code int) *UpdatePetWithFormResponseData {
	r.Status = code
	return r
}

// DeletePetResponseData wraps the success response with optional headers and status override.
type DeletePetResponseData struct {
	Body    *struct{}
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewDeletePetResponseData creates a new DeletePetResponseData with the given body.
func NewDeletePetResponseData(body *struct{}) *DeletePetResponseData {
	return &DeletePetResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *DeletePetResponseData) WithHeaders(h http.Header) *DeletePetResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *DeletePetResponseData) WithStatus(code int) *DeletePetResponseData {
	r.Status = code
	return r
}

// UploadFileResponseData wraps the success response with optional headers and status override.
type UploadFileResponseData struct {
	Body    *UploadFileResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewUploadFileResponseData creates a new UploadFileResponseData with the given body.
func NewUploadFileResponseData(body *UploadFileResponse) *UploadFileResponseData {
	return &UploadFileResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *UploadFileResponseData) WithHeaders(h http.Header) *UploadFileResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *UploadFileResponseData) WithStatus(code int) *UploadFileResponseData {
	r.Status = code
	return r
}

// GetInventoryResponseData wraps the success response with optional headers and status override.
type GetInventoryResponseData struct {
	Body    *GetInventoryResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetInventoryResponseData creates a new GetInventoryResponseData with the given body.
func NewGetInventoryResponseData(body *GetInventoryResponse) *GetInventoryResponseData {
	return &GetInventoryResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetInventoryResponseData) WithHeaders(h http.Header) *GetInventoryResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetInventoryResponseData) WithStatus(code int) *GetInventoryResponseData {
	r.Status = code
	return r
}

// PlaceOrderResponseData wraps the success response with optional headers and status override.
type PlaceOrderResponseData struct {
	Body    *PlaceOrderResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewPlaceOrderResponseData creates a new PlaceOrderResponseData with the given body.
func NewPlaceOrderResponseData(body *PlaceOrderResponse) *PlaceOrderResponseData {
	return &PlaceOrderResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *PlaceOrderResponseData) WithHeaders(h http.Header) *PlaceOrderResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *PlaceOrderResponseData) WithStatus(code int) *PlaceOrderResponseData {
	r.Status = code
	return r
}

// GetOrderByIDResponseData wraps the success response with optional headers and status override.
type GetOrderByIDResponseData struct {
	Body    *GetOrderByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetOrderByIDResponseData creates a new GetOrderByIDResponseData with the given body.
func NewGetOrderByIDResponseData(body *GetOrderByIDResponse) *GetOrderByIDResponseData {
	return &GetOrderByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetOrderByIDResponseData) WithHeaders(h http.Header) *GetOrderByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetOrderByIDResponseData) WithStatus(code int) *GetOrderByIDResponseData {
	r.Status = code
	return r
}

// DeleteOrderResponseData wraps the success response with optional headers and status override.
type DeleteOrderResponseData struct {
	Body    *struct{}
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewDeleteOrderResponseData creates a new DeleteOrderResponseData with the given body.
func NewDeleteOrderResponseData(body *struct{}) *DeleteOrderResponseData {
	return &DeleteOrderResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *DeleteOrderResponseData) WithHeaders(h http.Header) *DeleteOrderResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *DeleteOrderResponseData) WithStatus(code int) *DeleteOrderResponseData {
	r.Status = code
	return r
}

// CreateUserResponseData wraps the success response with optional headers and status override.
type CreateUserResponseData struct {
	Body    *CreateUserResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewCreateUserResponseData creates a new CreateUserResponseData with the given body.
func NewCreateUserResponseData(body *CreateUserResponse) *CreateUserResponseData {
	return &CreateUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *CreateUserResponseData) WithHeaders(h http.Header) *CreateUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *CreateUserResponseData) WithStatus(code int) *CreateUserResponseData {
	r.Status = code
	return r
}

// CreateUsersWithListInputResponseData wraps the success response with optional headers and status override.
type CreateUsersWithListInputResponseData struct {
	Body    *CreateUsersWithListInputResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewCreateUsersWithListInputResponseData creates a new CreateUsersWithListInputResponseData with the given body.
func NewCreateUsersWithListInputResponseData(body *CreateUsersWithListInputResponse) *CreateUsersWithListInputResponseData {
	return &CreateUsersWithListInputResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *CreateUsersWithListInputResponseData) WithHeaders(h http.Header) *CreateUsersWithListInputResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *CreateUsersWithListInputResponseData) WithStatus(code int) *CreateUsersWithListInputResponseData {
	r.Status = code
	return r
}

// LoginUserResponseData wraps the success response with optional headers and status override.
type LoginUserResponseData struct {
	Body    *LoginUserResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewLoginUserResponseData creates a new LoginUserResponseData with the given body.
func NewLoginUserResponseData(body *LoginUserResponse) *LoginUserResponseData {
	return &LoginUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *LoginUserResponseData) WithHeaders(h http.Header) *LoginUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *LoginUserResponseData) WithStatus(code int) *LoginUserResponseData {
	r.Status = code
	return r
}

// LogoutUserResponseData wraps the success response with optional headers and status override.
type LogoutUserResponseData struct {
	Body    *struct{}
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewLogoutUserResponseData creates a new LogoutUserResponseData with the given body.
func NewLogoutUserResponseData(body *struct{}) *LogoutUserResponseData {
	return &LogoutUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *LogoutUserResponseData) WithHeaders(h http.Header) *LogoutUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *LogoutUserResponseData) WithStatus(code int) *LogoutUserResponseData {
	r.Status = code
	return r
}

// GetUserByNameResponseData wraps the success response with optional headers and status override.
type GetUserByNameResponseData struct {
	Body    *GetUserByNameResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserByNameResponseData creates a new GetUserByNameResponseData with the given body.
func NewGetUserByNameResponseData(body *GetUserByNameResponse) *GetUserByNameResponseData {
	return &GetUserByNameResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserByNameResponseData) WithHeaders(h http.Header) *GetUserByNameResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserByNameResponseData) WithStatus(code int) *GetUserByNameResponseData {
	r.Status = code
	return r
}

// UpdateUserResponseData wraps the success response with optional headers and status override.
type UpdateUserResponseData struct {
	Body    *struct{}
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewUpdateUserResponseData creates a new UpdateUserResponseData with the given body.
func NewUpdateUserResponseData(body *struct{}) *UpdateUserResponseData {
	return &UpdateUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *UpdateUserResponseData) WithHeaders(h http.Header) *UpdateUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *UpdateUserResponseData) WithStatus(code int) *UpdateUserResponseData {
	r.Status = code
	return r
}

// DeleteUserResponseData wraps the success response with optional headers and status override.
type DeleteUserResponseData struct {
	Body    *struct{}
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewDeleteUserResponseData creates a new DeleteUserResponseData with the given body.
func NewDeleteUserResponseData(body *struct{}) *DeleteUserResponseData {
	return &DeleteUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *DeleteUserResponseData) WithHeaders(h http.Header) *DeleteUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *DeleteUserResponseData) WithStatus(code int) *DeleteUserResponseData {
	r.Status = code
	return r
}

type UpdatePetResponse = Pet

type AddPetResponse = Pet

type FindPetsByStatusResponse []Pet

func (f FindPetsByStatusResponse) Validate() error {
	if f == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range f {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type FindPetsByTagsResponse []Pet

func (f FindPetsByTagsResponse) Validate() error {
	if f == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range f {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPetByIDResponse = Pet

type UpdatePetWithFormResponse = Pet

type UploadFileResponse = APIResponse

type GetInventoryResponse map[string]int32

type PlaceOrderResponse = Order

type GetOrderByIDResponse = Order

type CreateUserResponse = User

type CreateUsersWithListInputResponse = User

type LoginUserResponse = string

type GetUserByNameResponse = User

// UpdatePetServiceRequestOptions holds all parameters for the UpdatePet operation.
type UpdatePetServiceRequestOptions struct {
	Body *UpdatePetBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *UpdatePetServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AddPetServiceRequestOptions holds all parameters for the AddPet operation.
type AddPetServiceRequestOptions struct {
	Body *AddPetBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AddPetServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// FindPetsByStatusServiceRequestOptions holds all parameters for the FindPetsByStatus operation.
type FindPetsByStatusServiceRequestOptions struct {
	Query *FindPetsByStatusQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *FindPetsByStatusServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// FindPetsByTagsServiceRequestOptions holds all parameters for the FindPetsByTags operation.
type FindPetsByTagsServiceRequestOptions struct {
	Query *FindPetsByTagsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *FindPetsByTagsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPetByIDServiceRequestOptions holds all parameters for the GetPetByID operation.
type GetPetByIDServiceRequestOptions struct {
	PathParams *GetPetByIDPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetPetByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// UpdatePetWithFormServiceRequestOptions holds all parameters for the UpdatePetWithForm operation.
type UpdatePetWithFormServiceRequestOptions struct {
	PathParams *UpdatePetWithFormPath
	Query      *UpdatePetWithFormQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *UpdatePetWithFormServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// DeletePetServiceRequestOptions holds all parameters for the DeletePet operation.
type DeletePetServiceRequestOptions struct {
	PathParams *DeletePetPath
	Header     *DeletePetHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *DeletePetServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// UploadFileServiceRequestOptions holds all parameters for the UploadFile operation.
type UploadFileServiceRequestOptions struct {
	PathParams *UploadFilePath
	Query      *UploadFileQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *UploadFileServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// PlaceOrderServiceRequestOptions holds all parameters for the PlaceOrder operation.
type PlaceOrderServiceRequestOptions struct {
	Body *PlaceOrderBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *PlaceOrderServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetOrderByIDServiceRequestOptions holds all parameters for the GetOrderByID operation.
type GetOrderByIDServiceRequestOptions struct {
	PathParams *GetOrderByIDPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetOrderByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// DeleteOrderServiceRequestOptions holds all parameters for the DeleteOrder operation.
type DeleteOrderServiceRequestOptions struct {
	PathParams *DeleteOrderPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *DeleteOrderServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// CreateUserServiceRequestOptions holds all parameters for the CreateUser operation.
type CreateUserServiceRequestOptions struct {
	Body *CreateUserBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *CreateUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// CreateUsersWithListInputServiceRequestOptions holds all parameters for the CreateUsersWithListInput operation.
type CreateUsersWithListInputServiceRequestOptions struct {
	Body *CreateUsersWithListInputBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *CreateUsersWithListInputServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// LoginUserServiceRequestOptions holds all parameters for the LoginUser operation.
type LoginUserServiceRequestOptions struct {
	Query *LoginUserQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *LoginUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserByNameServiceRequestOptions holds all parameters for the GetUserByName operation.
type GetUserByNameServiceRequestOptions struct {
	PathParams *GetUserByNamePath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserByNameServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// UpdateUserServiceRequestOptions holds all parameters for the UpdateUser operation.
type UpdateUserServiceRequestOptions struct {
	PathParams *UpdateUserPath
	Body       *UpdateUserBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *UpdateUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// DeleteUserServiceRequestOptions holds all parameters for the DeleteUser operation.
type DeleteUserServiceRequestOptions struct {
	PathParams *DeleteUserPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *DeleteUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

type Order struct {
	ID       *int64       `json:"id,omitempty"`
	PetID    *int64       `json:"petId,omitempty"`
	Quantity *int32       `json:"quantity,omitempty"`
	ShipDate *time.Time   `json:"shipDate,omitempty"`
	Status   *OrderStatus `json:"status,omitempty"`
	Complete *bool        `json:"complete,omitempty"`
}

func (o Order) Validate() error {
	var errors runtime.ValidationErrors
	if o.Status != nil {
		if v, ok := any(o.Status).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Status", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Category struct {
	ID   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type User struct {
	ID         *int64  `json:"id,omitempty"`
	Username   *string `json:"username,omitempty"`
	FirstName  *string `json:"firstName,omitempty"`
	LastName   *string `json:"lastName,omitempty"`
	Email      *string `json:"email,omitempty"`
	Password   *string `json:"password,omitempty"`
	Phone      *string `json:"phone,omitempty"`
	UserStatus *int32  `json:"userStatus,omitempty"`
}

type Tag struct {
	ID   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type Pet struct {
	ID        *int64     `json:"id,omitempty"`
	Name      string     `json:"name" validate:"required"`
	Category  *Category  `json:"category,omitempty"`
	PhotoUrls []string   `json:"photoUrls" validate:"required"`
	Tags      []Tag      `json:"tags,omitempty"`
	Status    *PetStatus `json:"status,omitempty"`
}

func (p Pet) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if p.Category != nil {
		if v, ok := any(p.Category).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Category", err)
			}
		}
	}
	if err := typesValidator.Var(p.PhotoUrls, "required"); err != nil {
		errors = errors.Append("PhotoUrls", err)
	}
	for i, item := range p.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if p.Status != nil {
		if v, ok := any(p.Status).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Status", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type APIResponse struct {
	Code    *int32  `json:"code,omitempty"`
	Type    *string `json:"type,omitempty"`
	Message *string `json:"message,omitempty"`
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
