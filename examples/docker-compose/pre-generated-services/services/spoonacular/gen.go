// Code generated by oapi-codegen. DO NOT EDIT.

package spoonacular

import (
	"context"
	"embed"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"path"
	"strings"

	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/config"
	"github.com/cubahno/connexions/v2/pkg/db"
	"github.com/cubahno/connexions/v2/pkg/generator"
	"github.com/cubahno/connexions/v2/pkg/loader"
	"github.com/cubahno/connexions/v2/pkg/typedef"
	oapicodegen "github.com/doordash-oss/oapi-codegen-dd/v3/pkg/codegen"
	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
	yamlv4 "go.yaml.in/yaml/v4"
)

type Language string

const (
	LanguageDe Language = "de"
	LanguageEn Language = "en"
)

// Validate checks if the Language value is valid
func (l Language) Validate() error {
	switch l {
	case LanguageDe, LanguageEn:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Language value, got: %v", l))
	}
}

type ContentType string

const (
	ContentTypeApplicationJSON               ContentType = "application/json"
	ContentTypeApplicationXWwwFormUrlencoded ContentType = "application/x-www-form-urlencoded"
	ContentTypeMultipartFormData             ContentType = "multipart/form-data"
)

// Validate checks if the ContentType value is valid
func (c ContentType) Validate() error {
	switch c {
	case ContentTypeApplicationJSON, ContentTypeApplicationXWwwFormUrlencoded, ContentTypeMultipartFormData:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid ContentType value, got: %v", c))
	}
}

type Accept string

const (
	AcceptApplicationJSON Accept = "application/json"
	AcceptMedia           Accept = "media/*"
	AcceptTextHTML        Accept = "text/html"
)

// Validate checks if the Accept value is valid
func (a Accept) Validate() error {
	switch a {
	case AcceptApplicationJSON, AcceptMedia, AcceptTextHTML:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Accept value, got: %v", a))
	}
}

type GetRecipeTasteByIDQueryNormalize bool

const (
	GetRecipeTasteByIDQueryNormalizeFalse GetRecipeTasteByIDQueryNormalize = false
	GetRecipeTasteByIDQueryNormalizeTrue  GetRecipeTasteByIDQueryNormalize = true
)

// Validate checks if the GetRecipeTasteByIDQueryNormalize value is valid
func (g GetRecipeTasteByIDQueryNormalize) Validate() error {
	switch g {
	case GetRecipeTasteByIDQueryNormalizeFalse, GetRecipeTasteByIDQueryNormalizeTrue:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid GetRecipeTasteByIDQueryNormalize value, got: %v", g))
	}
}

type IngredientsByIDImageQueryMeasure string

const (
	IngredientsByIDImageQueryMeasureMetric IngredientsByIDImageQueryMeasure = "metric"
	IngredientsByIDImageQueryMeasureUs     IngredientsByIDImageQueryMeasure = "us"
)

// Validate checks if the IngredientsByIDImageQueryMeasure value is valid
func (i IngredientsByIDImageQueryMeasure) Validate() error {
	switch i {
	case IngredientsByIDImageQueryMeasureMetric, IngredientsByIDImageQueryMeasureUs:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid IngredientsByIDImageQueryMeasure value, got: %v", i))
	}
}

type VisualizeRecipeIngredientsByIDQueryMeasure string

const (
	VisualizeRecipeIngredientsByIDQueryMeasureMetric VisualizeRecipeIngredientsByIDQueryMeasure = "metric"
	VisualizeRecipeIngredientsByIDQueryMeasureUs     VisualizeRecipeIngredientsByIDQueryMeasure = "us"
)

// Validate checks if the VisualizeRecipeIngredientsByIDQueryMeasure value is valid
func (v VisualizeRecipeIngredientsByIDQueryMeasure) Validate() error {
	switch v {
	case VisualizeRecipeIngredientsByIDQueryMeasureMetric, VisualizeRecipeIngredientsByIDQueryMeasureUs:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid VisualizeRecipeIngredientsByIDQueryMeasure value, got: %v", v))
	}
}

type VisualizeRecipeTasteByIDQueryNormalize bool

const (
	VisualizeRecipeTasteByIDQueryNormalizeFalse VisualizeRecipeTasteByIDQueryNormalize = false
	VisualizeRecipeTasteByIDQueryNormalizeTrue  VisualizeRecipeTasteByIDQueryNormalize = true
)

// Validate checks if the VisualizeRecipeTasteByIDQueryNormalize value is valid
func (v VisualizeRecipeTasteByIDQueryNormalize) Validate() error {
	switch v {
	case VisualizeRecipeTasteByIDQueryNormalizeFalse, VisualizeRecipeTasteByIDQueryNormalizeTrue:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid VisualizeRecipeTasteByIDQueryNormalize value, got: %v", v))
	}
}

type SearchGroceryProductsQueryAddProductInformation bool

const (
	SearchGroceryProductsQueryAddProductInformationFalse SearchGroceryProductsQueryAddProductInformation = false
	SearchGroceryProductsQueryAddProductInformationTrue  SearchGroceryProductsQueryAddProductInformation = true
)

// Validate checks if the SearchGroceryProductsQueryAddProductInformation value is valid
func (s SearchGroceryProductsQueryAddProductInformation) Validate() error {
	switch s {
	case SearchGroceryProductsQueryAddProductInformationFalse, SearchGroceryProductsQueryAddProductInformationTrue:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid SearchGroceryProductsQueryAddProductInformation value, got: %v", s))
	}
}

type ClassifyGroceryProductQueryLocale string

const (
	ClassifyGroceryProductQueryLocaleEnGB ClassifyGroceryProductQueryLocale = "en_GB"
	ClassifyGroceryProductQueryLocaleEnUS ClassifyGroceryProductQueryLocale = "en_US"
)

// Validate checks if the ClassifyGroceryProductQueryLocale value is valid
func (c ClassifyGroceryProductQueryLocale) Validate() error {
	switch c {
	case ClassifyGroceryProductQueryLocaleEnGB, ClassifyGroceryProductQueryLocaleEnUS:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid ClassifyGroceryProductQueryLocale value, got: %v", c))
	}
}

type SearchMenuItemsQueryAddMenuItemInformation bool

const (
	SearchMenuItemsQueryAddMenuItemInformationFalse SearchMenuItemsQueryAddMenuItemInformation = false
	SearchMenuItemsQueryAddMenuItemInformationTrue  SearchMenuItemsQueryAddMenuItemInformation = true
)

// Validate checks if the SearchMenuItemsQueryAddMenuItemInformation value is valid
func (s SearchMenuItemsQueryAddMenuItemInformation) Validate() error {
	switch s {
	case SearchMenuItemsQueryAddMenuItemInformationFalse, SearchMenuItemsQueryAddMenuItemInformationTrue:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid SearchMenuItemsQueryAddMenuItemInformation value, got: %v", s))
	}
}

// OapiErrorKind represents the type of error that occurred during request processing.
type OapiErrorKind int

const (
	// OapiErrorKindParse indicates a parameter parsing error (invalid path/query/header parameter).
	OapiErrorKindParse OapiErrorKind = iota

	// OapiErrorKindDecode indicates a request body decoding error (invalid JSON, form data, etc.).
	OapiErrorKindDecode

	// OapiErrorKindValidation indicates a request validation error (failed schema validation).
	OapiErrorKindValidation

	// OapiErrorKindService indicates a service/business logic error returned by the service implementation.
	OapiErrorKindService
)

// OapiHandlerError represents an error that occurred during request handling (parse, decode, validation).
// When no typed error response is configured in the OpenAPI spec, this error type is used.
// Custom error handlers can type-assert to this type to access error details.
type OapiHandlerError struct {
	Kind          OapiErrorKind
	OperationID   string
	Message       string
	ParamName     string
	ParamLocation string
}

func (e OapiHandlerError) Error() string {
	return e.Message
}

// OapiErrorResponse is the default JSON error response structure used by OapiDefaultErrorHandler.
type OapiErrorResponse struct {
	Error         string `json:"error"`
	OperationID   string `json:"operation_id,omitempty"`
	ParamName     string `json:"param_name,omitempty"`
	ParamLocation string `json:"param_location,omitempty"`
}

// OapiErrorHandler handles errors that occur during request processing.
// Implement this interface to customize error responses, logging, and metrics.
type OapiErrorHandler interface {
	// HandleError writes an error response to w with the given status code.
	// The err is either an OapiHandlerError (for parse/decode/validation errors)
	// or a typed error matching the OpenAPI spec's error response schema.
	HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error)
}

// OapiDefaultErrorHandler provides the default error handling behavior.
// It writes JSON error responses. For OapiHandlerError, it uses OapiErrorResponse.
// For typed errors (from OpenAPI spec), it encodes them directly.
type OapiDefaultErrorHandler struct{}

// HandleError implements OapiErrorHandler with default JSON error responses.
func (h *OapiDefaultErrorHandler) HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)

	if handlerErr, ok := err.(OapiHandlerError); ok {
		_ = json.NewEncoder(w).Encode(OapiErrorResponse{
			Error:         handlerErr.Message,
			OperationID:   handlerErr.OperationID,
			ParamName:     handlerErr.ParamName,
			ParamLocation: handlerErr.ParamLocation,
		})
		return
	}

	// Typed error from OpenAPI spec - encode directly
	_ = json.NewEncoder(w).Encode(err)
}

// ServiceInterface defines the service interface for business logic.
type ServiceInterface interface {
	// SearchRecipes Search Recipes
	SearchRecipes(ctx context.Context, opts *SearchRecipesServiceRequestOptions) (*SearchRecipesResponseData, error)
	// SearchRecipesByIngredients Search Recipes by Ingredients
	SearchRecipesByIngredients(ctx context.Context, opts *SearchRecipesByIngredientsServiceRequestOptions) (*SearchRecipesByIngredientsResponseData, error)
	// SearchRecipesByNutrients Search Recipes by Nutrients
	SearchRecipesByNutrients(ctx context.Context, opts *SearchRecipesByNutrientsServiceRequestOptions) (*SearchRecipesByNutrientsResponseData, error)
	// GetRecipeInformation Get Recipe Information
	GetRecipeInformation(ctx context.Context, opts *GetRecipeInformationServiceRequestOptions) (*GetRecipeInformationResponseData, error)
	// GetRecipeInformationBulk Get Recipe Information Bulk
	GetRecipeInformationBulk(ctx context.Context, opts *GetRecipeInformationBulkServiceRequestOptions) (*GetRecipeInformationBulkResponseData, error)
	// GetSimilarRecipes Get Similar Recipes
	GetSimilarRecipes(ctx context.Context, opts *GetSimilarRecipesServiceRequestOptions) (*GetSimilarRecipesResponseData, error)
	// GetRandomRecipes Get Random Recipes
	GetRandomRecipes(ctx context.Context, opts *GetRandomRecipesServiceRequestOptions) (*GetRandomRecipesResponseData, error)
	// AutocompleteRecipeSearch Autocomplete Recipe Search
	AutocompleteRecipeSearch(ctx context.Context, opts *AutocompleteRecipeSearchServiceRequestOptions) (*AutocompleteRecipeSearchResponseData, error)
	// GetRecipeTasteByID Taste by ID
	GetRecipeTasteByID(ctx context.Context, opts *GetRecipeTasteByIDServiceRequestOptions) (*GetRecipeTasteByIDResponseData, error)
	// RecipeTasteByIDImage Recipe Taste by ID Image
	RecipeTasteByIDImage(ctx context.Context, opts *RecipeTasteByIDImageServiceRequestOptions) (*RecipeTasteByIDImageResponseData, error)
	// GetRecipeEquipmentByID Equipment by ID
	GetRecipeEquipmentByID(ctx context.Context, opts *GetRecipeEquipmentByIDServiceRequestOptions) (*GetRecipeEquipmentByIDResponseData, error)
	// EquipmentByIDImage Equipment by ID Image
	EquipmentByIDImage(ctx context.Context, opts *EquipmentByIDImageServiceRequestOptions) (*EquipmentByIDImageResponseData, error)
	// GetRecipePriceBreakdownByID Price Breakdown by ID
	GetRecipePriceBreakdownByID(ctx context.Context, opts *GetRecipePriceBreakdownByIDServiceRequestOptions) (*GetRecipePriceBreakdownByIDResponseData, error)
	// PriceBreakdownByIDImage Price Breakdown by ID Image
	PriceBreakdownByIDImage(ctx context.Context, opts *PriceBreakdownByIDImageServiceRequestOptions) (*PriceBreakdownByIDImageResponseData, error)
	// GetRecipeIngredientsByID Ingredients by ID
	GetRecipeIngredientsByID(ctx context.Context, opts *GetRecipeIngredientsByIDServiceRequestOptions) (*GetRecipeIngredientsByIDResponseData, error)
	// IngredientsByIDImage Ingredients by ID Image
	IngredientsByIDImage(ctx context.Context, opts *IngredientsByIDImageServiceRequestOptions) (*IngredientsByIDImageResponseData, error)
	// GetRecipeNutritionWidgetByID Nutrition by ID
	GetRecipeNutritionWidgetByID(ctx context.Context, opts *GetRecipeNutritionWidgetByIDServiceRequestOptions) (*GetRecipeNutritionWidgetByIDResponseData, error)
	// RecipeNutritionByIDImage Recipe Nutrition by ID Image
	RecipeNutritionByIDImage(ctx context.Context, opts *RecipeNutritionByIDImageServiceRequestOptions) (*RecipeNutritionByIDImageResponseData, error)
	// RecipeNutritionLabelWidget Recipe Nutrition Label Widget
	RecipeNutritionLabelWidget(ctx context.Context, opts *RecipeNutritionLabelWidgetServiceRequestOptions) (*RecipeNutritionLabelWidgetResponseData, error)
	// RecipeNutritionLabelImage Recipe Nutrition Label Image
	RecipeNutritionLabelImage(ctx context.Context, opts *RecipeNutritionLabelImageServiceRequestOptions) (*RecipeNutritionLabelImageResponseData, error)
	// GetAnalyzedRecipeInstructions Get Analyzed Recipe Instructions
	GetAnalyzedRecipeInstructions(ctx context.Context, opts *GetAnalyzedRecipeInstructionsServiceRequestOptions) (*GetAnalyzedRecipeInstructionsResponseData, error)
	// ExtractRecipeFromWebsite Extract Recipe from Website
	ExtractRecipeFromWebsite(ctx context.Context, opts *ExtractRecipeFromWebsiteServiceRequestOptions) (*ExtractRecipeFromWebsiteResponseData, error)
	// VisualizeRecipeIngredientsByID Ingredients by ID Widget
	VisualizeRecipeIngredientsByID(ctx context.Context, opts *VisualizeRecipeIngredientsByIDServiceRequestOptions) (*VisualizeRecipeIngredientsByIDResponseData, error)
	// VisualizeRecipeTasteByID Recipe Taste by ID Widget
	VisualizeRecipeTasteByID(ctx context.Context, opts *VisualizeRecipeTasteByIDServiceRequestOptions) (*VisualizeRecipeTasteByIDResponseData, error)
	// VisualizeRecipeEquipmentByID Equipment by ID Widget
	VisualizeRecipeEquipmentByID(ctx context.Context, opts *VisualizeRecipeEquipmentByIDServiceRequestOptions) (*VisualizeRecipeEquipmentByIDResponseData, error)
	// VisualizeRecipePriceBreakdownByID Price Breakdown by ID Widget
	VisualizeRecipePriceBreakdownByID(ctx context.Context, opts *VisualizeRecipePriceBreakdownByIDServiceRequestOptions) (*VisualizeRecipePriceBreakdownByIDResponseData, error)
	// VisualizeRecipeTaste Recipe Taste Widget
	VisualizeRecipeTaste(ctx context.Context, opts *VisualizeRecipeTasteServiceRequestOptions) (*VisualizeRecipeTasteResponseData, error)
	// VisualizeRecipeNutrition Recipe Nutrition Widget
	VisualizeRecipeNutrition(ctx context.Context, opts *VisualizeRecipeNutritionServiceRequestOptions) (*VisualizeRecipeNutritionResponseData, error)
	// VisualizePriceBreakdown Price Breakdown Widget
	VisualizePriceBreakdown(ctx context.Context, opts *VisualizePriceBreakdownServiceRequestOptions) (*VisualizePriceBreakdownResponseData, error)
	// VisualizeEquipment Equipment Widget
	VisualizeEquipment(ctx context.Context, opts *VisualizeEquipmentServiceRequestOptions) (*VisualizeEquipmentResponseData, error)
	// AnalyzeRecipe Analyze Recipe
	AnalyzeRecipe(ctx context.Context, opts *AnalyzeRecipeServiceRequestOptions) (*AnalyzeRecipeResponseData, error)
	// SummarizeRecipe Summarize Recipe
	SummarizeRecipe(ctx context.Context, opts *SummarizeRecipeServiceRequestOptions) (*SummarizeRecipeResponseData, error)
	// CreateRecipeCardGet Create Recipe Card
	CreateRecipeCardGet(ctx context.Context, opts *CreateRecipeCardGetServiceRequestOptions) (*CreateRecipeCardGetResponseData, error)
	// CreateRecipeCard Create Recipe Card
	CreateRecipeCard(ctx context.Context, opts *CreateRecipeCardServiceRequestOptions) (*CreateRecipeCardResponseData, error)
	// AnalyzeRecipeInstructions Analyze Recipe Instructions
	AnalyzeRecipeInstructions(ctx context.Context, opts *AnalyzeRecipeInstructionsServiceRequestOptions) (*AnalyzeRecipeInstructionsResponseData, error)
	// ClassifyCuisine Classify Cuisine
	ClassifyCuisine(ctx context.Context, opts *ClassifyCuisineServiceRequestOptions) (*ClassifyCuisineResponseData, error)
	// AnalyzeARecipeSearchQuery Analyze a Recipe Search Query
	AnalyzeARecipeSearchQuery(ctx context.Context, opts *AnalyzeARecipeSearchQueryServiceRequestOptions) (*AnalyzeARecipeSearchQueryResponseData, error)
	// ConvertAmounts Convert Amounts
	ConvertAmounts(ctx context.Context, opts *ConvertAmountsServiceRequestOptions) (*ConvertAmountsResponseData, error)
	// ParseIngredients Parse Ingredients
	ParseIngredients(ctx context.Context, opts *ParseIngredientsServiceRequestOptions) (*ParseIngredientsResponseData, error)
	// VisualizeRecipeNutritionByID Recipe Nutrition by ID Widget
	VisualizeRecipeNutritionByID(ctx context.Context, opts *VisualizeRecipeNutritionByIDServiceRequestOptions) (*VisualizeRecipeNutritionByIDResponseData, error)
	// VisualizeIngredients Ingredients Widget
	VisualizeIngredients(ctx context.Context, opts *VisualizeIngredientsServiceRequestOptions) (*VisualizeIngredientsResponseData, error)
	// GuessNutritionByDishName Guess Nutrition by Dish Name
	GuessNutritionByDishName(ctx context.Context, opts *GuessNutritionByDishNameServiceRequestOptions) (*GuessNutritionByDishNameResponseData, error)
	// GetIngredientInformation Get Ingredient Information
	GetIngredientInformation(ctx context.Context, opts *GetIngredientInformationServiceRequestOptions) (*GetIngredientInformationResponseData, error)
	// ComputeIngredientAmount Compute Ingredient Amount
	ComputeIngredientAmount(ctx context.Context, opts *ComputeIngredientAmountServiceRequestOptions) (*ComputeIngredientAmountResponseData, error)
	// ComputeGlycemicLoad Compute Glycemic Load
	ComputeGlycemicLoad(ctx context.Context, opts *ComputeGlycemicLoadServiceRequestOptions) (*ComputeGlycemicLoadResponseData, error)
	// AutocompleteIngredientSearch Autocomplete Ingredient Search
	AutocompleteIngredientSearch(ctx context.Context, opts *AutocompleteIngredientSearchServiceRequestOptions) (*AutocompleteIngredientSearchResponseData, error)
	// IngredientSearch Ingredient Search
	IngredientSearch(ctx context.Context, opts *IngredientSearchServiceRequestOptions) (*IngredientSearchResponseData, error)
	// GetIngredientSubstitutes Get Ingredient Substitutes
	GetIngredientSubstitutes(ctx context.Context, opts *GetIngredientSubstitutesServiceRequestOptions) (*GetIngredientSubstitutesResponseData, error)
	// GetIngredientSubstitutesByID Get Ingredient Substitutes by ID
	GetIngredientSubstitutesByID(ctx context.Context, opts *GetIngredientSubstitutesByIDServiceRequestOptions) (*GetIngredientSubstitutesByIDResponseData, error)
	// SearchGroceryProducts Search Grocery Products
	SearchGroceryProducts(ctx context.Context, opts *SearchGroceryProductsServiceRequestOptions) (*SearchGroceryProductsResponseData, error)
	// SearchGroceryProductsByUPC Search Grocery Products by UPC
	SearchGroceryProductsByUPC(ctx context.Context, opts *SearchGroceryProductsByUPCServiceRequestOptions) (*SearchGroceryProductsByUPCResponseData, error)
	// SearchCustomFoods Search Custom Foods
	SearchCustomFoods(ctx context.Context, opts *SearchCustomFoodsServiceRequestOptions) (*SearchCustomFoodsResponseData, error)
	// GetProductInformation Get Product Information
	GetProductInformation(ctx context.Context, opts *GetProductInformationServiceRequestOptions) (*GetProductInformationResponseData, error)
	// GetComparableProducts Get Comparable Products
	GetComparableProducts(ctx context.Context, opts *GetComparableProductsServiceRequestOptions) (*GetComparableProductsResponseData, error)
	// AutocompleteProductSearch Autocomplete Product Search
	AutocompleteProductSearch(ctx context.Context, opts *AutocompleteProductSearchServiceRequestOptions) (*AutocompleteProductSearchResponseData, error)
	// VisualizeProductNutritionByID Product Nutrition by ID Widget
	VisualizeProductNutritionByID(ctx context.Context, opts *VisualizeProductNutritionByIDServiceRequestOptions) (*VisualizeProductNutritionByIDResponseData, error)
	// ProductNutritionByIDImage Product Nutrition by ID Image
	ProductNutritionByIDImage(ctx context.Context, opts *ProductNutritionByIDImageServiceRequestOptions) (*ProductNutritionByIDImageResponseData, error)
	// ProductNutritionLabelWidget Product Nutrition Label Widget
	ProductNutritionLabelWidget(ctx context.Context, opts *ProductNutritionLabelWidgetServiceRequestOptions) (*ProductNutritionLabelWidgetResponseData, error)
	// ProductNutritionLabelImage Product Nutrition Label Image
	ProductNutritionLabelImage(ctx context.Context, opts *ProductNutritionLabelImageServiceRequestOptions) (*ProductNutritionLabelImageResponseData, error)
	// ClassifyGroceryProduct Classify Grocery Product
	ClassifyGroceryProduct(ctx context.Context, opts *ClassifyGroceryProductServiceRequestOptions) (*ClassifyGroceryProductResponseData, error)
	// ClassifyGroceryProductBulk Classify Grocery Product Bulk
	ClassifyGroceryProductBulk(ctx context.Context, opts *ClassifyGroceryProductBulkServiceRequestOptions) (*ClassifyGroceryProductBulkResponseData, error)
	// MapIngredientsToGroceryProducts Map Ingredients to Grocery Products
	MapIngredientsToGroceryProducts(ctx context.Context, opts *MapIngredientsToGroceryProductsServiceRequestOptions) (*MapIngredientsToGroceryProductsResponseData, error)
	// AutocompleteMenuItemSearch Autocomplete Menu Item Search
	AutocompleteMenuItemSearch(ctx context.Context, opts *AutocompleteMenuItemSearchServiceRequestOptions) (*AutocompleteMenuItemSearchResponseData, error)
	// SearchMenuItems Search Menu Items
	SearchMenuItems(ctx context.Context, opts *SearchMenuItemsServiceRequestOptions) (*SearchMenuItemsResponseData, error)
	// GetMenuItemInformation Get Menu Item Information
	GetMenuItemInformation(ctx context.Context, opts *GetMenuItemInformationServiceRequestOptions) (*GetMenuItemInformationResponseData, error)
	// VisualizeMenuItemNutritionByID Menu Item Nutrition by ID Widget
	VisualizeMenuItemNutritionByID(ctx context.Context, opts *VisualizeMenuItemNutritionByIDServiceRequestOptions) (*VisualizeMenuItemNutritionByIDResponseData, error)
	// MenuItemNutritionByIDImage Menu Item Nutrition by ID Image
	MenuItemNutritionByIDImage(ctx context.Context, opts *MenuItemNutritionByIDImageServiceRequestOptions) (*MenuItemNutritionByIDImageResponseData, error)
	// MenuItemNutritionLabelWidget Menu Item Nutrition Label Widget
	MenuItemNutritionLabelWidget(ctx context.Context, opts *MenuItemNutritionLabelWidgetServiceRequestOptions) (*MenuItemNutritionLabelWidgetResponseData, error)
	// MenuItemNutritionLabelImage Menu Item Nutrition Label Image
	MenuItemNutritionLabelImage(ctx context.Context, opts *MenuItemNutritionLabelImageServiceRequestOptions) (*MenuItemNutritionLabelImageResponseData, error)
	// GenerateMealPlan Generate Meal Plan
	GenerateMealPlan(ctx context.Context, opts *GenerateMealPlanServiceRequestOptions) (*GenerateMealPlanResponseData, error)
	// GetMealPlanWeek Get Meal Plan Week
	GetMealPlanWeek(ctx context.Context, opts *GetMealPlanWeekServiceRequestOptions) (*GetMealPlanWeekResponseData, error)
	// ClearMealPlanDay Clear Meal Plan Day
	ClearMealPlanDay(ctx context.Context, opts *ClearMealPlanDayServiceRequestOptions) (*ClearMealPlanDayResponseData, error)
	// AddToMealPlan Add to Meal Plan
	AddToMealPlan(ctx context.Context, opts *AddToMealPlanServiceRequestOptions) (*AddToMealPlanResponseData, error)
	// DeleteFromMealPlan Delete from Meal Plan
	DeleteFromMealPlan(ctx context.Context, opts *DeleteFromMealPlanServiceRequestOptions) (*DeleteFromMealPlanResponseData, error)
	// GetMealPlanTemplates Get Meal Plan Templates
	GetMealPlanTemplates(ctx context.Context, opts *GetMealPlanTemplatesServiceRequestOptions) (*GetMealPlanTemplatesResponseData, error)
	// AddMealPlanTemplate Add Meal Plan Template
	AddMealPlanTemplate(ctx context.Context, opts *AddMealPlanTemplateServiceRequestOptions) (*AddMealPlanTemplateResponseData, error)
	// GetMealPlanTemplate Get Meal Plan Template
	GetMealPlanTemplate(ctx context.Context, opts *GetMealPlanTemplateServiceRequestOptions) (*GetMealPlanTemplateResponseData, error)
	// DeleteMealPlanTemplate Delete Meal Plan Template
	DeleteMealPlanTemplate(ctx context.Context, opts *DeleteMealPlanTemplateServiceRequestOptions) (*DeleteMealPlanTemplateResponseData, error)
	// GetShoppingList Get Shopping List
	GetShoppingList(ctx context.Context, opts *GetShoppingListServiceRequestOptions) (*GetShoppingListResponseData, error)
	// GenerateShoppingList Generate Shopping List
	GenerateShoppingList(ctx context.Context, opts *GenerateShoppingListServiceRequestOptions) (*GenerateShoppingListResponseData, error)
	// ConnectUser Connect User
	ConnectUser(ctx context.Context, opts *ConnectUserServiceRequestOptions) (*ConnectUserResponseData, error)
	// AddToShoppingList Add to Shopping List
	AddToShoppingList(ctx context.Context, opts *AddToShoppingListServiceRequestOptions) (*AddToShoppingListResponseData, error)
	// DeleteFromShoppingList Delete from Shopping List
	DeleteFromShoppingList(ctx context.Context, opts *DeleteFromShoppingListServiceRequestOptions) (*DeleteFromShoppingListResponseData, error)
	// SearchRestaurants Search Restaurants
	SearchRestaurants(ctx context.Context, opts *SearchRestaurantsServiceRequestOptions) (*SearchRestaurantsResponseData, error)
	// GetDishPairingForWine Dish Pairing for Wine
	GetDishPairingForWine(ctx context.Context, opts *GetDishPairingForWineServiceRequestOptions) (*GetDishPairingForWineResponseData, error)
	// GetWinePairing Wine Pairing
	GetWinePairing(ctx context.Context, opts *GetWinePairingServiceRequestOptions) (*GetWinePairingResponseData, error)
	// GetWineDescription Wine Description
	GetWineDescription(ctx context.Context, opts *GetWineDescriptionServiceRequestOptions) (*GetWineDescriptionResponseData, error)
	// GetWineRecommendation Wine Recommendation
	GetWineRecommendation(ctx context.Context, opts *GetWineRecommendationServiceRequestOptions) (*GetWineRecommendationResponseData, error)
	// ImageClassificationByURL Image Classification by URL
	ImageClassificationByURL(ctx context.Context, opts *ImageClassificationByURLServiceRequestOptions) (*ImageClassificationByURLResponseData, error)
	// ImageAnalysisByURL Image Analysis by URL
	ImageAnalysisByURL(ctx context.Context, opts *ImageAnalysisByURLServiceRequestOptions) (*ImageAnalysisByURLResponseData, error)
	// QuickAnswer Quick Answer
	QuickAnswer(ctx context.Context, opts *QuickAnswerServiceRequestOptions) (*QuickAnswerResponseData, error)
	// DetectFoodInText Detect Food in Text
	DetectFoodInText(ctx context.Context, opts *DetectFoodInTextServiceRequestOptions) (*DetectFoodInTextResponseData, error)
	// SearchSiteContent Search Site Content
	SearchSiteContent(ctx context.Context, opts *SearchSiteContentServiceRequestOptions) (*SearchSiteContentResponseData, error)
	// SearchAllFood Search All Food
	SearchAllFood(ctx context.Context, opts *SearchAllFoodServiceRequestOptions) (*SearchAllFoodResponseData, error)
	// SearchFoodVideos Search Food Videos
	SearchFoodVideos(ctx context.Context, opts *SearchFoodVideosServiceRequestOptions) (*SearchFoodVideosResponseData, error)
	// GetARandomFoodJoke Random Food Joke
	GetARandomFoodJoke(ctx context.Context) (*GetARandomFoodJokeResponseData, error)
	// GetRandomFoodTrivia Random Food Trivia
	GetRandomFoodTrivia(ctx context.Context) (*GetRandomFoodTriviaResponseData, error)
	// TalkToChatbot Talk to Chatbot
	TalkToChatbot(ctx context.Context, opts *TalkToChatbotServiceRequestOptions) (*TalkToChatbotResponseData, error)
	// GetConversationSuggests Conversation Suggests
	GetConversationSuggests(ctx context.Context, opts *GetConversationSuggestsServiceRequestOptions) (*GetConversationSuggestsResponseData, error)
}

// HTTPAdapter adapts the ServiceInterface to HTTP handlers.
// This struct is generated and should not be modified.
type HTTPAdapter struct {
	svc        ServiceInterface
	errHandler OapiErrorHandler
}

// NewHTTPAdapter creates a new HTTPAdapter wrapping the given service.
// If errHandler is nil, OapiDefaultErrorHandler is used.
func NewHTTPAdapter(svc ServiceInterface, errHandler OapiErrorHandler) *HTTPAdapter {
	if errHandler == nil {
		errHandler = &OapiDefaultErrorHandler{}
	}
	return &HTTPAdapter{svc: svc, errHandler: errHandler}
}

// SearchRecipes handles GET /recipes/complexSearch
func (a *HTTPAdapter) SearchRecipes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchRecipesServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchRecipesQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery, err := runtime.ParseString[Query](queryParamQueryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "query",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Query = &queryParamQuery
	}
	if queryParamCuisineStr := query.Get("cuisine"); queryParamCuisineStr != "" {
		queryParamCuisine := queryParamCuisineStr
		queryParams.Cuisine = &queryParamCuisine
	}
	if queryParamExcludeCuisineStr := query.Get("excludeCuisine"); queryParamExcludeCuisineStr != "" {
		queryParamExcludeCuisine := queryParamExcludeCuisineStr
		queryParams.ExcludeCuisine = &queryParamExcludeCuisine
	}
	if queryParamDietStr := query.Get("diet"); queryParamDietStr != "" {
		queryParamDiet := queryParamDietStr
		queryParams.Diet = &queryParamDiet
	}
	if queryParamIntolerancesStr := query.Get("intolerances"); queryParamIntolerancesStr != "" {
		queryParamIntolerances := queryParamIntolerancesStr
		queryParams.Intolerances = &queryParamIntolerances
	}
	if queryParamEquipmentStr := query.Get("equipment"); queryParamEquipmentStr != "" {
		queryParamEquipment := queryParamEquipmentStr
		queryParams.Equipment = &queryParamEquipment
	}
	if queryParamIncludeIngredientsStr := query.Get("includeIngredients"); queryParamIncludeIngredientsStr != "" {
		queryParamIncludeIngredients := queryParamIncludeIngredientsStr
		queryParams.IncludeIngredients = &queryParamIncludeIngredients
	}
	if queryParamExcludeIngredientsStr := query.Get("excludeIngredients"); queryParamExcludeIngredientsStr != "" {
		queryParamExcludeIngredients := queryParamExcludeIngredientsStr
		queryParams.ExcludeIngredients = &queryParamExcludeIngredients
	}
	if queryParamTypeStr := query.Get("type"); queryParamTypeStr != "" {
		queryParamType := queryParamTypeStr
		queryParams.Type = &queryParamType
	}
	if queryParamInstructionsRequiredStr := query.Get("instructionsRequired"); queryParamInstructionsRequiredStr != "" {
		queryParamInstructionsRequired, err := runtime.ParseString[bool](queryParamInstructionsRequiredStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "instructionsRequired",
				ParamLocation: "query",
			})
			return
		}
		queryParams.InstructionsRequired = &queryParamInstructionsRequired
	}
	if queryParamFillIngredientsStr := query.Get("fillIngredients"); queryParamFillIngredientsStr != "" {
		queryParamFillIngredients, err := runtime.ParseString[bool](queryParamFillIngredientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "fillIngredients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.FillIngredients = &queryParamFillIngredients
	}
	if queryParamAddRecipeInformationStr := query.Get("addRecipeInformation"); queryParamAddRecipeInformationStr != "" {
		queryParamAddRecipeInformation, err := runtime.ParseString[bool](queryParamAddRecipeInformationStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "addRecipeInformation",
				ParamLocation: "query",
			})
			return
		}
		queryParams.AddRecipeInformation = &queryParamAddRecipeInformation
	}
	if queryParamAddRecipeNutritionStr := query.Get("addRecipeNutrition"); queryParamAddRecipeNutritionStr != "" {
		queryParamAddRecipeNutrition, err := runtime.ParseString[bool](queryParamAddRecipeNutritionStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "addRecipeNutrition",
				ParamLocation: "query",
			})
			return
		}
		queryParams.AddRecipeNutrition = &queryParamAddRecipeNutrition
	}
	if queryParamAuthorStr := query.Get("author"); queryParamAuthorStr != "" {
		queryParamAuthor := queryParamAuthorStr
		queryParams.Author = &queryParamAuthor
	}
	if queryParamTagsStr := query.Get("tags"); queryParamTagsStr != "" {
		queryParamTags, err := runtime.ParseString[Tags](queryParamTagsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "tags",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Tags = &queryParamTags
	}
	if queryParamRecipeBoxIDStr := query.Get("recipeBoxId"); queryParamRecipeBoxIDStr != "" {
		queryParamRecipeBoxID, err := runtime.ParseString[float32](queryParamRecipeBoxIDStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "recipeBoxId",
				ParamLocation: "query",
			})
			return
		}
		queryParams.RecipeBoxID = &queryParamRecipeBoxID
	}
	if queryParamTitleMatchStr := query.Get("titleMatch"); queryParamTitleMatchStr != "" {
		queryParamTitleMatch := queryParamTitleMatchStr
		queryParams.TitleMatch = &queryParamTitleMatch
	}
	if queryParamMaxReadyTimeStr := query.Get("maxReadyTime"); queryParamMaxReadyTimeStr != "" {
		queryParamMaxReadyTime, err := runtime.ParseString[float32](queryParamMaxReadyTimeStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxReadyTime",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxReadyTime = &queryParamMaxReadyTime
	}
	if queryParamIgnorePantryStr := query.Get("ignorePantry"); queryParamIgnorePantryStr != "" {
		queryParamIgnorePantry, err := runtime.ParseString[IgnorePantry](queryParamIgnorePantryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "ignorePantry",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IgnorePantry = &queryParamIgnorePantry
	}
	if queryParamSortStr := query.Get("sort"); queryParamSortStr != "" {
		queryParamSort := queryParamSortStr
		queryParams.Sort = &queryParamSort
	}
	if queryParamSortDirectionStr := query.Get("sortDirection"); queryParamSortDirectionStr != "" {
		queryParamSortDirection := queryParamSortDirectionStr
		queryParams.SortDirection = &queryParamSortDirection
	}
	if queryParamMinCarbsStr := query.Get("minCarbs"); queryParamMinCarbsStr != "" {
		queryParamMinCarbs, err := runtime.ParseString[float32](queryParamMinCarbsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minCarbs",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCarbs = &queryParamMinCarbs
	}
	if queryParamMaxCarbsStr := query.Get("maxCarbs"); queryParamMaxCarbsStr != "" {
		queryParamMaxCarbs, err := runtime.ParseString[float32](queryParamMaxCarbsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxCarbs",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCarbs = &queryParamMaxCarbs
	}
	if queryParamMinProteinStr := query.Get("minProtein"); queryParamMinProteinStr != "" {
		queryParamMinProtein, err := runtime.ParseString[float32](queryParamMinProteinStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minProtein",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinProtein = &queryParamMinProtein
	}
	if queryParamMaxProteinStr := query.Get("maxProtein"); queryParamMaxProteinStr != "" {
		queryParamMaxProtein, err := runtime.ParseString[float32](queryParamMaxProteinStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxProtein",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxProtein = &queryParamMaxProtein
	}
	if queryParamMinCaloriesStr := query.Get("minCalories"); queryParamMinCaloriesStr != "" {
		queryParamMinCalories, err := runtime.ParseString[float32](queryParamMinCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCalories = &queryParamMinCalories
	}
	if queryParamMaxCaloriesStr := query.Get("maxCalories"); queryParamMaxCaloriesStr != "" {
		queryParamMaxCalories, err := runtime.ParseString[float32](queryParamMaxCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCalories = &queryParamMaxCalories
	}
	if queryParamMinFatStr := query.Get("minFat"); queryParamMinFatStr != "" {
		queryParamMinFat, err := runtime.ParseString[float32](queryParamMinFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFat = &queryParamMinFat
	}
	if queryParamMaxFatStr := query.Get("maxFat"); queryParamMaxFatStr != "" {
		queryParamMaxFat, err := runtime.ParseString[float32](queryParamMaxFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFat = &queryParamMaxFat
	}
	if queryParamMinAlcoholStr := query.Get("minAlcohol"); queryParamMinAlcoholStr != "" {
		queryParamMinAlcohol, err := runtime.ParseString[float32](queryParamMinAlcoholStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minAlcohol",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinAlcohol = &queryParamMinAlcohol
	}
	if queryParamMaxAlcoholStr := query.Get("maxAlcohol"); queryParamMaxAlcoholStr != "" {
		queryParamMaxAlcohol, err := runtime.ParseString[float32](queryParamMaxAlcoholStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxAlcohol",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxAlcohol = &queryParamMaxAlcohol
	}
	if queryParamMinCaffeineStr := query.Get("minCaffeine"); queryParamMinCaffeineStr != "" {
		queryParamMinCaffeine, err := runtime.ParseString[float32](queryParamMinCaffeineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minCaffeine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCaffeine = &queryParamMinCaffeine
	}
	if queryParamMaxCaffeineStr := query.Get("maxCaffeine"); queryParamMaxCaffeineStr != "" {
		queryParamMaxCaffeine, err := runtime.ParseString[float32](queryParamMaxCaffeineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxCaffeine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCaffeine = &queryParamMaxCaffeine
	}
	if queryParamMinCopperStr := query.Get("minCopper"); queryParamMinCopperStr != "" {
		queryParamMinCopper, err := runtime.ParseString[float32](queryParamMinCopperStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minCopper",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCopper = &queryParamMinCopper
	}
	if queryParamMaxCopperStr := query.Get("maxCopper"); queryParamMaxCopperStr != "" {
		queryParamMaxCopper, err := runtime.ParseString[float32](queryParamMaxCopperStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxCopper",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCopper = &queryParamMaxCopper
	}
	if queryParamMinCalciumStr := query.Get("minCalcium"); queryParamMinCalciumStr != "" {
		queryParamMinCalcium, err := runtime.ParseString[float32](queryParamMinCalciumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minCalcium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCalcium = &queryParamMinCalcium
	}
	if queryParamMaxCalciumStr := query.Get("maxCalcium"); queryParamMaxCalciumStr != "" {
		queryParamMaxCalcium, err := runtime.ParseString[float32](queryParamMaxCalciumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxCalcium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCalcium = &queryParamMaxCalcium
	}
	if queryParamMinCholineStr := query.Get("minCholine"); queryParamMinCholineStr != "" {
		queryParamMinCholine, err := runtime.ParseString[float32](queryParamMinCholineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minCholine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCholine = &queryParamMinCholine
	}
	if queryParamMaxCholineStr := query.Get("maxCholine"); queryParamMaxCholineStr != "" {
		queryParamMaxCholine, err := runtime.ParseString[float32](queryParamMaxCholineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxCholine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCholine = &queryParamMaxCholine
	}
	if queryParamMinCholesterolStr := query.Get("minCholesterol"); queryParamMinCholesterolStr != "" {
		queryParamMinCholesterol, err := runtime.ParseString[float32](queryParamMinCholesterolStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minCholesterol",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCholesterol = &queryParamMinCholesterol
	}
	if queryParamMaxCholesterolStr := query.Get("maxCholesterol"); queryParamMaxCholesterolStr != "" {
		queryParamMaxCholesterol, err := runtime.ParseString[float32](queryParamMaxCholesterolStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxCholesterol",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCholesterol = &queryParamMaxCholesterol
	}
	if queryParamMinFluorideStr := query.Get("minFluoride"); queryParamMinFluorideStr != "" {
		queryParamMinFluoride, err := runtime.ParseString[float32](queryParamMinFluorideStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minFluoride",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFluoride = &queryParamMinFluoride
	}
	if queryParamMaxFluorideStr := query.Get("maxFluoride"); queryParamMaxFluorideStr != "" {
		queryParamMaxFluoride, err := runtime.ParseString[float32](queryParamMaxFluorideStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxFluoride",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFluoride = &queryParamMaxFluoride
	}
	if queryParamMinSaturatedFatStr := query.Get("minSaturatedFat"); queryParamMinSaturatedFatStr != "" {
		queryParamMinSaturatedFat, err := runtime.ParseString[float32](queryParamMinSaturatedFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minSaturatedFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinSaturatedFat = &queryParamMinSaturatedFat
	}
	if queryParamMaxSaturatedFatStr := query.Get("maxSaturatedFat"); queryParamMaxSaturatedFatStr != "" {
		queryParamMaxSaturatedFat, err := runtime.ParseString[float32](queryParamMaxSaturatedFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxSaturatedFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxSaturatedFat = &queryParamMaxSaturatedFat
	}
	if queryParamMinVitaminAStr := query.Get("minVitaminA"); queryParamMinVitaminAStr != "" {
		queryParamMinVitaminA, err := runtime.ParseString[float32](queryParamMinVitaminAStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminA",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminA = &queryParamMinVitaminA
	}
	if queryParamMaxVitaminAStr := query.Get("maxVitaminA"); queryParamMaxVitaminAStr != "" {
		queryParamMaxVitaminA, err := runtime.ParseString[float32](queryParamMaxVitaminAStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminA",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminA = &queryParamMaxVitaminA
	}
	if queryParamMinVitaminCStr := query.Get("minVitaminC"); queryParamMinVitaminCStr != "" {
		queryParamMinVitaminC, err := runtime.ParseString[float32](queryParamMinVitaminCStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminC",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminC = &queryParamMinVitaminC
	}
	if queryParamMaxVitaminCStr := query.Get("maxVitaminC"); queryParamMaxVitaminCStr != "" {
		queryParamMaxVitaminC, err := runtime.ParseString[float32](queryParamMaxVitaminCStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminC",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminC = &queryParamMaxVitaminC
	}
	if queryParamMinVitaminDStr := query.Get("minVitaminD"); queryParamMinVitaminDStr != "" {
		queryParamMinVitaminD, err := runtime.ParseString[float32](queryParamMinVitaminDStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminD",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminD = &queryParamMinVitaminD
	}
	if queryParamMaxVitaminDStr := query.Get("maxVitaminD"); queryParamMaxVitaminDStr != "" {
		queryParamMaxVitaminD, err := runtime.ParseString[float32](queryParamMaxVitaminDStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminD",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminD = &queryParamMaxVitaminD
	}
	if queryParamMinVitaminEStr := query.Get("minVitaminE"); queryParamMinVitaminEStr != "" {
		queryParamMinVitaminE, err := runtime.ParseString[float32](queryParamMinVitaminEStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminE",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminE = &queryParamMinVitaminE
	}
	if queryParamMaxVitaminEStr := query.Get("maxVitaminE"); queryParamMaxVitaminEStr != "" {
		queryParamMaxVitaminE, err := runtime.ParseString[float32](queryParamMaxVitaminEStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminE",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminE = &queryParamMaxVitaminE
	}
	if queryParamMinVitaminKStr := query.Get("minVitaminK"); queryParamMinVitaminKStr != "" {
		queryParamMinVitaminK, err := runtime.ParseString[float32](queryParamMinVitaminKStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminK",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminK = &queryParamMinVitaminK
	}
	if queryParamMaxVitaminKStr := query.Get("maxVitaminK"); queryParamMaxVitaminKStr != "" {
		queryParamMaxVitaminK, err := runtime.ParseString[float32](queryParamMaxVitaminKStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminK",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminK = &queryParamMaxVitaminK
	}
	if queryParamMinVitaminB1Str := query.Get("minVitaminB1"); queryParamMinVitaminB1Str != "" {
		queryParamMinVitaminB1, err := runtime.ParseString[float32](queryParamMinVitaminB1Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminB1",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB1 = &queryParamMinVitaminB1
	}
	if queryParamMaxVitaminB1Str := query.Get("maxVitaminB1"); queryParamMaxVitaminB1Str != "" {
		queryParamMaxVitaminB1, err := runtime.ParseString[float32](queryParamMaxVitaminB1Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminB1",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB1 = &queryParamMaxVitaminB1
	}
	if queryParamMinVitaminB2Str := query.Get("minVitaminB2"); queryParamMinVitaminB2Str != "" {
		queryParamMinVitaminB2, err := runtime.ParseString[float32](queryParamMinVitaminB2Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminB2",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB2 = &queryParamMinVitaminB2
	}
	if queryParamMaxVitaminB2Str := query.Get("maxVitaminB2"); queryParamMaxVitaminB2Str != "" {
		queryParamMaxVitaminB2, err := runtime.ParseString[float32](queryParamMaxVitaminB2Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminB2",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB2 = &queryParamMaxVitaminB2
	}
	if queryParamMinVitaminB5Str := query.Get("minVitaminB5"); queryParamMinVitaminB5Str != "" {
		queryParamMinVitaminB5, err := runtime.ParseString[float32](queryParamMinVitaminB5Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminB5",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB5 = &queryParamMinVitaminB5
	}
	if queryParamMaxVitaminB5Str := query.Get("maxVitaminB5"); queryParamMaxVitaminB5Str != "" {
		queryParamMaxVitaminB5, err := runtime.ParseString[float32](queryParamMaxVitaminB5Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminB5",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB5 = &queryParamMaxVitaminB5
	}
	if queryParamMinVitaminB3Str := query.Get("minVitaminB3"); queryParamMinVitaminB3Str != "" {
		queryParamMinVitaminB3, err := runtime.ParseString[float32](queryParamMinVitaminB3Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminB3",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB3 = &queryParamMinVitaminB3
	}
	if queryParamMaxVitaminB3Str := query.Get("maxVitaminB3"); queryParamMaxVitaminB3Str != "" {
		queryParamMaxVitaminB3, err := runtime.ParseString[float32](queryParamMaxVitaminB3Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminB3",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB3 = &queryParamMaxVitaminB3
	}
	if queryParamMinVitaminB6Str := query.Get("minVitaminB6"); queryParamMinVitaminB6Str != "" {
		queryParamMinVitaminB6, err := runtime.ParseString[float32](queryParamMinVitaminB6Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminB6",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB6 = &queryParamMinVitaminB6
	}
	if queryParamMaxVitaminB6Str := query.Get("maxVitaminB6"); queryParamMaxVitaminB6Str != "" {
		queryParamMaxVitaminB6, err := runtime.ParseString[float32](queryParamMaxVitaminB6Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminB6",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB6 = &queryParamMaxVitaminB6
	}
	if queryParamMinVitaminB12Str := query.Get("minVitaminB12"); queryParamMinVitaminB12Str != "" {
		queryParamMinVitaminB12, err := runtime.ParseString[float32](queryParamMinVitaminB12Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minVitaminB12",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB12 = &queryParamMinVitaminB12
	}
	if queryParamMaxVitaminB12Str := query.Get("maxVitaminB12"); queryParamMaxVitaminB12Str != "" {
		queryParamMaxVitaminB12, err := runtime.ParseString[float32](queryParamMaxVitaminB12Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxVitaminB12",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB12 = &queryParamMaxVitaminB12
	}
	if queryParamMinFiberStr := query.Get("minFiber"); queryParamMinFiberStr != "" {
		queryParamMinFiber, err := runtime.ParseString[float32](queryParamMinFiberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minFiber",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFiber = &queryParamMinFiber
	}
	if queryParamMaxFiberStr := query.Get("maxFiber"); queryParamMaxFiberStr != "" {
		queryParamMaxFiber, err := runtime.ParseString[float32](queryParamMaxFiberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxFiber",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFiber = &queryParamMaxFiber
	}
	if queryParamMinFolateStr := query.Get("minFolate"); queryParamMinFolateStr != "" {
		queryParamMinFolate, err := runtime.ParseString[float32](queryParamMinFolateStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minFolate",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFolate = &queryParamMinFolate
	}
	if queryParamMaxFolateStr := query.Get("maxFolate"); queryParamMaxFolateStr != "" {
		queryParamMaxFolate, err := runtime.ParseString[float32](queryParamMaxFolateStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxFolate",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFolate = &queryParamMaxFolate
	}
	if queryParamMinFolicAcidStr := query.Get("minFolicAcid"); queryParamMinFolicAcidStr != "" {
		queryParamMinFolicAcid, err := runtime.ParseString[float32](queryParamMinFolicAcidStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minFolicAcid",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFolicAcid = &queryParamMinFolicAcid
	}
	if queryParamMaxFolicAcidStr := query.Get("maxFolicAcid"); queryParamMaxFolicAcidStr != "" {
		queryParamMaxFolicAcid, err := runtime.ParseString[float32](queryParamMaxFolicAcidStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxFolicAcid",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFolicAcid = &queryParamMaxFolicAcid
	}
	if queryParamMinIodineStr := query.Get("minIodine"); queryParamMinIodineStr != "" {
		queryParamMinIodine, err := runtime.ParseString[float32](queryParamMinIodineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minIodine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinIodine = &queryParamMinIodine
	}
	if queryParamMaxIodineStr := query.Get("maxIodine"); queryParamMaxIodineStr != "" {
		queryParamMaxIodine, err := runtime.ParseString[float32](queryParamMaxIodineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxIodine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxIodine = &queryParamMaxIodine
	}
	if queryParamMinIronStr := query.Get("minIron"); queryParamMinIronStr != "" {
		queryParamMinIron, err := runtime.ParseString[float32](queryParamMinIronStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minIron",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinIron = &queryParamMinIron
	}
	if queryParamMaxIronStr := query.Get("maxIron"); queryParamMaxIronStr != "" {
		queryParamMaxIron, err := runtime.ParseString[float32](queryParamMaxIronStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxIron",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxIron = &queryParamMaxIron
	}
	if queryParamMinMagnesiumStr := query.Get("minMagnesium"); queryParamMinMagnesiumStr != "" {
		queryParamMinMagnesium, err := runtime.ParseString[float32](queryParamMinMagnesiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minMagnesium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinMagnesium = &queryParamMinMagnesium
	}
	if queryParamMaxMagnesiumStr := query.Get("maxMagnesium"); queryParamMaxMagnesiumStr != "" {
		queryParamMaxMagnesium, err := runtime.ParseString[float32](queryParamMaxMagnesiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxMagnesium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxMagnesium = &queryParamMaxMagnesium
	}
	if queryParamMinManganeseStr := query.Get("minManganese"); queryParamMinManganeseStr != "" {
		queryParamMinManganese, err := runtime.ParseString[float32](queryParamMinManganeseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minManganese",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinManganese = &queryParamMinManganese
	}
	if queryParamMaxManganeseStr := query.Get("maxManganese"); queryParamMaxManganeseStr != "" {
		queryParamMaxManganese, err := runtime.ParseString[float32](queryParamMaxManganeseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxManganese",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxManganese = &queryParamMaxManganese
	}
	if queryParamMinPhosphorusStr := query.Get("minPhosphorus"); queryParamMinPhosphorusStr != "" {
		queryParamMinPhosphorus, err := runtime.ParseString[float32](queryParamMinPhosphorusStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minPhosphorus",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinPhosphorus = &queryParamMinPhosphorus
	}
	if queryParamMaxPhosphorusStr := query.Get("maxPhosphorus"); queryParamMaxPhosphorusStr != "" {
		queryParamMaxPhosphorus, err := runtime.ParseString[float32](queryParamMaxPhosphorusStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxPhosphorus",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxPhosphorus = &queryParamMaxPhosphorus
	}
	if queryParamMinPotassiumStr := query.Get("minPotassium"); queryParamMinPotassiumStr != "" {
		queryParamMinPotassium, err := runtime.ParseString[float32](queryParamMinPotassiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minPotassium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinPotassium = &queryParamMinPotassium
	}
	if queryParamMaxPotassiumStr := query.Get("maxPotassium"); queryParamMaxPotassiumStr != "" {
		queryParamMaxPotassium, err := runtime.ParseString[float32](queryParamMaxPotassiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxPotassium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxPotassium = &queryParamMaxPotassium
	}
	if queryParamMinSeleniumStr := query.Get("minSelenium"); queryParamMinSeleniumStr != "" {
		queryParamMinSelenium, err := runtime.ParseString[float32](queryParamMinSeleniumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minSelenium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinSelenium = &queryParamMinSelenium
	}
	if queryParamMaxSeleniumStr := query.Get("maxSelenium"); queryParamMaxSeleniumStr != "" {
		queryParamMaxSelenium, err := runtime.ParseString[float32](queryParamMaxSeleniumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxSelenium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxSelenium = &queryParamMaxSelenium
	}
	if queryParamMinSodiumStr := query.Get("minSodium"); queryParamMinSodiumStr != "" {
		queryParamMinSodium, err := runtime.ParseString[float32](queryParamMinSodiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minSodium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinSodium = &queryParamMinSodium
	}
	if queryParamMaxSodiumStr := query.Get("maxSodium"); queryParamMaxSodiumStr != "" {
		queryParamMaxSodium, err := runtime.ParseString[float32](queryParamMaxSodiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxSodium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxSodium = &queryParamMaxSodium
	}
	if queryParamMinSugarStr := query.Get("minSugar"); queryParamMinSugarStr != "" {
		queryParamMinSugar, err := runtime.ParseString[float32](queryParamMinSugarStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minSugar",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinSugar = &queryParamMinSugar
	}
	if queryParamMaxSugarStr := query.Get("maxSugar"); queryParamMaxSugarStr != "" {
		queryParamMaxSugar, err := runtime.ParseString[float32](queryParamMaxSugarStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxSugar",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxSugar = &queryParamMaxSugar
	}
	if queryParamMinZincStr := query.Get("minZinc"); queryParamMinZincStr != "" {
		queryParamMinZinc, err := runtime.ParseString[float32](queryParamMinZincStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "minZinc",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinZinc = &queryParamMinZinc
	}
	if queryParamMaxZincStr := query.Get("maxZinc"); queryParamMaxZincStr != "" {
		queryParamMaxZinc, err := runtime.ParseString[float32](queryParamMaxZincStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "maxZinc",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxZinc = &queryParamMaxZinc
	}
	if queryParamOffsetStr := query.Get("offset"); queryParamOffsetStr != "" {
		queryParamOffset, err := runtime.ParseString[Offset](queryParamOffsetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "offset",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Offset = &queryParamOffset
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	if queryParamLimitLicenseStr := query.Get("limitLicense"); queryParamLimitLicenseStr != "" {
		queryParamLimitLicense, err := runtime.ParseString[LimitLicense](queryParamLimitLicenseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipes",
				Message:       err.Error(),
				ParamName:     "limitLicense",
				ParamLocation: "query",
			})
			return
		}
		queryParams.LimitLicense = &queryParamLimitLicense
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchRecipes(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchRecipesByIngredients handles GET /recipes/findByIngredients
func (a *HTTPAdapter) SearchRecipesByIngredients(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchRecipesByIngredientsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchRecipesByIngredientsQuery{}
	query := r.URL.Query()
	if queryParamIngredientsStr := query.Get("ingredients"); queryParamIngredientsStr != "" {
		queryParamIngredients, err := runtime.ParseString[Ingredients](queryParamIngredientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByIngredients",
				Message:       err.Error(),
				ParamName:     "ingredients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Ingredients = &queryParamIngredients
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByIngredients",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	if queryParamLimitLicenseStr := query.Get("limitLicense"); queryParamLimitLicenseStr != "" {
		queryParamLimitLicense, err := runtime.ParseString[LimitLicense](queryParamLimitLicenseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByIngredients",
				Message:       err.Error(),
				ParamName:     "limitLicense",
				ParamLocation: "query",
			})
			return
		}
		queryParams.LimitLicense = &queryParamLimitLicense
	}
	if queryParamRankingStr := query.Get("ranking"); queryParamRankingStr != "" {
		queryParamRanking, err := runtime.ParseString[float32](queryParamRankingStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByIngredients",
				Message:       err.Error(),
				ParamName:     "ranking",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Ranking = &queryParamRanking
	}
	if queryParamIgnorePantryStr := query.Get("ignorePantry"); queryParamIgnorePantryStr != "" {
		queryParamIgnorePantry, err := runtime.ParseString[IgnorePantry](queryParamIgnorePantryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByIngredients",
				Message:       err.Error(),
				ParamName:     "ignorePantry",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IgnorePantry = &queryParamIgnorePantry
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchRecipesByIngredients(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchRecipesByNutrients handles GET /recipes/findByNutrients
func (a *HTTPAdapter) SearchRecipesByNutrients(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchRecipesByNutrientsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchRecipesByNutrientsQuery{}
	query := r.URL.Query()
	if queryParamMinCarbsStr := query.Get("minCarbs"); queryParamMinCarbsStr != "" {
		queryParamMinCarbs, err := runtime.ParseString[float32](queryParamMinCarbsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minCarbs",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCarbs = &queryParamMinCarbs
	}
	if queryParamMaxCarbsStr := query.Get("maxCarbs"); queryParamMaxCarbsStr != "" {
		queryParamMaxCarbs, err := runtime.ParseString[float32](queryParamMaxCarbsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxCarbs",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCarbs = &queryParamMaxCarbs
	}
	if queryParamMinProteinStr := query.Get("minProtein"); queryParamMinProteinStr != "" {
		queryParamMinProtein, err := runtime.ParseString[float32](queryParamMinProteinStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minProtein",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinProtein = &queryParamMinProtein
	}
	if queryParamMaxProteinStr := query.Get("maxProtein"); queryParamMaxProteinStr != "" {
		queryParamMaxProtein, err := runtime.ParseString[float32](queryParamMaxProteinStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxProtein",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxProtein = &queryParamMaxProtein
	}
	if queryParamMinCaloriesStr := query.Get("minCalories"); queryParamMinCaloriesStr != "" {
		queryParamMinCalories, err := runtime.ParseString[float32](queryParamMinCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCalories = &queryParamMinCalories
	}
	if queryParamMaxCaloriesStr := query.Get("maxCalories"); queryParamMaxCaloriesStr != "" {
		queryParamMaxCalories, err := runtime.ParseString[float32](queryParamMaxCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCalories = &queryParamMaxCalories
	}
	if queryParamMinFatStr := query.Get("minFat"); queryParamMinFatStr != "" {
		queryParamMinFat, err := runtime.ParseString[float32](queryParamMinFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFat = &queryParamMinFat
	}
	if queryParamMaxFatStr := query.Get("maxFat"); queryParamMaxFatStr != "" {
		queryParamMaxFat, err := runtime.ParseString[float32](queryParamMaxFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFat = &queryParamMaxFat
	}
	if queryParamMinAlcoholStr := query.Get("minAlcohol"); queryParamMinAlcoholStr != "" {
		queryParamMinAlcohol, err := runtime.ParseString[float32](queryParamMinAlcoholStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minAlcohol",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinAlcohol = &queryParamMinAlcohol
	}
	if queryParamMaxAlcoholStr := query.Get("maxAlcohol"); queryParamMaxAlcoholStr != "" {
		queryParamMaxAlcohol, err := runtime.ParseString[float32](queryParamMaxAlcoholStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxAlcohol",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxAlcohol = &queryParamMaxAlcohol
	}
	if queryParamMinCaffeineStr := query.Get("minCaffeine"); queryParamMinCaffeineStr != "" {
		queryParamMinCaffeine, err := runtime.ParseString[float32](queryParamMinCaffeineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minCaffeine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCaffeine = &queryParamMinCaffeine
	}
	if queryParamMaxCaffeineStr := query.Get("maxCaffeine"); queryParamMaxCaffeineStr != "" {
		queryParamMaxCaffeine, err := runtime.ParseString[float32](queryParamMaxCaffeineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxCaffeine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCaffeine = &queryParamMaxCaffeine
	}
	if queryParamMinCopperStr := query.Get("minCopper"); queryParamMinCopperStr != "" {
		queryParamMinCopper, err := runtime.ParseString[float32](queryParamMinCopperStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minCopper",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCopper = &queryParamMinCopper
	}
	if queryParamMaxCopperStr := query.Get("maxCopper"); queryParamMaxCopperStr != "" {
		queryParamMaxCopper, err := runtime.ParseString[float32](queryParamMaxCopperStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxCopper",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCopper = &queryParamMaxCopper
	}
	if queryParamMinCalciumStr := query.Get("minCalcium"); queryParamMinCalciumStr != "" {
		queryParamMinCalcium, err := runtime.ParseString[float32](queryParamMinCalciumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minCalcium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCalcium = &queryParamMinCalcium
	}
	if queryParamMaxCalciumStr := query.Get("maxCalcium"); queryParamMaxCalciumStr != "" {
		queryParamMaxCalcium, err := runtime.ParseString[float32](queryParamMaxCalciumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxCalcium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCalcium = &queryParamMaxCalcium
	}
	if queryParamMinCholineStr := query.Get("minCholine"); queryParamMinCholineStr != "" {
		queryParamMinCholine, err := runtime.ParseString[float32](queryParamMinCholineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minCholine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCholine = &queryParamMinCholine
	}
	if queryParamMaxCholineStr := query.Get("maxCholine"); queryParamMaxCholineStr != "" {
		queryParamMaxCholine, err := runtime.ParseString[float32](queryParamMaxCholineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxCholine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCholine = &queryParamMaxCholine
	}
	if queryParamMinCholesterolStr := query.Get("minCholesterol"); queryParamMinCholesterolStr != "" {
		queryParamMinCholesterol, err := runtime.ParseString[float32](queryParamMinCholesterolStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minCholesterol",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCholesterol = &queryParamMinCholesterol
	}
	if queryParamMaxCholesterolStr := query.Get("maxCholesterol"); queryParamMaxCholesterolStr != "" {
		queryParamMaxCholesterol, err := runtime.ParseString[float32](queryParamMaxCholesterolStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxCholesterol",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCholesterol = &queryParamMaxCholesterol
	}
	if queryParamMinFluorideStr := query.Get("minFluoride"); queryParamMinFluorideStr != "" {
		queryParamMinFluoride, err := runtime.ParseString[float32](queryParamMinFluorideStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minFluoride",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFluoride = &queryParamMinFluoride
	}
	if queryParamMaxFluorideStr := query.Get("maxFluoride"); queryParamMaxFluorideStr != "" {
		queryParamMaxFluoride, err := runtime.ParseString[float32](queryParamMaxFluorideStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxFluoride",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFluoride = &queryParamMaxFluoride
	}
	if queryParamMinSaturatedFatStr := query.Get("minSaturatedFat"); queryParamMinSaturatedFatStr != "" {
		queryParamMinSaturatedFat, err := runtime.ParseString[float32](queryParamMinSaturatedFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minSaturatedFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinSaturatedFat = &queryParamMinSaturatedFat
	}
	if queryParamMaxSaturatedFatStr := query.Get("maxSaturatedFat"); queryParamMaxSaturatedFatStr != "" {
		queryParamMaxSaturatedFat, err := runtime.ParseString[float32](queryParamMaxSaturatedFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxSaturatedFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxSaturatedFat = &queryParamMaxSaturatedFat
	}
	if queryParamMinVitaminAStr := query.Get("minVitaminA"); queryParamMinVitaminAStr != "" {
		queryParamMinVitaminA, err := runtime.ParseString[float32](queryParamMinVitaminAStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminA",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminA = &queryParamMinVitaminA
	}
	if queryParamMaxVitaminAStr := query.Get("maxVitaminA"); queryParamMaxVitaminAStr != "" {
		queryParamMaxVitaminA, err := runtime.ParseString[float32](queryParamMaxVitaminAStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminA",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminA = &queryParamMaxVitaminA
	}
	if queryParamMinVitaminCStr := query.Get("minVitaminC"); queryParamMinVitaminCStr != "" {
		queryParamMinVitaminC, err := runtime.ParseString[float32](queryParamMinVitaminCStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminC",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminC = &queryParamMinVitaminC
	}
	if queryParamMaxVitaminCStr := query.Get("maxVitaminC"); queryParamMaxVitaminCStr != "" {
		queryParamMaxVitaminC, err := runtime.ParseString[float32](queryParamMaxVitaminCStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminC",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminC = &queryParamMaxVitaminC
	}
	if queryParamMinVitaminDStr := query.Get("minVitaminD"); queryParamMinVitaminDStr != "" {
		queryParamMinVitaminD, err := runtime.ParseString[float32](queryParamMinVitaminDStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminD",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminD = &queryParamMinVitaminD
	}
	if queryParamMaxVitaminDStr := query.Get("maxVitaminD"); queryParamMaxVitaminDStr != "" {
		queryParamMaxVitaminD, err := runtime.ParseString[float32](queryParamMaxVitaminDStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminD",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminD = &queryParamMaxVitaminD
	}
	if queryParamMinVitaminEStr := query.Get("minVitaminE"); queryParamMinVitaminEStr != "" {
		queryParamMinVitaminE, err := runtime.ParseString[float32](queryParamMinVitaminEStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminE",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminE = &queryParamMinVitaminE
	}
	if queryParamMaxVitaminEStr := query.Get("maxVitaminE"); queryParamMaxVitaminEStr != "" {
		queryParamMaxVitaminE, err := runtime.ParseString[float32](queryParamMaxVitaminEStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminE",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminE = &queryParamMaxVitaminE
	}
	if queryParamMinVitaminKStr := query.Get("minVitaminK"); queryParamMinVitaminKStr != "" {
		queryParamMinVitaminK, err := runtime.ParseString[float32](queryParamMinVitaminKStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminK",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminK = &queryParamMinVitaminK
	}
	if queryParamMaxVitaminKStr := query.Get("maxVitaminK"); queryParamMaxVitaminKStr != "" {
		queryParamMaxVitaminK, err := runtime.ParseString[float32](queryParamMaxVitaminKStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminK",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminK = &queryParamMaxVitaminK
	}
	if queryParamMinVitaminB1Str := query.Get("minVitaminB1"); queryParamMinVitaminB1Str != "" {
		queryParamMinVitaminB1, err := runtime.ParseString[float32](queryParamMinVitaminB1Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminB1",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB1 = &queryParamMinVitaminB1
	}
	if queryParamMaxVitaminB1Str := query.Get("maxVitaminB1"); queryParamMaxVitaminB1Str != "" {
		queryParamMaxVitaminB1, err := runtime.ParseString[float32](queryParamMaxVitaminB1Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminB1",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB1 = &queryParamMaxVitaminB1
	}
	if queryParamMinVitaminB2Str := query.Get("minVitaminB2"); queryParamMinVitaminB2Str != "" {
		queryParamMinVitaminB2, err := runtime.ParseString[float32](queryParamMinVitaminB2Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminB2",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB2 = &queryParamMinVitaminB2
	}
	if queryParamMaxVitaminB2Str := query.Get("maxVitaminB2"); queryParamMaxVitaminB2Str != "" {
		queryParamMaxVitaminB2, err := runtime.ParseString[float32](queryParamMaxVitaminB2Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminB2",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB2 = &queryParamMaxVitaminB2
	}
	if queryParamMinVitaminB5Str := query.Get("minVitaminB5"); queryParamMinVitaminB5Str != "" {
		queryParamMinVitaminB5, err := runtime.ParseString[float32](queryParamMinVitaminB5Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminB5",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB5 = &queryParamMinVitaminB5
	}
	if queryParamMaxVitaminB5Str := query.Get("maxVitaminB5"); queryParamMaxVitaminB5Str != "" {
		queryParamMaxVitaminB5, err := runtime.ParseString[float32](queryParamMaxVitaminB5Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminB5",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB5 = &queryParamMaxVitaminB5
	}
	if queryParamMinVitaminB3Str := query.Get("minVitaminB3"); queryParamMinVitaminB3Str != "" {
		queryParamMinVitaminB3, err := runtime.ParseString[float32](queryParamMinVitaminB3Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminB3",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB3 = &queryParamMinVitaminB3
	}
	if queryParamMaxVitaminB3Str := query.Get("maxVitaminB3"); queryParamMaxVitaminB3Str != "" {
		queryParamMaxVitaminB3, err := runtime.ParseString[float32](queryParamMaxVitaminB3Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminB3",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB3 = &queryParamMaxVitaminB3
	}
	if queryParamMinVitaminB6Str := query.Get("minVitaminB6"); queryParamMinVitaminB6Str != "" {
		queryParamMinVitaminB6, err := runtime.ParseString[float32](queryParamMinVitaminB6Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminB6",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB6 = &queryParamMinVitaminB6
	}
	if queryParamMaxVitaminB6Str := query.Get("maxVitaminB6"); queryParamMaxVitaminB6Str != "" {
		queryParamMaxVitaminB6, err := runtime.ParseString[float32](queryParamMaxVitaminB6Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminB6",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB6 = &queryParamMaxVitaminB6
	}
	if queryParamMinVitaminB12Str := query.Get("minVitaminB12"); queryParamMinVitaminB12Str != "" {
		queryParamMinVitaminB12, err := runtime.ParseString[float32](queryParamMinVitaminB12Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minVitaminB12",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinVitaminB12 = &queryParamMinVitaminB12
	}
	if queryParamMaxVitaminB12Str := query.Get("maxVitaminB12"); queryParamMaxVitaminB12Str != "" {
		queryParamMaxVitaminB12, err := runtime.ParseString[float32](queryParamMaxVitaminB12Str)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxVitaminB12",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxVitaminB12 = &queryParamMaxVitaminB12
	}
	if queryParamMinFiberStr := query.Get("minFiber"); queryParamMinFiberStr != "" {
		queryParamMinFiber, err := runtime.ParseString[float32](queryParamMinFiberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minFiber",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFiber = &queryParamMinFiber
	}
	if queryParamMaxFiberStr := query.Get("maxFiber"); queryParamMaxFiberStr != "" {
		queryParamMaxFiber, err := runtime.ParseString[float32](queryParamMaxFiberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxFiber",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFiber = &queryParamMaxFiber
	}
	if queryParamMinFolateStr := query.Get("minFolate"); queryParamMinFolateStr != "" {
		queryParamMinFolate, err := runtime.ParseString[float32](queryParamMinFolateStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minFolate",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFolate = &queryParamMinFolate
	}
	if queryParamMaxFolateStr := query.Get("maxFolate"); queryParamMaxFolateStr != "" {
		queryParamMaxFolate, err := runtime.ParseString[float32](queryParamMaxFolateStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxFolate",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFolate = &queryParamMaxFolate
	}
	if queryParamMinFolicAcidStr := query.Get("minFolicAcid"); queryParamMinFolicAcidStr != "" {
		queryParamMinFolicAcid, err := runtime.ParseString[float32](queryParamMinFolicAcidStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minFolicAcid",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFolicAcid = &queryParamMinFolicAcid
	}
	if queryParamMaxFolicAcidStr := query.Get("maxFolicAcid"); queryParamMaxFolicAcidStr != "" {
		queryParamMaxFolicAcid, err := runtime.ParseString[float32](queryParamMaxFolicAcidStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxFolicAcid",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFolicAcid = &queryParamMaxFolicAcid
	}
	if queryParamMinIodineStr := query.Get("minIodine"); queryParamMinIodineStr != "" {
		queryParamMinIodine, err := runtime.ParseString[float32](queryParamMinIodineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minIodine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinIodine = &queryParamMinIodine
	}
	if queryParamMaxIodineStr := query.Get("maxIodine"); queryParamMaxIodineStr != "" {
		queryParamMaxIodine, err := runtime.ParseString[float32](queryParamMaxIodineStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxIodine",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxIodine = &queryParamMaxIodine
	}
	if queryParamMinIronStr := query.Get("minIron"); queryParamMinIronStr != "" {
		queryParamMinIron, err := runtime.ParseString[float32](queryParamMinIronStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minIron",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinIron = &queryParamMinIron
	}
	if queryParamMaxIronStr := query.Get("maxIron"); queryParamMaxIronStr != "" {
		queryParamMaxIron, err := runtime.ParseString[float32](queryParamMaxIronStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxIron",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxIron = &queryParamMaxIron
	}
	if queryParamMinMagnesiumStr := query.Get("minMagnesium"); queryParamMinMagnesiumStr != "" {
		queryParamMinMagnesium, err := runtime.ParseString[float32](queryParamMinMagnesiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minMagnesium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinMagnesium = &queryParamMinMagnesium
	}
	if queryParamMaxMagnesiumStr := query.Get("maxMagnesium"); queryParamMaxMagnesiumStr != "" {
		queryParamMaxMagnesium, err := runtime.ParseString[float32](queryParamMaxMagnesiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxMagnesium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxMagnesium = &queryParamMaxMagnesium
	}
	if queryParamMinManganeseStr := query.Get("minManganese"); queryParamMinManganeseStr != "" {
		queryParamMinManganese, err := runtime.ParseString[float32](queryParamMinManganeseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minManganese",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinManganese = &queryParamMinManganese
	}
	if queryParamMaxManganeseStr := query.Get("maxManganese"); queryParamMaxManganeseStr != "" {
		queryParamMaxManganese, err := runtime.ParseString[float32](queryParamMaxManganeseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxManganese",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxManganese = &queryParamMaxManganese
	}
	if queryParamMinPhosphorusStr := query.Get("minPhosphorus"); queryParamMinPhosphorusStr != "" {
		queryParamMinPhosphorus, err := runtime.ParseString[float32](queryParamMinPhosphorusStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minPhosphorus",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinPhosphorus = &queryParamMinPhosphorus
	}
	if queryParamMaxPhosphorusStr := query.Get("maxPhosphorus"); queryParamMaxPhosphorusStr != "" {
		queryParamMaxPhosphorus, err := runtime.ParseString[float32](queryParamMaxPhosphorusStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxPhosphorus",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxPhosphorus = &queryParamMaxPhosphorus
	}
	if queryParamMinPotassiumStr := query.Get("minPotassium"); queryParamMinPotassiumStr != "" {
		queryParamMinPotassium, err := runtime.ParseString[float32](queryParamMinPotassiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minPotassium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinPotassium = &queryParamMinPotassium
	}
	if queryParamMaxPotassiumStr := query.Get("maxPotassium"); queryParamMaxPotassiumStr != "" {
		queryParamMaxPotassium, err := runtime.ParseString[float32](queryParamMaxPotassiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxPotassium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxPotassium = &queryParamMaxPotassium
	}
	if queryParamMinSeleniumStr := query.Get("minSelenium"); queryParamMinSeleniumStr != "" {
		queryParamMinSelenium, err := runtime.ParseString[float32](queryParamMinSeleniumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minSelenium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinSelenium = &queryParamMinSelenium
	}
	if queryParamMaxSeleniumStr := query.Get("maxSelenium"); queryParamMaxSeleniumStr != "" {
		queryParamMaxSelenium, err := runtime.ParseString[float32](queryParamMaxSeleniumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxSelenium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxSelenium = &queryParamMaxSelenium
	}
	if queryParamMinSodiumStr := query.Get("minSodium"); queryParamMinSodiumStr != "" {
		queryParamMinSodium, err := runtime.ParseString[float32](queryParamMinSodiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minSodium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinSodium = &queryParamMinSodium
	}
	if queryParamMaxSodiumStr := query.Get("maxSodium"); queryParamMaxSodiumStr != "" {
		queryParamMaxSodium, err := runtime.ParseString[float32](queryParamMaxSodiumStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxSodium",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxSodium = &queryParamMaxSodium
	}
	if queryParamMinSugarStr := query.Get("minSugar"); queryParamMinSugarStr != "" {
		queryParamMinSugar, err := runtime.ParseString[float32](queryParamMinSugarStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minSugar",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinSugar = &queryParamMinSugar
	}
	if queryParamMaxSugarStr := query.Get("maxSugar"); queryParamMaxSugarStr != "" {
		queryParamMaxSugar, err := runtime.ParseString[float32](queryParamMaxSugarStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxSugar",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxSugar = &queryParamMaxSugar
	}
	if queryParamMinZincStr := query.Get("minZinc"); queryParamMinZincStr != "" {
		queryParamMinZinc, err := runtime.ParseString[float32](queryParamMinZincStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "minZinc",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinZinc = &queryParamMinZinc
	}
	if queryParamMaxZincStr := query.Get("maxZinc"); queryParamMaxZincStr != "" {
		queryParamMaxZinc, err := runtime.ParseString[float32](queryParamMaxZincStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "maxZinc",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxZinc = &queryParamMaxZinc
	}
	if queryParamOffsetStr := query.Get("offset"); queryParamOffsetStr != "" {
		queryParamOffset, err := runtime.ParseString[Offset](queryParamOffsetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "offset",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Offset = &queryParamOffset
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	if queryParamRandomStr := query.Get("random"); queryParamRandomStr != "" {
		queryParamRandom, err := runtime.ParseString[bool](queryParamRandomStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "random",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Random = &queryParamRandom
	}
	if queryParamLimitLicenseStr := query.Get("limitLicense"); queryParamLimitLicenseStr != "" {
		queryParamLimitLicense, err := runtime.ParseString[LimitLicense](queryParamLimitLicenseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRecipesByNutrients",
				Message:       err.Error(),
				ParamName:     "limitLicense",
				ParamLocation: "query",
			})
			return
		}
		queryParams.LimitLicense = &queryParamLimitLicense
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchRecipesByNutrients(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetRecipeInformation handles GET /recipes/{id}/information
func (a *HTTPAdapter) GetRecipeInformation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetRecipeInformationServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetRecipeInformationPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetRecipeInformation",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetRecipeInformationQuery{}
	query := r.URL.Query()
	if queryParamIncludeNutritionStr := query.Get("includeNutrition"); queryParamIncludeNutritionStr != "" {
		queryParamIncludeNutrition, err := runtime.ParseString[IncludeNutrition](queryParamIncludeNutritionStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetRecipeInformation",
				Message:       err.Error(),
				ParamName:     "includeNutrition",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IncludeNutrition = &queryParamIncludeNutrition
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetRecipeInformation(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetRecipeInformationBulk handles GET /recipes/informationBulk
func (a *HTTPAdapter) GetRecipeInformationBulk(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetRecipeInformationBulkServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GetRecipeInformationBulkQuery{}
	query := r.URL.Query()
	if queryParamIdsStr := query.Get("ids"); queryParamIdsStr != "" {
		queryParamIds := queryParamIdsStr
		queryParams.Ids = queryParamIds
	}
	if queryParamIncludeNutritionStr := query.Get("includeNutrition"); queryParamIncludeNutritionStr != "" {
		queryParamIncludeNutrition, err := runtime.ParseString[IncludeNutrition](queryParamIncludeNutritionStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetRecipeInformationBulk",
				Message:       err.Error(),
				ParamName:     "includeNutrition",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IncludeNutrition = &queryParamIncludeNutrition
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetRecipeInformationBulk(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetSimilarRecipes handles GET /recipes/{id}/similar
func (a *HTTPAdapter) GetSimilarRecipes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetSimilarRecipesServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetSimilarRecipesPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetSimilarRecipes",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetSimilarRecipesQuery{}
	query := r.URL.Query()
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetSimilarRecipes",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	if queryParamLimitLicenseStr := query.Get("limitLicense"); queryParamLimitLicenseStr != "" {
		queryParamLimitLicense, err := runtime.ParseString[LimitLicense](queryParamLimitLicenseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetSimilarRecipes",
				Message:       err.Error(),
				ParamName:     "limitLicense",
				ParamLocation: "query",
			})
			return
		}
		queryParams.LimitLicense = &queryParamLimitLicense
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetSimilarRecipes(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetRandomRecipes handles GET /recipes/random
func (a *HTTPAdapter) GetRandomRecipes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetRandomRecipesServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GetRandomRecipesQuery{}
	query := r.URL.Query()
	if queryParamLimitLicenseStr := query.Get("limitLicense"); queryParamLimitLicenseStr != "" {
		queryParamLimitLicense, err := runtime.ParseString[LimitLicense](queryParamLimitLicenseStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetRandomRecipes",
				Message:       err.Error(),
				ParamName:     "limitLicense",
				ParamLocation: "query",
			})
			return
		}
		queryParams.LimitLicense = &queryParamLimitLicense
	}
	if queryParamTagsStr := query.Get("tags"); queryParamTagsStr != "" {
		queryParamTags, err := runtime.ParseString[Tags](queryParamTagsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetRandomRecipes",
				Message:       err.Error(),
				ParamName:     "tags",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Tags = &queryParamTags
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetRandomRecipes",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetRandomRecipes(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AutocompleteRecipeSearch handles GET /recipes/autocomplete
func (a *HTTPAdapter) AutocompleteRecipeSearch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AutocompleteRecipeSearchServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &AutocompleteRecipeSearchQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery, err := runtime.ParseString[Query](queryParamQueryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AutocompleteRecipeSearch",
				Message:       err.Error(),
				ParamName:     "query",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Query = &queryParamQuery
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AutocompleteRecipeSearch",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.AutocompleteRecipeSearch(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetRecipeTasteByID handles GET /recipes/{id}/tasteWidget.json
func (a *HTTPAdapter) GetRecipeTasteByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetRecipeTasteByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetRecipeTasteByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetRecipeTasteByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetRecipeTasteByIDQuery{}
	query := r.URL.Query()
	if queryParamNormalizeStr := query.Get("normalize"); queryParamNormalizeStr != "" {
		queryParamNormalize, err := runtime.ParseString[GetRecipeTasteByIDQueryNormalize](queryParamNormalizeStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetRecipeTasteByID",
				Message:       err.Error(),
				ParamName:     "normalize",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Normalize = &queryParamNormalize
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetRecipeTasteByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// RecipeTasteByIDImage handles GET /recipes/{id}/tasteWidget.png
func (a *HTTPAdapter) RecipeTasteByIDImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &RecipeTasteByIDImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &RecipeTasteByIDImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "RecipeTasteByIDImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &RecipeTasteByIDImageQuery{}
	query := r.URL.Query()
	if queryParamNormalizeStr := query.Get("normalize"); queryParamNormalizeStr != "" {
		queryParamNormalize, err := runtime.ParseString[bool](queryParamNormalizeStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeTasteByIDImage",
				Message:       err.Error(),
				ParamName:     "normalize",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Normalize = &queryParamNormalize
	}
	if queryParamRgbStr := query.Get("rgb"); queryParamRgbStr != "" {
		queryParamRgb, err := runtime.ParseString[Rgb](queryParamRgbStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeTasteByIDImage",
				Message:       err.Error(),
				ParamName:     "rgb",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Rgb = &queryParamRgb
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.RecipeTasteByIDImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetRecipeEquipmentByID handles GET /recipes/{id}/equipmentWidget.json
func (a *HTTPAdapter) GetRecipeEquipmentByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetRecipeEquipmentByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetRecipeEquipmentByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetRecipeEquipmentByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetRecipeEquipmentByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// EquipmentByIDImage handles GET /recipes/{id}/equipmentWidget.png
func (a *HTTPAdapter) EquipmentByIDImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &EquipmentByIDImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &EquipmentByIDImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "EquipmentByIDImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.EquipmentByIDImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetRecipePriceBreakdownByID handles GET /recipes/{id}/priceBreakdownWidget.json
func (a *HTTPAdapter) GetRecipePriceBreakdownByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetRecipePriceBreakdownByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetRecipePriceBreakdownByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetRecipePriceBreakdownByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetRecipePriceBreakdownByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// PriceBreakdownByIDImage handles GET /recipes/{id}/priceBreakdownWidget.png
func (a *HTTPAdapter) PriceBreakdownByIDImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &PriceBreakdownByIDImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &PriceBreakdownByIDImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "PriceBreakdownByIDImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.PriceBreakdownByIDImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetRecipeIngredientsByID handles GET /recipes/{id}/ingredientWidget.json
func (a *HTTPAdapter) GetRecipeIngredientsByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetRecipeIngredientsByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetRecipeIngredientsByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetRecipeIngredientsByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetRecipeIngredientsByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// IngredientsByIDImage handles GET /recipes/{id}/ingredientWidget.png
func (a *HTTPAdapter) IngredientsByIDImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &IngredientsByIDImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &IngredientsByIDImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "IngredientsByIDImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &IngredientsByIDImageQuery{}
	query := r.URL.Query()
	if queryParamMeasureStr := query.Get("measure"); queryParamMeasureStr != "" {

		queryParamMeasure := IngredientsByIDImageQueryMeasure(queryParamMeasureStr)
		queryParams.Measure = &queryParamMeasure
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.IngredientsByIDImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetRecipeNutritionWidgetByID handles GET /recipes/{id}/nutritionWidget.json
func (a *HTTPAdapter) GetRecipeNutritionWidgetByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetRecipeNutritionWidgetByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetRecipeNutritionWidgetByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetRecipeNutritionWidgetByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetRecipeNutritionWidgetByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// RecipeNutritionByIDImage handles GET /recipes/{id}/nutritionWidget.png
func (a *HTTPAdapter) RecipeNutritionByIDImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &RecipeNutritionByIDImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &RecipeNutritionByIDImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "RecipeNutritionByIDImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.RecipeNutritionByIDImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// RecipeNutritionLabelWidget handles GET /recipes/{id}/nutritionLabel
func (a *HTTPAdapter) RecipeNutritionLabelWidget(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &RecipeNutritionLabelWidgetServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &RecipeNutritionLabelWidgetPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "RecipeNutritionLabelWidget",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &RecipeNutritionLabelWidgetQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	if queryParamShowOptionalNutrientsStr := query.Get("showOptionalNutrients"); queryParamShowOptionalNutrientsStr != "" {
		queryParamShowOptionalNutrients, err := runtime.ParseString[bool](queryParamShowOptionalNutrientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showOptionalNutrients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowOptionalNutrients = &queryParamShowOptionalNutrients
	}
	if queryParamShowZeroValuesStr := query.Get("showZeroValues"); queryParamShowZeroValuesStr != "" {
		queryParamShowZeroValues, err := runtime.ParseString[bool](queryParamShowZeroValuesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showZeroValues",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowZeroValues = &queryParamShowZeroValues
	}
	if queryParamShowIngredientsStr := query.Get("showIngredients"); queryParamShowIngredientsStr != "" {
		queryParamShowIngredients, err := runtime.ParseString[bool](queryParamShowIngredientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showIngredients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowIngredients = &queryParamShowIngredients
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.RecipeNutritionLabelWidget(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// RecipeNutritionLabelImage handles GET /recipes/{id}/nutritionLabel.png
func (a *HTTPAdapter) RecipeNutritionLabelImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &RecipeNutritionLabelImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &RecipeNutritionLabelImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "RecipeNutritionLabelImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &RecipeNutritionLabelImageQuery{}
	query := r.URL.Query()
	if queryParamShowOptionalNutrientsStr := query.Get("showOptionalNutrients"); queryParamShowOptionalNutrientsStr != "" {
		queryParamShowOptionalNutrients, err := runtime.ParseString[bool](queryParamShowOptionalNutrientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showOptionalNutrients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowOptionalNutrients = &queryParamShowOptionalNutrients
	}
	if queryParamShowZeroValuesStr := query.Get("showZeroValues"); queryParamShowZeroValuesStr != "" {
		queryParamShowZeroValues, err := runtime.ParseString[bool](queryParamShowZeroValuesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showZeroValues",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowZeroValues = &queryParamShowZeroValues
	}
	if queryParamShowIngredientsStr := query.Get("showIngredients"); queryParamShowIngredientsStr != "" {
		queryParamShowIngredients, err := runtime.ParseString[bool](queryParamShowIngredientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "RecipeNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showIngredients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowIngredients = &queryParamShowIngredients
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.RecipeNutritionLabelImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetAnalyzedRecipeInstructions handles GET /recipes/{id}/analyzedInstructions
func (a *HTTPAdapter) GetAnalyzedRecipeInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetAnalyzedRecipeInstructionsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetAnalyzedRecipeInstructionsPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetAnalyzedRecipeInstructions",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetAnalyzedRecipeInstructionsQuery{}
	query := r.URL.Query()
	if queryParamStepBreakdownStr := query.Get("stepBreakdown"); queryParamStepBreakdownStr != "" {
		queryParamStepBreakdown, err := runtime.ParseString[bool](queryParamStepBreakdownStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetAnalyzedRecipeInstructions",
				Message:       err.Error(),
				ParamName:     "stepBreakdown",
				ParamLocation: "query",
			})
			return
		}
		queryParams.StepBreakdown = &queryParamStepBreakdown
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetAnalyzedRecipeInstructions(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ExtractRecipeFromWebsite handles GET /recipes/extract
func (a *HTTPAdapter) ExtractRecipeFromWebsite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ExtractRecipeFromWebsiteServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ExtractRecipeFromWebsiteQuery{}
	query := r.URL.Query()
	if queryParamURLStr := query.Get("url"); queryParamURLStr != "" {
		queryParamURL := queryParamURLStr
		queryParams.URL = queryParamURL
	}
	if queryParamForceExtractionStr := query.Get("forceExtraction"); queryParamForceExtractionStr != "" {
		queryParamForceExtraction, err := runtime.ParseString[bool](queryParamForceExtractionStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ExtractRecipeFromWebsite",
				Message:       err.Error(),
				ParamName:     "forceExtraction",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ForceExtraction = &queryParamForceExtraction
	}
	if queryParamAnalyzeStr := query.Get("analyze"); queryParamAnalyzeStr != "" {
		queryParamAnalyze, err := runtime.ParseString[bool](queryParamAnalyzeStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ExtractRecipeFromWebsite",
				Message:       err.Error(),
				ParamName:     "analyze",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Analyze = &queryParamAnalyze
	}
	if queryParamIncludeNutritionStr := query.Get("includeNutrition"); queryParamIncludeNutritionStr != "" {
		queryParamIncludeNutrition, err := runtime.ParseString[IncludeNutrition](queryParamIncludeNutritionStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ExtractRecipeFromWebsite",
				Message:       err.Error(),
				ParamName:     "includeNutrition",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IncludeNutrition = &queryParamIncludeNutrition
	}
	if queryParamIncludeTasteStr := query.Get("includeTaste"); queryParamIncludeTasteStr != "" {
		queryParamIncludeTaste, err := runtime.ParseString[IncludeTaste](queryParamIncludeTasteStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ExtractRecipeFromWebsite",
				Message:       err.Error(),
				ParamName:     "includeTaste",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IncludeTaste = &queryParamIncludeTaste
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ExtractRecipeFromWebsite(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// VisualizeRecipeIngredientsByID handles GET /recipes/{id}/ingredientWidget
func (a *HTTPAdapter) VisualizeRecipeIngredientsByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeRecipeIngredientsByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &VisualizeRecipeIngredientsByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "VisualizeRecipeIngredientsByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &VisualizeRecipeIngredientsByIDQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeIngredientsByID",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	if queryParamMeasureStr := query.Get("measure"); queryParamMeasureStr != "" {

		queryParamMeasure := VisualizeRecipeIngredientsByIDQueryMeasure(queryParamMeasureStr)
		queryParams.Measure = &queryParamMeasure
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.VisualizeRecipeIngredientsByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// VisualizeRecipeTasteByID handles GET /recipes/{id}/tasteWidget
func (a *HTTPAdapter) VisualizeRecipeTasteByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeRecipeTasteByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &VisualizeRecipeTasteByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "VisualizeRecipeTasteByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &VisualizeRecipeTasteByIDQuery{}
	query := r.URL.Query()
	if queryParamNormalizeStr := query.Get("normalize"); queryParamNormalizeStr != "" {
		queryParamNormalize, err := runtime.ParseString[VisualizeRecipeTasteByIDQueryNormalize](queryParamNormalizeStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeTasteByID",
				Message:       err.Error(),
				ParamName:     "normalize",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Normalize = &queryParamNormalize
	}
	if queryParamRgbStr := query.Get("rgb"); queryParamRgbStr != "" {
		queryParamRgb, err := runtime.ParseString[Rgb](queryParamRgbStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeTasteByID",
				Message:       err.Error(),
				ParamName:     "rgb",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Rgb = &queryParamRgb
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.VisualizeRecipeTasteByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// VisualizeRecipeEquipmentByID handles GET /recipes/{id}/equipmentWidget
func (a *HTTPAdapter) VisualizeRecipeEquipmentByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeRecipeEquipmentByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &VisualizeRecipeEquipmentByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "VisualizeRecipeEquipmentByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &VisualizeRecipeEquipmentByIDQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeEquipmentByID",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.VisualizeRecipeEquipmentByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// VisualizeRecipePriceBreakdownByID handles GET /recipes/{id}/priceBreakdownWidget
func (a *HTTPAdapter) VisualizeRecipePriceBreakdownByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeRecipePriceBreakdownByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &VisualizeRecipePriceBreakdownByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "VisualizeRecipePriceBreakdownByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &VisualizeRecipePriceBreakdownByIDQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipePriceBreakdownByID",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.VisualizeRecipePriceBreakdownByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// VisualizeRecipeTaste handles POST /recipes/visualizeTaste
func (a *HTTPAdapter) VisualizeRecipeTaste(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeRecipeTasteServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &VisualizeRecipeTasteQuery{}
	query := r.URL.Query()
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage, err := runtime.ParseString[Language](queryParamLanguageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeTaste",
				Message:       err.Error(),
				ParamName:     "language",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Language = &queryParamLanguage
	}
	if queryParamNormalizeStr := query.Get("normalize"); queryParamNormalizeStr != "" {
		queryParamNormalize, err := runtime.ParseString[bool](queryParamNormalizeStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeTaste",
				Message:       err.Error(),
				ParamName:     "normalize",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Normalize = &queryParamNormalize
	}
	if queryParamRgbStr := query.Get("rgb"); queryParamRgbStr != "" {
		queryParamRgb, err := runtime.ParseString[Rgb](queryParamRgbStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeTaste",
				Message:       err.Error(),
				ParamName:     "rgb",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Rgb = &queryParamRgb
	}
	opts.Query = queryParams

	// Parse header parameters
	headerParams := &VisualizeRecipeTasteHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeTaste",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	if headerValues := headers[http.CanonicalHeaderKey("Accept")]; len(headerValues) > 0 {
		headerParamAccept, err := runtime.ParseString[Accept](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeTaste",
				Message:       err.Error(),
				ParamName:     "Accept",
				ParamLocation: "header",
			})
			return
		}
		headerParams.Accept = &headerParamAccept
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body VisualizeRecipeTasteBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeRecipeTaste",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeRecipeTaste",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeRecipeTaste",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.VisualizeRecipeTaste(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// VisualizeRecipeNutrition handles POST /recipes/visualizeNutrition
func (a *HTTPAdapter) VisualizeRecipeNutrition(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeRecipeNutritionServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &VisualizeRecipeNutritionQuery{}
	query := r.URL.Query()
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage, err := runtime.ParseString[Language](queryParamLanguageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeNutrition",
				Message:       err.Error(),
				ParamName:     "language",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Language = &queryParamLanguage
	}
	opts.Query = queryParams

	// Parse header parameters
	headerParams := &VisualizeRecipeNutritionHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeNutrition",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	if headerValues := headers[http.CanonicalHeaderKey("Accept")]; len(headerValues) > 0 {
		headerParamAccept, err := runtime.ParseString[Accept](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeNutrition",
				Message:       err.Error(),
				ParamName:     "Accept",
				ParamLocation: "header",
			})
			return
		}
		headerParams.Accept = &headerParamAccept
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body VisualizeRecipeNutritionBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeRecipeNutrition",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeRecipeNutrition",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeRecipeNutrition",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.VisualizeRecipeNutrition(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// VisualizePriceBreakdown handles POST /recipes/visualizePriceEstimator
func (a *HTTPAdapter) VisualizePriceBreakdown(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizePriceBreakdownServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &VisualizePriceBreakdownQuery{}
	query := r.URL.Query()
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage, err := runtime.ParseString[Language](queryParamLanguageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizePriceBreakdown",
				Message:       err.Error(),
				ParamName:     "language",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Language = &queryParamLanguage
	}
	opts.Query = queryParams

	// Parse header parameters
	headerParams := &VisualizePriceBreakdownHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizePriceBreakdown",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	if headerValues := headers[http.CanonicalHeaderKey("Accept")]; len(headerValues) > 0 {
		headerParamAccept, err := runtime.ParseString[Accept](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizePriceBreakdown",
				Message:       err.Error(),
				ParamName:     "Accept",
				ParamLocation: "header",
			})
			return
		}
		headerParams.Accept = &headerParamAccept
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body VisualizePriceBreakdownBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizePriceBreakdown",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizePriceBreakdown",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizePriceBreakdown",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.VisualizePriceBreakdown(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// VisualizeEquipment handles POST /recipes/visualizeEquipment
func (a *HTTPAdapter) VisualizeEquipment(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeEquipmentServiceRequestOptions{}
	opts.RawRequest = r

	// Parse header parameters
	headerParams := &VisualizeEquipmentHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeEquipment",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	if headerValues := headers[http.CanonicalHeaderKey("Accept")]; len(headerValues) > 0 {
		headerParamAccept, err := runtime.ParseString[Accept](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeEquipment",
				Message:       err.Error(),
				ParamName:     "Accept",
				ParamLocation: "header",
			})
			return
		}
		headerParams.Accept = &headerParamAccept
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body VisualizeEquipmentBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeEquipment",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeEquipment",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeEquipment",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.VisualizeEquipment(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// AnalyzeRecipe handles POST /recipes/analyze
func (a *HTTPAdapter) AnalyzeRecipe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AnalyzeRecipeServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &AnalyzeRecipeQuery{}
	query := r.URL.Query()
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage := queryParamLanguageStr
		queryParams.Language = &queryParamLanguage
	}
	if queryParamIncludeNutritionStr := query.Get("includeNutrition"); queryParamIncludeNutritionStr != "" {
		queryParamIncludeNutrition, err := runtime.ParseString[bool](queryParamIncludeNutritionStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AnalyzeRecipe",
				Message:       err.Error(),
				ParamName:     "includeNutrition",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IncludeNutrition = &queryParamIncludeNutrition
	}
	if queryParamIncludeTasteStr := query.Get("includeTaste"); queryParamIncludeTasteStr != "" {
		queryParamIncludeTaste, err := runtime.ParseString[bool](queryParamIncludeTasteStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AnalyzeRecipe",
				Message:       err.Error(),
				ParamName:     "includeTaste",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IncludeTaste = &queryParamIncludeTaste
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.AnalyzeRecipe(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SummarizeRecipe handles GET /recipes/{id}/summary
func (a *HTTPAdapter) SummarizeRecipe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SummarizeRecipeServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &SummarizeRecipePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "SummarizeRecipe",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.SummarizeRecipe(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// CreateRecipeCardGet handles GET /recipes/{id}/card
func (a *HTTPAdapter) CreateRecipeCardGet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &CreateRecipeCardGetServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &CreateRecipeCardGetPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "CreateRecipeCardGet",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &CreateRecipeCardGetQuery{}
	query := r.URL.Query()
	if queryParamMaskStr := query.Get("mask"); queryParamMaskStr != "" {
		queryParamMask := queryParamMaskStr
		queryParams.Mask = &queryParamMask
	}
	if queryParamBackgroundImageStr := query.Get("backgroundImage"); queryParamBackgroundImageStr != "" {
		queryParamBackgroundImage := queryParamBackgroundImageStr
		queryParams.BackgroundImage = &queryParamBackgroundImage
	}
	if queryParamBackgroundColorStr := query.Get("backgroundColor"); queryParamBackgroundColorStr != "" {
		queryParamBackgroundColor := queryParamBackgroundColorStr
		queryParams.BackgroundColor = &queryParamBackgroundColor
	}
	if queryParamFontColorStr := query.Get("fontColor"); queryParamFontColorStr != "" {
		queryParamFontColor := queryParamFontColorStr
		queryParams.FontColor = &queryParamFontColor
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.CreateRecipeCardGet(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// CreateRecipeCard handles POST /recipes/visualizeRecipe
func (a *HTTPAdapter) CreateRecipeCard(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &CreateRecipeCardServiceRequestOptions{}
	opts.RawRequest = r

	// Parse header parameters
	headerParams := &CreateRecipeCardHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "CreateRecipeCard",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "CreateRecipeCard",
			Message:     err.Error(),
		})
		return
	}
	var body CreateRecipeCardBody
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.CreateRecipeCard(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AnalyzeRecipeInstructions handles POST /recipes/analyzeInstructions
func (a *HTTPAdapter) AnalyzeRecipeInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AnalyzeRecipeInstructionsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse header parameters
	headerParams := &AnalyzeRecipeInstructionsHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AnalyzeRecipeInstructions",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body AnalyzeRecipeInstructionsBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "AnalyzeRecipeInstructions",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "AnalyzeRecipeInstructions",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "AnalyzeRecipeInstructions",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.AnalyzeRecipeInstructions(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ClassifyCuisine handles POST /recipes/cuisine
func (a *HTTPAdapter) ClassifyCuisine(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ClassifyCuisineServiceRequestOptions{}
	opts.RawRequest = r

	// Parse header parameters
	headerParams := &ClassifyCuisineHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ClassifyCuisine",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body ClassifyCuisineBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ClassifyCuisine",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ClassifyCuisine",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ClassifyCuisine",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.ClassifyCuisine(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AnalyzeARecipeSearchQuery handles GET /recipes/queries/analyze
func (a *HTTPAdapter) AnalyzeARecipeSearchQuery(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AnalyzeARecipeSearchQueryServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &AnalyzeARecipeSearchQueryQuery{}
	query := r.URL.Query()
	if queryParamQStr := query.Get("q"); queryParamQStr != "" {
		queryParamQ := queryParamQStr
		queryParams.Q = queryParamQ
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.AnalyzeARecipeSearchQuery(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ConvertAmounts handles GET /recipes/convert
func (a *HTTPAdapter) ConvertAmounts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ConvertAmountsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ConvertAmountsQuery{}
	query := r.URL.Query()
	if queryParamIngredientNameStr := query.Get("ingredientName"); queryParamIngredientNameStr != "" {
		queryParamIngredientName := queryParamIngredientNameStr
		queryParams.IngredientName = queryParamIngredientName
	}
	if queryParamSourceAmountStr := query.Get("sourceAmount"); queryParamSourceAmountStr != "" {
		queryParamSourceAmount, err := runtime.ParseString[float32](queryParamSourceAmountStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ConvertAmounts",
				Message:       err.Error(),
				ParamName:     "sourceAmount",
				ParamLocation: "query",
			})
			return
		}
		queryParams.SourceAmount = queryParamSourceAmount
	}
	if queryParamSourceUnitStr := query.Get("sourceUnit"); queryParamSourceUnitStr != "" {
		queryParamSourceUnit := queryParamSourceUnitStr
		queryParams.SourceUnit = queryParamSourceUnit
	}
	if queryParamTargetUnitStr := query.Get("targetUnit"); queryParamTargetUnitStr != "" {
		queryParamTargetUnit := queryParamTargetUnitStr
		queryParams.TargetUnit = queryParamTargetUnit
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ConvertAmounts(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ParseIngredients handles POST /recipes/parseIngredients
func (a *HTTPAdapter) ParseIngredients(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ParseIngredientsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ParseIngredientsQuery{}
	query := r.URL.Query()
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage, err := runtime.ParseString[Language](queryParamLanguageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ParseIngredients",
				Message:       err.Error(),
				ParamName:     "language",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Language = &queryParamLanguage
	}
	opts.Query = queryParams

	// Parse header parameters
	headerParams := &ParseIngredientsHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ParseIngredients",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body ParseIngredientsBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ParseIngredients",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ParseIngredients",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ParseIngredients",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.ParseIngredients(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// VisualizeRecipeNutritionByID handles GET /recipes/{id}/nutritionWidget
func (a *HTTPAdapter) VisualizeRecipeNutritionByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeRecipeNutritionByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &VisualizeRecipeNutritionByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "VisualizeRecipeNutritionByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &VisualizeRecipeNutritionByIDQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeNutritionByID",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	opts.Query = queryParams

	// Parse header parameters
	headerParams := &VisualizeRecipeNutritionByIDHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Accept")]; len(headerValues) > 0 {
		headerParamAccept, err := runtime.ParseString[Accept](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeRecipeNutritionByID",
				Message:       err.Error(),
				ParamName:     "Accept",
				ParamLocation: "header",
			})
			return
		}
		headerParams.Accept = &headerParamAccept
	}
	opts.Header = headerParams

	// Call business logic
	resp, err := a.svc.VisualizeRecipeNutritionByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// VisualizeIngredients handles POST /recipes/visualizeIngredients
func (a *HTTPAdapter) VisualizeIngredients(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeIngredientsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &VisualizeIngredientsQuery{}
	query := r.URL.Query()
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage, err := runtime.ParseString[Language](queryParamLanguageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeIngredients",
				Message:       err.Error(),
				ParamName:     "language",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Language = &queryParamLanguage
	}
	opts.Query = queryParams

	// Parse header parameters
	headerParams := &VisualizeIngredientsHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeIngredients",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	if headerValues := headers[http.CanonicalHeaderKey("Accept")]; len(headerValues) > 0 {
		headerParamAccept, err := runtime.ParseString[Accept](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeIngredients",
				Message:       err.Error(),
				ParamName:     "Accept",
				ParamLocation: "header",
			})
			return
		}
		headerParams.Accept = &headerParamAccept
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body VisualizeIngredientsBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeIngredients",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeIngredients",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "VisualizeIngredients",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.VisualizeIngredients(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// GuessNutritionByDishName handles GET /recipes/guessNutrition
func (a *HTTPAdapter) GuessNutritionByDishName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GuessNutritionByDishNameServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GuessNutritionByDishNameQuery{}
	query := r.URL.Query()
	if queryParamTitleStr := query.Get("title"); queryParamTitleStr != "" {
		queryParamTitle := queryParamTitleStr
		queryParams.Title = queryParamTitle
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GuessNutritionByDishName(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetIngredientInformation handles GET /food/ingredients/{id}/information
func (a *HTTPAdapter) GetIngredientInformation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetIngredientInformationServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetIngredientInformationPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetIngredientInformation",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetIngredientInformationQuery{}
	query := r.URL.Query()
	if queryParamAmountStr := query.Get("amount"); queryParamAmountStr != "" {
		queryParamAmount, err := runtime.ParseString[float32](queryParamAmountStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetIngredientInformation",
				Message:       err.Error(),
				ParamName:     "amount",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Amount = &queryParamAmount
	}
	if queryParamUnitStr := query.Get("unit"); queryParamUnitStr != "" {
		queryParamUnit := queryParamUnitStr
		queryParams.Unit = &queryParamUnit
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetIngredientInformation(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ComputeIngredientAmount handles GET /food/ingredients/{id}/amount
func (a *HTTPAdapter) ComputeIngredientAmount(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ComputeIngredientAmountServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &ComputeIngredientAmountPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "ComputeIngredientAmount",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &ComputeIngredientAmountQuery{}
	query := r.URL.Query()
	if queryParamNutrientStr := query.Get("nutrient"); queryParamNutrientStr != "" {
		queryParamNutrient := queryParamNutrientStr
		queryParams.Nutrient = queryParamNutrient
	}
	if queryParamTargetStr := query.Get("target"); queryParamTargetStr != "" {
		queryParamTarget, err := runtime.ParseString[float32](queryParamTargetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ComputeIngredientAmount",
				Message:       err.Error(),
				ParamName:     "target",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Target = queryParamTarget
	}
	if queryParamUnitStr := query.Get("unit"); queryParamUnitStr != "" {
		queryParamUnit := queryParamUnitStr
		queryParams.Unit = &queryParamUnit
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ComputeIngredientAmount(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ComputeGlycemicLoad handles POST /food/ingredients/glycemicLoad
func (a *HTTPAdapter) ComputeGlycemicLoad(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ComputeGlycemicLoadServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ComputeGlycemicLoadQuery{}
	query := r.URL.Query()
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage, err := runtime.ParseString[Language](queryParamLanguageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ComputeGlycemicLoad",
				Message:       err.Error(),
				ParamName:     "language",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Language = &queryParamLanguage
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()
	var body ComputeGlycemicLoadBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ComputeGlycemicLoad",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.ComputeGlycemicLoad(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AutocompleteIngredientSearch handles GET /food/ingredients/autocomplete
func (a *HTTPAdapter) AutocompleteIngredientSearch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AutocompleteIngredientSearchServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &AutocompleteIngredientSearchQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery, err := runtime.ParseString[Query](queryParamQueryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AutocompleteIngredientSearch",
				Message:       err.Error(),
				ParamName:     "query",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Query = &queryParamQuery
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AutocompleteIngredientSearch",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	if queryParamMetaInformationStr := query.Get("metaInformation"); queryParamMetaInformationStr != "" {
		queryParamMetaInformation, err := runtime.ParseString[bool](queryParamMetaInformationStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AutocompleteIngredientSearch",
				Message:       err.Error(),
				ParamName:     "metaInformation",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MetaInformation = &queryParamMetaInformation
	}
	if queryParamIntolerancesStr := query.Get("intolerances"); queryParamIntolerancesStr != "" {
		queryParamIntolerances := queryParamIntolerancesStr
		queryParams.Intolerances = &queryParamIntolerances
	}
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage, err := runtime.ParseString[Language](queryParamLanguageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AutocompleteIngredientSearch",
				Message:       err.Error(),
				ParamName:     "language",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Language = &queryParamLanguage
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.AutocompleteIngredientSearch(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// IngredientSearch handles GET /food/ingredients/search
func (a *HTTPAdapter) IngredientSearch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &IngredientSearchServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &IngredientSearchQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery, err := runtime.ParseString[Query](queryParamQueryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "query",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Query = &queryParamQuery
	}
	if queryParamAddChildrenStr := query.Get("addChildren"); queryParamAddChildrenStr != "" {
		queryParamAddChildren, err := runtime.ParseString[bool](queryParamAddChildrenStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "addChildren",
				ParamLocation: "query",
			})
			return
		}
		queryParams.AddChildren = &queryParamAddChildren
	}
	if queryParamMinProteinPercentStr := query.Get("minProteinPercent"); queryParamMinProteinPercentStr != "" {
		queryParamMinProteinPercent, err := runtime.ParseString[float32](queryParamMinProteinPercentStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "minProteinPercent",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinProteinPercent = &queryParamMinProteinPercent
	}
	if queryParamMaxProteinPercentStr := query.Get("maxProteinPercent"); queryParamMaxProteinPercentStr != "" {
		queryParamMaxProteinPercent, err := runtime.ParseString[float32](queryParamMaxProteinPercentStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "maxProteinPercent",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxProteinPercent = &queryParamMaxProteinPercent
	}
	if queryParamMinFatPercentStr := query.Get("minFatPercent"); queryParamMinFatPercentStr != "" {
		queryParamMinFatPercent, err := runtime.ParseString[float32](queryParamMinFatPercentStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "minFatPercent",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFatPercent = &queryParamMinFatPercent
	}
	if queryParamMaxFatPercentStr := query.Get("maxFatPercent"); queryParamMaxFatPercentStr != "" {
		queryParamMaxFatPercent, err := runtime.ParseString[float32](queryParamMaxFatPercentStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "maxFatPercent",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFatPercent = &queryParamMaxFatPercent
	}
	if queryParamMinCarbsPercentStr := query.Get("minCarbsPercent"); queryParamMinCarbsPercentStr != "" {
		queryParamMinCarbsPercent, err := runtime.ParseString[float32](queryParamMinCarbsPercentStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "minCarbsPercent",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCarbsPercent = &queryParamMinCarbsPercent
	}
	if queryParamMaxCarbsPercentStr := query.Get("maxCarbsPercent"); queryParamMaxCarbsPercentStr != "" {
		queryParamMaxCarbsPercent, err := runtime.ParseString[float32](queryParamMaxCarbsPercentStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "maxCarbsPercent",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCarbsPercent = &queryParamMaxCarbsPercent
	}
	if queryParamMetaInformationStr := query.Get("metaInformation"); queryParamMetaInformationStr != "" {
		queryParamMetaInformation, err := runtime.ParseString[bool](queryParamMetaInformationStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "metaInformation",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MetaInformation = &queryParamMetaInformation
	}
	if queryParamIntolerancesStr := query.Get("intolerances"); queryParamIntolerancesStr != "" {
		queryParamIntolerances := queryParamIntolerancesStr
		queryParams.Intolerances = &queryParamIntolerances
	}
	if queryParamSortStr := query.Get("sort"); queryParamSortStr != "" {
		queryParamSort := queryParamSortStr
		queryParams.Sort = &queryParamSort
	}
	if queryParamSortDirectionStr := query.Get("sortDirection"); queryParamSortDirectionStr != "" {
		queryParamSortDirection := queryParamSortDirectionStr
		queryParams.SortDirection = &queryParamSortDirection
	}
	if queryParamOffsetStr := query.Get("offset"); queryParamOffsetStr != "" {
		queryParamOffset, err := runtime.ParseString[Offset](queryParamOffsetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "offset",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Offset = &queryParamOffset
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	if queryParamLanguageStr := query.Get("language"); queryParamLanguageStr != "" {
		queryParamLanguage, err := runtime.ParseString[Language](queryParamLanguageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "IngredientSearch",
				Message:       err.Error(),
				ParamName:     "language",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Language = &queryParamLanguage
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.IngredientSearch(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetIngredientSubstitutes handles GET /food/ingredients/substitutes
func (a *HTTPAdapter) GetIngredientSubstitutes(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetIngredientSubstitutesServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GetIngredientSubstitutesQuery{}
	query := r.URL.Query()
	if queryParamIngredientNameStr := query.Get("ingredientName"); queryParamIngredientNameStr != "" {
		queryParamIngredientName := queryParamIngredientNameStr
		queryParams.IngredientName = queryParamIngredientName
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetIngredientSubstitutes(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetIngredientSubstitutesByID handles GET /food/ingredients/{id}/substitutes
func (a *HTTPAdapter) GetIngredientSubstitutesByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetIngredientSubstitutesByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetIngredientSubstitutesByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetIngredientSubstitutesByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetIngredientSubstitutesByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchGroceryProducts handles GET /food/products/search
func (a *HTTPAdapter) SearchGroceryProducts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchGroceryProductsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchGroceryProductsQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery, err := runtime.ParseString[Query](queryParamQueryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "query",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Query = &queryParamQuery
	}
	if queryParamMinCaloriesStr := query.Get("minCalories"); queryParamMinCaloriesStr != "" {
		queryParamMinCalories, err := runtime.ParseString[float32](queryParamMinCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "minCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCalories = &queryParamMinCalories
	}
	if queryParamMaxCaloriesStr := query.Get("maxCalories"); queryParamMaxCaloriesStr != "" {
		queryParamMaxCalories, err := runtime.ParseString[float32](queryParamMaxCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "maxCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCalories = &queryParamMaxCalories
	}
	if queryParamMinCarbsStr := query.Get("minCarbs"); queryParamMinCarbsStr != "" {
		queryParamMinCarbs, err := runtime.ParseString[float32](queryParamMinCarbsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "minCarbs",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCarbs = &queryParamMinCarbs
	}
	if queryParamMaxCarbsStr := query.Get("maxCarbs"); queryParamMaxCarbsStr != "" {
		queryParamMaxCarbs, err := runtime.ParseString[float32](queryParamMaxCarbsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "maxCarbs",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCarbs = &queryParamMaxCarbs
	}
	if queryParamMinProteinStr := query.Get("minProtein"); queryParamMinProteinStr != "" {
		queryParamMinProtein, err := runtime.ParseString[float32](queryParamMinProteinStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "minProtein",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinProtein = &queryParamMinProtein
	}
	if queryParamMaxProteinStr := query.Get("maxProtein"); queryParamMaxProteinStr != "" {
		queryParamMaxProtein, err := runtime.ParseString[float32](queryParamMaxProteinStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "maxProtein",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxProtein = &queryParamMaxProtein
	}
	if queryParamMinFatStr := query.Get("minFat"); queryParamMinFatStr != "" {
		queryParamMinFat, err := runtime.ParseString[float32](queryParamMinFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "minFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFat = &queryParamMinFat
	}
	if queryParamMaxFatStr := query.Get("maxFat"); queryParamMaxFatStr != "" {
		queryParamMaxFat, err := runtime.ParseString[float32](queryParamMaxFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "maxFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFat = &queryParamMaxFat
	}
	if queryParamAddProductInformationStr := query.Get("addProductInformation"); queryParamAddProductInformationStr != "" {
		queryParamAddProductInformation, err := runtime.ParseString[SearchGroceryProductsQueryAddProductInformation](queryParamAddProductInformationStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "addProductInformation",
				ParamLocation: "query",
			})
			return
		}
		queryParams.AddProductInformation = &queryParamAddProductInformation
	}
	if queryParamOffsetStr := query.Get("offset"); queryParamOffsetStr != "" {
		queryParamOffset, err := runtime.ParseString[Offset](queryParamOffsetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "offset",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Offset = &queryParamOffset
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchGroceryProducts",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchGroceryProducts(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchGroceryProductsByUPC handles GET /food/products/upc/{upc}
func (a *HTTPAdapter) SearchGroceryProductsByUPC(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchGroceryProductsByUPCServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &SearchGroceryProductsByUPCPath{}
	pathParamUpcStr := chi.URLParam(r, "upc")

	pathParamUpc, err := runtime.ParseString[float32](pathParamUpcStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "SearchGroceryProductsByUPC",
			Message:       err.Error(),
			ParamName:     "upc",
			ParamLocation: "path",
		})
		return
	}
	pathParams.Upc = pathParamUpc
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.SearchGroceryProductsByUPC(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchCustomFoods handles GET /food/customFoods/search
func (a *HTTPAdapter) SearchCustomFoods(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchCustomFoodsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchCustomFoodsQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery, err := runtime.ParseString[Query](queryParamQueryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchCustomFoods",
				Message:       err.Error(),
				ParamName:     "query",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Query = &queryParamQuery
	}
	if queryParamUsernameStr := query.Get("username"); queryParamUsernameStr != "" {
		queryParamUsername := queryParamUsernameStr
		queryParams.Username = queryParamUsername
	}
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash := queryParamHashStr
		queryParams.Hash = queryParamHash
	}
	if queryParamOffsetStr := query.Get("offset"); queryParamOffsetStr != "" {
		queryParamOffset, err := runtime.ParseString[Offset](queryParamOffsetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchCustomFoods",
				Message:       err.Error(),
				ParamName:     "offset",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Offset = &queryParamOffset
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchCustomFoods",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchCustomFoods(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetProductInformation handles GET /food/products/{id}
func (a *HTTPAdapter) GetProductInformation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetProductInformationServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetProductInformationPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetProductInformation",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetProductInformation(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetComparableProducts handles GET /food/products/upc/{upc}/comparable
func (a *HTTPAdapter) GetComparableProducts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetComparableProductsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetComparableProductsPath{}
	pathParamUpcStr := chi.URLParam(r, "upc")

	pathParamUpc, err := runtime.ParseString[float32](pathParamUpcStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetComparableProducts",
			Message:       err.Error(),
			ParamName:     "upc",
			ParamLocation: "path",
		})
		return
	}
	pathParams.Upc = pathParamUpc
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetComparableProducts(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AutocompleteProductSearch handles GET /food/products/suggest
func (a *HTTPAdapter) AutocompleteProductSearch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AutocompleteProductSearchServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &AutocompleteProductSearchQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery := queryParamQueryStr
		queryParams.Query = queryParamQuery
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[int64](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AutocompleteProductSearch",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.AutocompleteProductSearch(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// VisualizeProductNutritionByID handles GET /food/products/{id}/nutritionWidget
func (a *HTTPAdapter) VisualizeProductNutritionByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeProductNutritionByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &VisualizeProductNutritionByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "VisualizeProductNutritionByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &VisualizeProductNutritionByIDQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeProductNutritionByID",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	opts.Query = queryParams

	// Parse header parameters
	headerParams := &VisualizeProductNutritionByIDHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Accept")]; len(headerValues) > 0 {
		headerParamAccept, err := runtime.ParseString[Accept](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeProductNutritionByID",
				Message:       err.Error(),
				ParamName:     "Accept",
				ParamLocation: "header",
			})
			return
		}
		headerParams.Accept = &headerParamAccept
	}
	opts.Header = headerParams

	// Call business logic
	resp, err := a.svc.VisualizeProductNutritionByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// ProductNutritionByIDImage handles GET /food/products/{id}/nutritionWidget.png
func (a *HTTPAdapter) ProductNutritionByIDImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ProductNutritionByIDImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &ProductNutritionByIDImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "ProductNutritionByIDImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.ProductNutritionByIDImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// ProductNutritionLabelWidget handles GET /food/products/{id}/nutritionLabel
func (a *HTTPAdapter) ProductNutritionLabelWidget(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ProductNutritionLabelWidgetServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &ProductNutritionLabelWidgetPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "ProductNutritionLabelWidget",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &ProductNutritionLabelWidgetQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ProductNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	if queryParamShowOptionalNutrientsStr := query.Get("showOptionalNutrients"); queryParamShowOptionalNutrientsStr != "" {
		queryParamShowOptionalNutrients, err := runtime.ParseString[bool](queryParamShowOptionalNutrientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ProductNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showOptionalNutrients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowOptionalNutrients = &queryParamShowOptionalNutrients
	}
	if queryParamShowZeroValuesStr := query.Get("showZeroValues"); queryParamShowZeroValuesStr != "" {
		queryParamShowZeroValues, err := runtime.ParseString[bool](queryParamShowZeroValuesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ProductNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showZeroValues",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowZeroValues = &queryParamShowZeroValues
	}
	if queryParamShowIngredientsStr := query.Get("showIngredients"); queryParamShowIngredientsStr != "" {
		queryParamShowIngredients, err := runtime.ParseString[bool](queryParamShowIngredientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ProductNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showIngredients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowIngredients = &queryParamShowIngredients
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ProductNutritionLabelWidget(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// ProductNutritionLabelImage handles GET /food/products/{id}/nutritionLabel.png
func (a *HTTPAdapter) ProductNutritionLabelImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ProductNutritionLabelImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &ProductNutritionLabelImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "ProductNutritionLabelImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &ProductNutritionLabelImageQuery{}
	query := r.URL.Query()
	if queryParamShowOptionalNutrientsStr := query.Get("showOptionalNutrients"); queryParamShowOptionalNutrientsStr != "" {
		queryParamShowOptionalNutrients, err := runtime.ParseString[bool](queryParamShowOptionalNutrientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ProductNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showOptionalNutrients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowOptionalNutrients = &queryParamShowOptionalNutrients
	}
	if queryParamShowZeroValuesStr := query.Get("showZeroValues"); queryParamShowZeroValuesStr != "" {
		queryParamShowZeroValues, err := runtime.ParseString[bool](queryParamShowZeroValuesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ProductNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showZeroValues",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowZeroValues = &queryParamShowZeroValues
	}
	if queryParamShowIngredientsStr := query.Get("showIngredients"); queryParamShowIngredientsStr != "" {
		queryParamShowIngredients, err := runtime.ParseString[bool](queryParamShowIngredientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ProductNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showIngredients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowIngredients = &queryParamShowIngredients
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ProductNutritionLabelImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// ClassifyGroceryProduct handles POST /food/products/classify
func (a *HTTPAdapter) ClassifyGroceryProduct(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ClassifyGroceryProductServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ClassifyGroceryProductQuery{}
	query := r.URL.Query()
	if queryParamLocaleStr := query.Get("locale"); queryParamLocaleStr != "" {

		queryParamLocale := ClassifyGroceryProductQueryLocale(queryParamLocaleStr)
		queryParams.Locale = &queryParamLocale
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()
	var body ClassifyGroceryProductBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ClassifyGroceryProduct",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.ClassifyGroceryProduct(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ClassifyGroceryProductBulk handles POST /food/products/classifyBatch
func (a *HTTPAdapter) ClassifyGroceryProductBulk(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ClassifyGroceryProductBulkServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ClassifyGroceryProductBulkQuery{}
	query := r.URL.Query()
	if queryParamLocaleStr := query.Get("locale"); queryParamLocaleStr != "" {
		queryParamLocale := queryParamLocaleStr
		queryParams.Locale = &queryParamLocale
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()
	var body ClassifyGroceryProductBulkBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "ClassifyGroceryProductBulk",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.ClassifyGroceryProductBulk(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// MapIngredientsToGroceryProducts handles POST /food/ingredients/map
func (a *HTTPAdapter) MapIngredientsToGroceryProducts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &MapIngredientsToGroceryProductsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()
	var body MapIngredientsToGroceryProductsBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "MapIngredientsToGroceryProducts",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.MapIngredientsToGroceryProducts(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AutocompleteMenuItemSearch handles GET /food/menuItems/suggest
func (a *HTTPAdapter) AutocompleteMenuItemSearch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AutocompleteMenuItemSearchServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &AutocompleteMenuItemSearchQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery := queryParamQueryStr
		queryParams.Query = queryParamQuery
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[float32](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AutocompleteMenuItemSearch",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.AutocompleteMenuItemSearch(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchMenuItems handles GET /food/menuItems/search
func (a *HTTPAdapter) SearchMenuItems(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchMenuItemsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchMenuItemsQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery, err := runtime.ParseString[Query](queryParamQueryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "query",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Query = &queryParamQuery
	}
	if queryParamMinCaloriesStr := query.Get("minCalories"); queryParamMinCaloriesStr != "" {
		queryParamMinCalories, err := runtime.ParseString[float32](queryParamMinCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "minCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCalories = &queryParamMinCalories
	}
	if queryParamMaxCaloriesStr := query.Get("maxCalories"); queryParamMaxCaloriesStr != "" {
		queryParamMaxCalories, err := runtime.ParseString[float32](queryParamMaxCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "maxCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCalories = &queryParamMaxCalories
	}
	if queryParamMinCarbsStr := query.Get("minCarbs"); queryParamMinCarbsStr != "" {
		queryParamMinCarbs, err := runtime.ParseString[float32](queryParamMinCarbsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "minCarbs",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinCarbs = &queryParamMinCarbs
	}
	if queryParamMaxCarbsStr := query.Get("maxCarbs"); queryParamMaxCarbsStr != "" {
		queryParamMaxCarbs, err := runtime.ParseString[float32](queryParamMaxCarbsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "maxCarbs",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxCarbs = &queryParamMaxCarbs
	}
	if queryParamMinProteinStr := query.Get("minProtein"); queryParamMinProteinStr != "" {
		queryParamMinProtein, err := runtime.ParseString[float32](queryParamMinProteinStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "minProtein",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinProtein = &queryParamMinProtein
	}
	if queryParamMaxProteinStr := query.Get("maxProtein"); queryParamMaxProteinStr != "" {
		queryParamMaxProtein, err := runtime.ParseString[float32](queryParamMaxProteinStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "maxProtein",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxProtein = &queryParamMaxProtein
	}
	if queryParamMinFatStr := query.Get("minFat"); queryParamMinFatStr != "" {
		queryParamMinFat, err := runtime.ParseString[float32](queryParamMinFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "minFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinFat = &queryParamMinFat
	}
	if queryParamMaxFatStr := query.Get("maxFat"); queryParamMaxFatStr != "" {
		queryParamMaxFat, err := runtime.ParseString[float32](queryParamMaxFatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "maxFat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxFat = &queryParamMaxFat
	}
	if queryParamAddMenuItemInformationStr := query.Get("addMenuItemInformation"); queryParamAddMenuItemInformationStr != "" {
		queryParamAddMenuItemInformation, err := runtime.ParseString[SearchMenuItemsQueryAddMenuItemInformation](queryParamAddMenuItemInformationStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "addMenuItemInformation",
				ParamLocation: "query",
			})
			return
		}
		queryParams.AddMenuItemInformation = &queryParamAddMenuItemInformation
	}
	if queryParamOffsetStr := query.Get("offset"); queryParamOffsetStr != "" {
		queryParamOffset, err := runtime.ParseString[Offset](queryParamOffsetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "offset",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Offset = &queryParamOffset
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchMenuItems",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchMenuItems(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetMenuItemInformation handles GET /food/menuItems/{id}
func (a *HTTPAdapter) GetMenuItemInformation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetMenuItemInformationServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetMenuItemInformationPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetMenuItemInformation",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetMenuItemInformation(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// VisualizeMenuItemNutritionByID handles GET /food/menuItems/{id}/nutritionWidget
func (a *HTTPAdapter) VisualizeMenuItemNutritionByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &VisualizeMenuItemNutritionByIDServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &VisualizeMenuItemNutritionByIDPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "VisualizeMenuItemNutritionByID",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &VisualizeMenuItemNutritionByIDQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeMenuItemNutritionByID",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	opts.Query = queryParams

	// Parse header parameters
	headerParams := &VisualizeMenuItemNutritionByIDHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Accept")]; len(headerValues) > 0 {
		headerParamAccept, err := runtime.ParseString[Accept](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "VisualizeMenuItemNutritionByID",
				Message:       err.Error(),
				ParamName:     "Accept",
				ParamLocation: "header",
			})
			return
		}
		headerParams.Accept = &headerParamAccept
	}
	opts.Header = headerParams

	// Call business logic
	resp, err := a.svc.VisualizeMenuItemNutritionByID(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// MenuItemNutritionByIDImage handles GET /food/menuItems/{id}/nutritionWidget.png
func (a *HTTPAdapter) MenuItemNutritionByIDImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &MenuItemNutritionByIDImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &MenuItemNutritionByIDImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "MenuItemNutritionByIDImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.MenuItemNutritionByIDImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// MenuItemNutritionLabelWidget handles GET /food/menuItems/{id}/nutritionLabel
func (a *HTTPAdapter) MenuItemNutritionLabelWidget(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &MenuItemNutritionLabelWidgetServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &MenuItemNutritionLabelWidgetPath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "MenuItemNutritionLabelWidget",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &MenuItemNutritionLabelWidgetQuery{}
	query := r.URL.Query()
	if queryParamDefaultCSSStr := query.Get("defaultCss"); queryParamDefaultCSSStr != "" {
		queryParamDefaultCSS, err := runtime.ParseString[DefaultCSS](queryParamDefaultCSSStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "MenuItemNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "defaultCss",
				ParamLocation: "query",
			})
			return
		}
		queryParams.DefaultCSS = &queryParamDefaultCSS
	}
	if queryParamShowOptionalNutrientsStr := query.Get("showOptionalNutrients"); queryParamShowOptionalNutrientsStr != "" {
		queryParamShowOptionalNutrients, err := runtime.ParseString[bool](queryParamShowOptionalNutrientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "MenuItemNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showOptionalNutrients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowOptionalNutrients = &queryParamShowOptionalNutrients
	}
	if queryParamShowZeroValuesStr := query.Get("showZeroValues"); queryParamShowZeroValuesStr != "" {
		queryParamShowZeroValues, err := runtime.ParseString[bool](queryParamShowZeroValuesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "MenuItemNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showZeroValues",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowZeroValues = &queryParamShowZeroValues
	}
	if queryParamShowIngredientsStr := query.Get("showIngredients"); queryParamShowIngredientsStr != "" {
		queryParamShowIngredients, err := runtime.ParseString[bool](queryParamShowIngredientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "MenuItemNutritionLabelWidget",
				Message:       err.Error(),
				ParamName:     "showIngredients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowIngredients = &queryParamShowIngredients
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.MenuItemNutritionLabelWidget(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// MenuItemNutritionLabelImage handles GET /food/menuItems/{id}/nutritionLabel.png
func (a *HTTPAdapter) MenuItemNutritionLabelImage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &MenuItemNutritionLabelImageServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &MenuItemNutritionLabelImagePath{}
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "MenuItemNutritionLabelImage",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &MenuItemNutritionLabelImageQuery{}
	query := r.URL.Query()
	if queryParamShowOptionalNutrientsStr := query.Get("showOptionalNutrients"); queryParamShowOptionalNutrientsStr != "" {
		queryParamShowOptionalNutrients, err := runtime.ParseString[bool](queryParamShowOptionalNutrientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "MenuItemNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showOptionalNutrients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowOptionalNutrients = &queryParamShowOptionalNutrients
	}
	if queryParamShowZeroValuesStr := query.Get("showZeroValues"); queryParamShowZeroValuesStr != "" {
		queryParamShowZeroValues, err := runtime.ParseString[bool](queryParamShowZeroValuesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "MenuItemNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showZeroValues",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowZeroValues = &queryParamShowZeroValues
	}
	if queryParamShowIngredientsStr := query.Get("showIngredients"); queryParamShowIngredientsStr != "" {
		queryParamShowIngredients, err := runtime.ParseString[bool](queryParamShowIngredientsStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "MenuItemNutritionLabelImage",
				Message:       err.Error(),
				ParamName:     "showIngredients",
				ParamLocation: "query",
			})
			return
		}
		queryParams.ShowIngredients = &queryParamShowIngredients
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.MenuItemNutritionLabelImage(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GenerateMealPlan handles GET /mealplanner/generate
func (a *HTTPAdapter) GenerateMealPlan(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GenerateMealPlanServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GenerateMealPlanQuery{}
	query := r.URL.Query()
	if queryParamTimeFrameStr := query.Get("timeFrame"); queryParamTimeFrameStr != "" {
		queryParamTimeFrame := queryParamTimeFrameStr
		queryParams.TimeFrame = &queryParamTimeFrame
	}
	if queryParamTargetCaloriesStr := query.Get("targetCalories"); queryParamTargetCaloriesStr != "" {
		queryParamTargetCalories, err := runtime.ParseString[float32](queryParamTargetCaloriesStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GenerateMealPlan",
				Message:       err.Error(),
				ParamName:     "targetCalories",
				ParamLocation: "query",
			})
			return
		}
		queryParams.TargetCalories = &queryParamTargetCalories
	}
	if queryParamDietStr := query.Get("diet"); queryParamDietStr != "" {
		queryParamDiet := queryParamDietStr
		queryParams.Diet = &queryParamDiet
	}
	if queryParamExcludeStr := query.Get("exclude"); queryParamExcludeStr != "" {
		queryParamExclude := queryParamExcludeStr
		queryParams.Exclude = &queryParamExclude
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GenerateMealPlan(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetMealPlanWeek handles GET /mealplanner/{username}/week/{start-date}
func (a *HTTPAdapter) GetMealPlanWeek(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetMealPlanWeekServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetMealPlanWeekPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	pathParamStartDateStr := chi.URLParam(r, "start-date")
	pathParams.StartDate = pathParamStartDateStr
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetMealPlanWeekQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetMealPlanWeek",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetMealPlanWeek(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ClearMealPlanDay handles DELETE /mealplanner/{username}/day/{date}
func (a *HTTPAdapter) ClearMealPlanDay(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ClearMealPlanDayServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &ClearMealPlanDayPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	pathParamDateStr := chi.URLParam(r, "date")
	pathParams.Date = pathParamDateStr
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &ClearMealPlanDayQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ClearMealPlanDay",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.ClearMealPlanDay(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AddToMealPlan handles POST /mealplanner/{username}/items
func (a *HTTPAdapter) AddToMealPlan(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AddToMealPlanServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &AddToMealPlanPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &AddToMealPlanQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AddToMealPlan",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.AddToMealPlan(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// DeleteFromMealPlan handles DELETE /mealplanner/{username}/items/{id}
func (a *HTTPAdapter) DeleteFromMealPlan(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DeleteFromMealPlanServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &DeleteFromMealPlanPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "DeleteFromMealPlan",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &DeleteFromMealPlanQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "DeleteFromMealPlan",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.DeleteFromMealPlan(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetMealPlanTemplates handles GET /mealplanner/{username}/templates
func (a *HTTPAdapter) GetMealPlanTemplates(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetMealPlanTemplatesServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetMealPlanTemplatesPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetMealPlanTemplatesQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetMealPlanTemplates",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetMealPlanTemplates(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AddMealPlanTemplate handles POST /mealplanner/{username}/templates
func (a *HTTPAdapter) AddMealPlanTemplate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AddMealPlanTemplateServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &AddMealPlanTemplatePath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &AddMealPlanTemplateQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash := queryParamHashStr
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.AddMealPlanTemplate(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetMealPlanTemplate handles GET /mealplanner/{username}/templates/{id}
func (a *HTTPAdapter) GetMealPlanTemplate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetMealPlanTemplateServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetMealPlanTemplatePath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "GetMealPlanTemplate",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetMealPlanTemplateQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetMealPlanTemplate",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetMealPlanTemplate(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// DeleteMealPlanTemplate handles DELETE /mealplanner/{username}/templates/{id}
func (a *HTTPAdapter) DeleteMealPlanTemplate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DeleteMealPlanTemplateServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &DeleteMealPlanTemplatePath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "DeleteMealPlanTemplate",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &DeleteMealPlanTemplateQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash := queryParamHashStr
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.DeleteMealPlanTemplate(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetShoppingList handles GET /mealplanner/{username}/shopping-list
func (a *HTTPAdapter) GetShoppingList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetShoppingListServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetShoppingListPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GetShoppingListQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetShoppingList",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetShoppingList(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GenerateShoppingList handles POST /mealplanner/{username}/shopping-list/{start-date}/{end-date}
func (a *HTTPAdapter) GenerateShoppingList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GenerateShoppingListServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GenerateShoppingListPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	pathParamStartDateStr := chi.URLParam(r, "start-date")
	pathParams.StartDate = pathParamStartDateStr
	pathParamEndDateStr := chi.URLParam(r, "end-date")
	pathParams.EndDate = pathParamEndDateStr
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &GenerateShoppingListQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GenerateShoppingList",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.GenerateShoppingList(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ConnectUser handles POST /users/connect
func (a *HTTPAdapter) ConnectUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ConnectUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.ConnectUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// AddToShoppingList handles POST /mealplanner/{username}/shopping-list/items
func (a *HTTPAdapter) AddToShoppingList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &AddToShoppingListServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &AddToShoppingListPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &AddToShoppingListQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "AddToShoppingList",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.AddToShoppingList(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// DeleteFromShoppingList handles DELETE /mealplanner/{username}/shopping-list/items/{id}
func (a *HTTPAdapter) DeleteFromShoppingList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DeleteFromShoppingListServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &DeleteFromShoppingListPath{}
	pathParamUsernameStr := chi.URLParam(r, "username")
	pathParams.Username = pathParamUsernameStr
	pathParamIDStr := chi.URLParam(r, "id")

	pathParamID, err := runtime.ParseString[float32](pathParamIDStr)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:          OapiErrorKindParse,
			OperationID:   "DeleteFromShoppingList",
			Message:       err.Error(),
			ParamName:     "id",
			ParamLocation: "path",
		})
		return
	}
	pathParams.ID = pathParamID
	opts.PathParams = pathParams
	// Parse query parameters
	queryParams := &DeleteFromShoppingListQuery{}
	query := r.URL.Query()
	if queryParamHashStr := query.Get("hash"); queryParamHashStr != "" {
		queryParamHash, err := runtime.ParseString[Hash](queryParamHashStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "DeleteFromShoppingList",
				Message:       err.Error(),
				ParamName:     "hash",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Hash = queryParamHash
	}
	opts.Query = queryParams
	// Parse request body
	defer r.Body.Close()

	// Call business logic
	resp, err := a.svc.DeleteFromShoppingList(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchRestaurants handles GET /food/restaurants/search
func (a *HTTPAdapter) SearchRestaurants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchRestaurantsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchRestaurantsQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery := queryParamQueryStr
		queryParams.Query = &queryParamQuery
	}
	if queryParamLatStr := query.Get("lat"); queryParamLatStr != "" {
		queryParamLat, err := runtime.ParseString[float32](queryParamLatStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRestaurants",
				Message:       err.Error(),
				ParamName:     "lat",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Lat = &queryParamLat
	}
	if queryParamLngStr := query.Get("lng"); queryParamLngStr != "" {
		queryParamLng, err := runtime.ParseString[float32](queryParamLngStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRestaurants",
				Message:       err.Error(),
				ParamName:     "lng",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Lng = &queryParamLng
	}
	if queryParamDistanceStr := query.Get("distance"); queryParamDistanceStr != "" {
		queryParamDistance, err := runtime.ParseString[float32](queryParamDistanceStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRestaurants",
				Message:       err.Error(),
				ParamName:     "distance",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Distance = &queryParamDistance
	}
	if queryParamBudgetStr := query.Get("budget"); queryParamBudgetStr != "" {
		queryParamBudget, err := runtime.ParseString[float32](queryParamBudgetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRestaurants",
				Message:       err.Error(),
				ParamName:     "budget",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Budget = &queryParamBudget
	}
	if queryParamCuisineStr := query.Get("cuisine"); queryParamCuisineStr != "" {
		queryParamCuisine := queryParamCuisineStr
		queryParams.Cuisine = &queryParamCuisine
	}
	if queryParamMinRatingStr := query.Get("min-rating"); queryParamMinRatingStr != "" {
		queryParamMinRating, err := runtime.ParseString[float32](queryParamMinRatingStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRestaurants",
				Message:       err.Error(),
				ParamName:     "min-rating",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinRating = &queryParamMinRating
	}
	if queryParamIsOpenStr := query.Get("is-open"); queryParamIsOpenStr != "" {
		queryParamIsOpen, err := runtime.ParseString[bool](queryParamIsOpenStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRestaurants",
				Message:       err.Error(),
				ParamName:     "is-open",
				ParamLocation: "query",
			})
			return
		}
		queryParams.IsOpen = &queryParamIsOpen
	}
	if queryParamSortStr := query.Get("sort"); queryParamSortStr != "" {
		queryParamSort := queryParamSortStr
		queryParams.Sort = &queryParamSort
	}
	if queryParamPageStr := query.Get("page"); queryParamPageStr != "" {
		queryParamPage, err := runtime.ParseString[float32](queryParamPageStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchRestaurants",
				Message:       err.Error(),
				ParamName:     "page",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Page = &queryParamPage
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchRestaurants(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetDishPairingForWine handles GET /food/wine/dishes
func (a *HTTPAdapter) GetDishPairingForWine(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetDishPairingForWineServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GetDishPairingForWineQuery{}
	query := r.URL.Query()
	if queryParamWineStr := query.Get("wine"); queryParamWineStr != "" {
		queryParamWine := queryParamWineStr
		queryParams.Wine = queryParamWine
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetDishPairingForWine(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetWinePairing handles GET /food/wine/pairing
func (a *HTTPAdapter) GetWinePairing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetWinePairingServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GetWinePairingQuery{}
	query := r.URL.Query()
	if queryParamFoodStr := query.Get("food"); queryParamFoodStr != "" {
		queryParamFood := queryParamFoodStr
		queryParams.Food = queryParamFood
	}
	if queryParamMaxPriceStr := query.Get("maxPrice"); queryParamMaxPriceStr != "" {
		queryParamMaxPrice, err := runtime.ParseString[float32](queryParamMaxPriceStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetWinePairing",
				Message:       err.Error(),
				ParamName:     "maxPrice",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxPrice = &queryParamMaxPrice
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetWinePairing(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetWineDescription handles GET /food/wine/description
func (a *HTTPAdapter) GetWineDescription(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetWineDescriptionServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GetWineDescriptionQuery{}
	query := r.URL.Query()
	if queryParamWineStr := query.Get("wine"); queryParamWineStr != "" {
		queryParamWine := queryParamWineStr
		queryParams.Wine = queryParamWine
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetWineDescription(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetWineRecommendation handles GET /food/wine/recommendation
func (a *HTTPAdapter) GetWineRecommendation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetWineRecommendationServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GetWineRecommendationQuery{}
	query := r.URL.Query()
	if queryParamWineStr := query.Get("wine"); queryParamWineStr != "" {
		queryParamWine := queryParamWineStr
		queryParams.Wine = queryParamWine
	}
	if queryParamMaxPriceStr := query.Get("maxPrice"); queryParamMaxPriceStr != "" {
		queryParamMaxPrice, err := runtime.ParseString[float32](queryParamMaxPriceStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetWineRecommendation",
				Message:       err.Error(),
				ParamName:     "maxPrice",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxPrice = &queryParamMaxPrice
	}
	if queryParamMinRatingStr := query.Get("minRating"); queryParamMinRatingStr != "" {
		queryParamMinRating, err := runtime.ParseString[float32](queryParamMinRatingStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetWineRecommendation",
				Message:       err.Error(),
				ParamName:     "minRating",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinRating = &queryParamMinRating
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[float32](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetWineRecommendation",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetWineRecommendation(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ImageClassificationByURL handles GET /food/images/classify
func (a *HTTPAdapter) ImageClassificationByURL(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ImageClassificationByURLServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ImageClassificationByURLQuery{}
	query := r.URL.Query()
	if queryParamImageURLStr := query.Get("imageUrl"); queryParamImageURLStr != "" {
		queryParamImageURL := queryParamImageURLStr
		queryParams.ImageURL = queryParamImageURL
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ImageClassificationByURL(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ImageAnalysisByURL handles GET /food/images/analyze
func (a *HTTPAdapter) ImageAnalysisByURL(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ImageAnalysisByURLServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ImageAnalysisByURLQuery{}
	query := r.URL.Query()
	if queryParamImageURLStr := query.Get("imageUrl"); queryParamImageURLStr != "" {
		queryParamImageURL := queryParamImageURLStr
		queryParams.ImageURL = queryParamImageURL
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ImageAnalysisByURL(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// QuickAnswer handles GET /recipes/quickAnswer
func (a *HTTPAdapter) QuickAnswer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &QuickAnswerServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &QuickAnswerQuery{}
	query := r.URL.Query()
	if queryParamQStr := query.Get("q"); queryParamQStr != "" {
		queryParamQ := queryParamQStr
		queryParams.Q = queryParamQ
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.QuickAnswer(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// DetectFoodInText handles POST /food/detect
func (a *HTTPAdapter) DetectFoodInText(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DetectFoodInTextServiceRequestOptions{}
	opts.RawRequest = r

	// Parse header parameters
	headerParams := &DetectFoodInTextHeaders{}
	headers := r.Header
	if headerValues := headers[http.CanonicalHeaderKey("Content-Type")]; len(headerValues) > 0 {
		headerParamContentType, err := runtime.ParseString[ContentType](headerValues[0])
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "DetectFoodInText",
				Message:       err.Error(),
				ParamName:     "Content-Type",
				ParamLocation: "header",
			})
			return
		}
		headerParams.ContentType = &headerParamContentType
	}
	opts.Header = headerParams
	// Parse request body
	defer r.Body.Close()
	var body DetectFoodInTextBody
	formBytes, err := io.ReadAll(r.Body)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "DetectFoodInText",
			Message:     err.Error(),
		})
		return
	}
	jsonBytes, err := runtime.ConvertFormFields(formBytes)
	if err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "DetectFoodInText",
			Message:     err.Error(),
		})
		return
	}
	if err := json.Unmarshal(jsonBytes, &body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "DetectFoodInText",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.DetectFoodInText(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchSiteContent handles GET /food/site/search
func (a *HTTPAdapter) SearchSiteContent(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchSiteContentServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchSiteContentQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery := queryParamQueryStr
		queryParams.Query = queryParamQuery
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchSiteContent(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchAllFood handles GET /food/search
func (a *HTTPAdapter) SearchAllFood(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchAllFoodServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchAllFoodQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery := queryParamQueryStr
		queryParams.Query = queryParamQuery
	}
	if queryParamOffsetStr := query.Get("offset"); queryParamOffsetStr != "" {
		queryParamOffset, err := runtime.ParseString[Offset](queryParamOffsetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchAllFood",
				Message:       err.Error(),
				ParamName:     "offset",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Offset = &queryParamOffset
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchAllFood",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchAllFood(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// SearchFoodVideos handles GET /food/videos/search
func (a *HTTPAdapter) SearchFoodVideos(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &SearchFoodVideosServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &SearchFoodVideosQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery, err := runtime.ParseString[Query](queryParamQueryStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchFoodVideos",
				Message:       err.Error(),
				ParamName:     "query",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Query = &queryParamQuery
	}
	if queryParamTypeStr := query.Get("type"); queryParamTypeStr != "" {
		queryParamType := queryParamTypeStr
		queryParams.Type = &queryParamType
	}
	if queryParamCuisineStr := query.Get("cuisine"); queryParamCuisineStr != "" {
		queryParamCuisine := queryParamCuisineStr
		queryParams.Cuisine = &queryParamCuisine
	}
	if queryParamDietStr := query.Get("diet"); queryParamDietStr != "" {
		queryParamDiet := queryParamDietStr
		queryParams.Diet = &queryParamDiet
	}
	if queryParamIncludeIngredientsStr := query.Get("includeIngredients"); queryParamIncludeIngredientsStr != "" {
		queryParamIncludeIngredients := queryParamIncludeIngredientsStr
		queryParams.IncludeIngredients = &queryParamIncludeIngredients
	}
	if queryParamExcludeIngredientsStr := query.Get("excludeIngredients"); queryParamExcludeIngredientsStr != "" {
		queryParamExcludeIngredients := queryParamExcludeIngredientsStr
		queryParams.ExcludeIngredients = &queryParamExcludeIngredients
	}
	if queryParamMinLengthStr := query.Get("minLength"); queryParamMinLengthStr != "" {
		queryParamMinLength, err := runtime.ParseString[float32](queryParamMinLengthStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchFoodVideos",
				Message:       err.Error(),
				ParamName:     "minLength",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MinLength = &queryParamMinLength
	}
	if queryParamMaxLengthStr := query.Get("maxLength"); queryParamMaxLengthStr != "" {
		queryParamMaxLength, err := runtime.ParseString[float32](queryParamMaxLengthStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchFoodVideos",
				Message:       err.Error(),
				ParamName:     "maxLength",
				ParamLocation: "query",
			})
			return
		}
		queryParams.MaxLength = &queryParamMaxLength
	}
	if queryParamOffsetStr := query.Get("offset"); queryParamOffsetStr != "" {
		queryParamOffset, err := runtime.ParseString[Offset](queryParamOffsetStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchFoodVideos",
				Message:       err.Error(),
				ParamName:     "offset",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Offset = &queryParamOffset
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[Number](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "SearchFoodVideos",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.SearchFoodVideos(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetARandomFoodJoke handles GET /food/jokes/random
func (a *HTTPAdapter) GetARandomFoodJoke(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.GetARandomFoodJoke(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetRandomFoodTrivia handles GET /food/trivia/random
func (a *HTTPAdapter) GetRandomFoodTrivia(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.GetRandomFoodTrivia(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// TalkToChatbot handles GET /food/converse
func (a *HTTPAdapter) TalkToChatbot(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &TalkToChatbotServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &TalkToChatbotQuery{}
	query := r.URL.Query()
	if queryParamTextStr := query.Get("text"); queryParamTextStr != "" {
		queryParamText := queryParamTextStr
		queryParams.Text = queryParamText
	}
	if queryParamContextIDStr := query.Get("contextId"); queryParamContextIDStr != "" {
		queryParamContextID := queryParamContextIDStr
		queryParams.ContextID = &queryParamContextID
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.TalkToChatbot(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetConversationSuggests handles GET /food/converse/suggest
func (a *HTTPAdapter) GetConversationSuggests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetConversationSuggestsServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &GetConversationSuggestsQuery{}
	query := r.URL.Query()
	if queryParamQueryStr := query.Get("query"); queryParamQueryStr != "" {
		queryParamQuery := queryParamQueryStr
		queryParams.Query = queryParamQuery
	}
	if queryParamNumberStr := query.Get("number"); queryParamNumberStr != "" {
		queryParamNumber, err := runtime.ParseString[float32](queryParamNumberStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "GetConversationSuggests",
				Message:       err.Error(),
				ParamName:     "number",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Number = &queryParamNumber
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.GetConversationSuggests(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// RouterOption is a function that configures the router.
type RouterOption func(*routerConfig)

type routerConfig struct {
	middlewares []func(http.Handler) http.Handler
	errHandler  OapiErrorHandler
}

// WithMiddleware adds middleware to the router.
func WithMiddleware(mw func(http.Handler) http.Handler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.middlewares = append(cfg.middlewares, mw)
	}
}

// WithErrorHandler sets a custom error handler for the router.
// If not set, OapiOapiDefaultErrorHandler is used.
func WithErrorHandler(h OapiErrorHandler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.errHandler = h
	}
}

// NewRouter creates a new chi.Router with the given service implementation.
func NewRouter(svc ServiceInterface, opts ...RouterOption) chi.Router {
	cfg := &routerConfig{}
	for _, opt := range opts {
		opt(cfg)
	}

	r := chi.NewRouter()
	for _, mw := range cfg.middlewares {
		r.Use(mw)
	}
	adapter := NewHTTPAdapter(svc, cfg.errHandler)
	r.Method("GET", "/recipes/complexSearch", http.HandlerFunc(adapter.SearchRecipes))
	r.Method("GET", "/recipes/findByIngredients", http.HandlerFunc(adapter.SearchRecipesByIngredients))
	r.Method("GET", "/recipes/findByNutrients", http.HandlerFunc(adapter.SearchRecipesByNutrients))
	r.Method("GET", "/recipes/{id}/information", http.HandlerFunc(adapter.GetRecipeInformation))
	r.Method("GET", "/recipes/informationBulk", http.HandlerFunc(adapter.GetRecipeInformationBulk))
	r.Method("GET", "/recipes/{id}/similar", http.HandlerFunc(adapter.GetSimilarRecipes))
	r.Method("GET", "/recipes/random", http.HandlerFunc(adapter.GetRandomRecipes))
	r.Method("GET", "/recipes/autocomplete", http.HandlerFunc(adapter.AutocompleteRecipeSearch))
	r.Method("GET", "/recipes/{id}/tasteWidget.json", http.HandlerFunc(adapter.GetRecipeTasteByID))
	r.Method("GET", "/recipes/{id}/tasteWidget.png", http.HandlerFunc(adapter.RecipeTasteByIDImage))
	r.Method("GET", "/recipes/{id}/equipmentWidget.json", http.HandlerFunc(adapter.GetRecipeEquipmentByID))
	r.Method("GET", "/recipes/{id}/equipmentWidget.png", http.HandlerFunc(adapter.EquipmentByIDImage))
	r.Method("GET", "/recipes/{id}/priceBreakdownWidget.json", http.HandlerFunc(adapter.GetRecipePriceBreakdownByID))
	r.Method("GET", "/recipes/{id}/priceBreakdownWidget.png", http.HandlerFunc(adapter.PriceBreakdownByIDImage))
	r.Method("GET", "/recipes/{id}/ingredientWidget.json", http.HandlerFunc(adapter.GetRecipeIngredientsByID))
	r.Method("GET", "/recipes/{id}/ingredientWidget.png", http.HandlerFunc(adapter.IngredientsByIDImage))
	r.Method("GET", "/recipes/{id}/nutritionWidget.json", http.HandlerFunc(adapter.GetRecipeNutritionWidgetByID))
	r.Method("GET", "/recipes/{id}/nutritionWidget.png", http.HandlerFunc(adapter.RecipeNutritionByIDImage))
	r.Method("GET", "/recipes/{id}/nutritionLabel", http.HandlerFunc(adapter.RecipeNutritionLabelWidget))
	r.Method("GET", "/recipes/{id}/nutritionLabel.png", http.HandlerFunc(adapter.RecipeNutritionLabelImage))
	r.Method("GET", "/recipes/{id}/analyzedInstructions", http.HandlerFunc(adapter.GetAnalyzedRecipeInstructions))
	r.Method("GET", "/recipes/extract", http.HandlerFunc(adapter.ExtractRecipeFromWebsite))
	r.Method("GET", "/recipes/{id}/ingredientWidget", http.HandlerFunc(adapter.VisualizeRecipeIngredientsByID))
	r.Method("GET", "/recipes/{id}/tasteWidget", http.HandlerFunc(adapter.VisualizeRecipeTasteByID))
	r.Method("GET", "/recipes/{id}/equipmentWidget", http.HandlerFunc(adapter.VisualizeRecipeEquipmentByID))
	r.Method("GET", "/recipes/{id}/priceBreakdownWidget", http.HandlerFunc(adapter.VisualizeRecipePriceBreakdownByID))
	r.Method("POST", "/recipes/visualizeTaste", http.HandlerFunc(adapter.VisualizeRecipeTaste))
	r.Method("POST", "/recipes/visualizeNutrition", http.HandlerFunc(adapter.VisualizeRecipeNutrition))
	r.Method("POST", "/recipes/visualizePriceEstimator", http.HandlerFunc(adapter.VisualizePriceBreakdown))
	r.Method("POST", "/recipes/visualizeEquipment", http.HandlerFunc(adapter.VisualizeEquipment))
	r.Method("POST", "/recipes/analyze", http.HandlerFunc(adapter.AnalyzeRecipe))
	r.Method("GET", "/recipes/{id}/summary", http.HandlerFunc(adapter.SummarizeRecipe))
	r.Method("GET", "/recipes/{id}/card", http.HandlerFunc(adapter.CreateRecipeCardGet))
	r.Method("POST", "/recipes/visualizeRecipe", http.HandlerFunc(adapter.CreateRecipeCard))
	r.Method("POST", "/recipes/analyzeInstructions", http.HandlerFunc(adapter.AnalyzeRecipeInstructions))
	r.Method("POST", "/recipes/cuisine", http.HandlerFunc(adapter.ClassifyCuisine))
	r.Method("GET", "/recipes/queries/analyze", http.HandlerFunc(adapter.AnalyzeARecipeSearchQuery))
	r.Method("GET", "/recipes/convert", http.HandlerFunc(adapter.ConvertAmounts))
	r.Method("POST", "/recipes/parseIngredients", http.HandlerFunc(adapter.ParseIngredients))
	r.Method("GET", "/recipes/{id}/nutritionWidget", http.HandlerFunc(adapter.VisualizeRecipeNutritionByID))
	r.Method("POST", "/recipes/visualizeIngredients", http.HandlerFunc(adapter.VisualizeIngredients))
	r.Method("GET", "/recipes/guessNutrition", http.HandlerFunc(adapter.GuessNutritionByDishName))
	r.Method("GET", "/food/ingredients/{id}/information", http.HandlerFunc(adapter.GetIngredientInformation))
	r.Method("GET", "/food/ingredients/{id}/amount", http.HandlerFunc(adapter.ComputeIngredientAmount))
	r.Method("POST", "/food/ingredients/glycemicLoad", http.HandlerFunc(adapter.ComputeGlycemicLoad))
	r.Method("GET", "/food/ingredients/autocomplete", http.HandlerFunc(adapter.AutocompleteIngredientSearch))
	r.Method("GET", "/food/ingredients/search", http.HandlerFunc(adapter.IngredientSearch))
	r.Method("GET", "/food/ingredients/substitutes", http.HandlerFunc(adapter.GetIngredientSubstitutes))
	r.Method("GET", "/food/ingredients/{id}/substitutes", http.HandlerFunc(adapter.GetIngredientSubstitutesByID))
	r.Method("GET", "/food/products/search", http.HandlerFunc(adapter.SearchGroceryProducts))
	r.Method("GET", "/food/products/upc/{upc}", http.HandlerFunc(adapter.SearchGroceryProductsByUPC))
	r.Method("GET", "/food/customFoods/search", http.HandlerFunc(adapter.SearchCustomFoods))
	r.Method("GET", "/food/products/{id}", http.HandlerFunc(adapter.GetProductInformation))
	r.Method("GET", "/food/products/upc/{upc}/comparable", http.HandlerFunc(adapter.GetComparableProducts))
	r.Method("GET", "/food/products/suggest", http.HandlerFunc(adapter.AutocompleteProductSearch))
	r.Method("GET", "/food/products/{id}/nutritionWidget", http.HandlerFunc(adapter.VisualizeProductNutritionByID))
	r.Method("GET", "/food/products/{id}/nutritionWidget.png", http.HandlerFunc(adapter.ProductNutritionByIDImage))
	r.Method("GET", "/food/products/{id}/nutritionLabel", http.HandlerFunc(adapter.ProductNutritionLabelWidget))
	r.Method("GET", "/food/products/{id}/nutritionLabel.png", http.HandlerFunc(adapter.ProductNutritionLabelImage))
	r.Method("POST", "/food/products/classify", http.HandlerFunc(adapter.ClassifyGroceryProduct))
	r.Method("POST", "/food/products/classifyBatch", http.HandlerFunc(adapter.ClassifyGroceryProductBulk))
	r.Method("POST", "/food/ingredients/map", http.HandlerFunc(adapter.MapIngredientsToGroceryProducts))
	r.Method("GET", "/food/menuItems/suggest", http.HandlerFunc(adapter.AutocompleteMenuItemSearch))
	r.Method("GET", "/food/menuItems/search", http.HandlerFunc(adapter.SearchMenuItems))
	r.Method("GET", "/food/menuItems/{id}", http.HandlerFunc(adapter.GetMenuItemInformation))
	r.Method("GET", "/food/menuItems/{id}/nutritionWidget", http.HandlerFunc(adapter.VisualizeMenuItemNutritionByID))
	r.Method("GET", "/food/menuItems/{id}/nutritionWidget.png", http.HandlerFunc(adapter.MenuItemNutritionByIDImage))
	r.Method("GET", "/food/menuItems/{id}/nutritionLabel", http.HandlerFunc(adapter.MenuItemNutritionLabelWidget))
	r.Method("GET", "/food/menuItems/{id}/nutritionLabel.png", http.HandlerFunc(adapter.MenuItemNutritionLabelImage))
	r.Method("GET", "/mealplanner/generate", http.HandlerFunc(adapter.GenerateMealPlan))
	r.Method("GET", "/mealplanner/{username}/week/{start-date}", http.HandlerFunc(adapter.GetMealPlanWeek))
	r.Method("DELETE", "/mealplanner/{username}/day/{date}", http.HandlerFunc(adapter.ClearMealPlanDay))
	r.Method("POST", "/mealplanner/{username}/items", http.HandlerFunc(adapter.AddToMealPlan))
	r.Method("DELETE", "/mealplanner/{username}/items/{id}", http.HandlerFunc(adapter.DeleteFromMealPlan))
	r.Method("GET", "/mealplanner/{username}/templates", http.HandlerFunc(adapter.GetMealPlanTemplates))
	r.Method("POST", "/mealplanner/{username}/templates", http.HandlerFunc(adapter.AddMealPlanTemplate))
	r.Method("GET", "/mealplanner/{username}/templates/{id}", http.HandlerFunc(adapter.GetMealPlanTemplate))
	r.Method("DELETE", "/mealplanner/{username}/templates/{id}", http.HandlerFunc(adapter.DeleteMealPlanTemplate))
	r.Method("GET", "/mealplanner/{username}/shopping-list", http.HandlerFunc(adapter.GetShoppingList))
	r.Method("POST", "/mealplanner/{username}/shopping-list/{start-date}/{end-date}", http.HandlerFunc(adapter.GenerateShoppingList))
	r.Method("POST", "/users/connect", http.HandlerFunc(adapter.ConnectUser))
	r.Method("POST", "/mealplanner/{username}/shopping-list/items", http.HandlerFunc(adapter.AddToShoppingList))
	r.Method("DELETE", "/mealplanner/{username}/shopping-list/items/{id}", http.HandlerFunc(adapter.DeleteFromShoppingList))
	r.Method("GET", "/food/restaurants/search", http.HandlerFunc(adapter.SearchRestaurants))
	r.Method("GET", "/food/wine/dishes", http.HandlerFunc(adapter.GetDishPairingForWine))
	r.Method("GET", "/food/wine/pairing", http.HandlerFunc(adapter.GetWinePairing))
	r.Method("GET", "/food/wine/description", http.HandlerFunc(adapter.GetWineDescription))
	r.Method("GET", "/food/wine/recommendation", http.HandlerFunc(adapter.GetWineRecommendation))
	r.Method("GET", "/food/images/classify", http.HandlerFunc(adapter.ImageClassificationByURL))
	r.Method("GET", "/food/images/analyze", http.HandlerFunc(adapter.ImageAnalysisByURL))
	r.Method("GET", "/recipes/quickAnswer", http.HandlerFunc(adapter.QuickAnswer))
	r.Method("POST", "/food/detect", http.HandlerFunc(adapter.DetectFoodInText))
	r.Method("GET", "/food/site/search", http.HandlerFunc(adapter.SearchSiteContent))
	r.Method("GET", "/food/search", http.HandlerFunc(adapter.SearchAllFood))
	r.Method("GET", "/food/videos/search", http.HandlerFunc(adapter.SearchFoodVideos))
	r.Method("GET", "/food/jokes/random", http.HandlerFunc(adapter.GetARandomFoodJoke))
	r.Method("GET", "/food/trivia/random", http.HandlerFunc(adapter.GetRandomFoodTrivia))
	r.Method("GET", "/food/converse", http.HandlerFunc(adapter.TalkToChatbot))
	r.Method("GET", "/food/converse/suggest", http.HandlerFunc(adapter.GetConversationSuggests))

	return r
}

// ============================================================================
// Connexions Service Registration
// ============================================================================

//go:embed setup/config.yml
var configSrc []byte

//go:embed setup/openapi.*
var openapiSpecFS embed.FS

//go:embed setup/codegen.yml
var codegenConfigSrc []byte

//go:embed setup/context.yml
var contextSrc []byte

var cfg *config.ServiceConfig

func init() {
	var err error
	cfg, err = config.NewServiceConfigFromBytes(configSrc)
	if err != nil {
		slog.Error("Failed to parse service config", "error", err)
		return
	}
	loader.Register(cfg.Name, RegisterAPIRouter)
}

// Register registers the service with the central router.
func RegisterAPIRouter(router *api.Router) {
	serviceName := cfg.Name

	// Read OpenAPI spec from embedded FS
	openapiSpec, err := readFirstEmbeddedFile(openapiSpecFS)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to read OpenAPI spec for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}

	// Load codegen config
	var codegenCfg oapicodegen.Configuration
	if err := yamlv4.Unmarshal(codegenConfigSrc, &codegenCfg); err != nil {
		slog.Error(fmt.Sprintf("Failed to parse codegen config for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}
	codegenCfg = codegenCfg.Merge(oapicodegen.NewDefaultConfiguration())

	// Create the typedef registry from the OpenAPI spec
	registry := typedef.NewRegistryFromSpec(openapiSpec, codegenCfg, cfg.SpecOptions)

	// Create the generator with service contexts
	orderedCtx := generator.LoadServiceContext(contextSrc, router.GetContexts())
	gen, err := generator.NewGenerator(orderedCtx)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to create generator for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}

	// Register with connexions using handler factory
	router.RegisterHTTPHandler(cfg, func(serviceDB db.DB) api.Handler {
		userSvc := &service{db: serviceDB}
		genSvc := &generatorService{service: userSvc, generator: gen, registry: registry}
		return newServiceHandler(genSvc, gen, registry)
	}, api.WithMiddleware(getMiddleware()))

	slog.Info(fmt.Sprintf("Registered %s service", serviceName),
		"service", serviceName,
	)
}

// readFirstEmbeddedFile reads the first file from an embedded filesystem.
func readFirstEmbeddedFile(fsys embed.FS) ([]byte, error) {
	entries, err := fsys.ReadDir("setup")
	if err != nil {
		return nil, fmt.Errorf("reading embedded directory: %w", err)
	}
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasPrefix(entry.Name(), "openapi.") {
			return fsys.ReadFile(path.Join("setup", entry.Name()))
		}
	}
	return nil, errors.New("no openapi spec file found in embedded filesystem")
}

// ============================================================================
// Service Handler
// ============================================================================

// serviceHandler wraps the chi router and service to implement api.Handler.
type serviceHandler struct {
	router   chi.Router
	service  ServiceInterface
	gen      generator.Generate
	registry typedef.OperationRegistry
}

// newServiceHandler creates a new serviceHandler.
func newServiceHandler(svc ServiceInterface, gen generator.Generate, registry typedef.OperationRegistry) api.Handler {
	return &serviceHandler{
		router:   NewRouter(svc),
		service:  svc,
		gen:      gen,
		registry: registry,
	}
}

func (h *serviceHandler) Routes() api.RouteDescriptions {
	routes := h.router.Routes()
	descriptions := make(api.RouteDescriptions, 0, len(routes))
	for _, route := range routes {
		for method := range route.Handlers {
			descriptions = append(descriptions, &api.RouteDescription{
				Method: method,
				Path:   route.Pattern,
			})
		}
	}
	return descriptions
}

func (h *serviceHandler) RegisterRoutes(router chi.Router) {
	router.Mount("/", h.router)
}

func (h *serviceHandler) Generate(w http.ResponseWriter, r *http.Request) {
	var req api.GenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		slog.Error("Failed to decode request", "error", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	op := h.registry.FindOperation(req.Path, req.Method)
	res := h.gen.Request(&req, op)
	api.NewJSONResponse(w).Send(res)
}

// ============================================================================
// Generator Service (fallback to mock responses)
// ============================================================================

// generatorService implements ServiceInterface with generator fallback.
// It delegates to the user's service first; if that returns nil, it generates a mock response.
type generatorService struct {
	service   *service
	generator generator.Generate
	registry  typedef.OperationRegistry
}

// Ensure generatorService implements ServiceInterface.
var _ ServiceInterface = (*generatorService)(nil)

// SearchRecipes handles GET /recipes/complexSearch
func (s *generatorService) SearchRecipes(ctx context.Context, opts *SearchRecipesServiceRequestOptions) (*SearchRecipesResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchRecipes(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/complexSearch", "GET")
	if respSchema == nil {
		return NewSearchRecipesResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchRecipesResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchRecipesResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchRecipesByIngredients handles GET /recipes/findByIngredients
func (s *generatorService) SearchRecipesByIngredients(ctx context.Context, opts *SearchRecipesByIngredientsServiceRequestOptions) (*SearchRecipesByIngredientsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchRecipesByIngredients(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/findByIngredients", "GET")
	if respSchema == nil {
		return NewSearchRecipesByIngredientsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchRecipesByIngredientsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchRecipesByIngredientsResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchRecipesByNutrients handles GET /recipes/findByNutrients
func (s *generatorService) SearchRecipesByNutrients(ctx context.Context, opts *SearchRecipesByNutrientsServiceRequestOptions) (*SearchRecipesByNutrientsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchRecipesByNutrients(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/findByNutrients", "GET")
	if respSchema == nil {
		return NewSearchRecipesByNutrientsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchRecipesByNutrientsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchRecipesByNutrientsResponseData(&body).WithHeaders(res.Headers), nil
}

// GetRecipeInformation handles GET /recipes/{id}/information
func (s *generatorService) GetRecipeInformation(ctx context.Context, opts *GetRecipeInformationServiceRequestOptions) (*GetRecipeInformationResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRecipeInformation(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/information", "GET")
	if respSchema == nil {
		return NewGetRecipeInformationResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRecipeInformationResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRecipeInformationResponseData(&body).WithHeaders(res.Headers), nil
}

// GetRecipeInformationBulk handles GET /recipes/informationBulk
func (s *generatorService) GetRecipeInformationBulk(ctx context.Context, opts *GetRecipeInformationBulkServiceRequestOptions) (*GetRecipeInformationBulkResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRecipeInformationBulk(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/informationBulk", "GET")
	if respSchema == nil {
		return NewGetRecipeInformationBulkResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRecipeInformationBulkResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRecipeInformationBulkResponseData(&body).WithHeaders(res.Headers), nil
}

// GetSimilarRecipes handles GET /recipes/{id}/similar
func (s *generatorService) GetSimilarRecipes(ctx context.Context, opts *GetSimilarRecipesServiceRequestOptions) (*GetSimilarRecipesResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetSimilarRecipes(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/similar", "GET")
	if respSchema == nil {
		return NewGetSimilarRecipesResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetSimilarRecipesResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetSimilarRecipesResponseData(&body).WithHeaders(res.Headers), nil
}

// GetRandomRecipes handles GET /recipes/random
func (s *generatorService) GetRandomRecipes(ctx context.Context, opts *GetRandomRecipesServiceRequestOptions) (*GetRandomRecipesResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRandomRecipes(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/random", "GET")
	if respSchema == nil {
		return NewGetRandomRecipesResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRandomRecipesResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRandomRecipesResponseData(&body).WithHeaders(res.Headers), nil
}

// AutocompleteRecipeSearch handles GET /recipes/autocomplete
func (s *generatorService) AutocompleteRecipeSearch(ctx context.Context, opts *AutocompleteRecipeSearchServiceRequestOptions) (*AutocompleteRecipeSearchResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AutocompleteRecipeSearch(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/autocomplete", "GET")
	if respSchema == nil {
		return NewAutocompleteRecipeSearchResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AutocompleteRecipeSearchResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAutocompleteRecipeSearchResponseData(&body).WithHeaders(res.Headers), nil
}

// GetRecipeTasteByID handles GET /recipes/{id}/tasteWidget.json
func (s *generatorService) GetRecipeTasteByID(ctx context.Context, opts *GetRecipeTasteByIDServiceRequestOptions) (*GetRecipeTasteByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRecipeTasteByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/tasteWidget.json", "GET")
	if respSchema == nil {
		return NewGetRecipeTasteByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRecipeTasteByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRecipeTasteByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// RecipeTasteByIDImage handles GET /recipes/{id}/tasteWidget.png
func (s *generatorService) RecipeTasteByIDImage(ctx context.Context, opts *RecipeTasteByIDImageServiceRequestOptions) (*RecipeTasteByIDImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.RecipeTasteByIDImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/tasteWidget.png", "GET")
	if respSchema == nil {
		return NewRecipeTasteByIDImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewRecipeTasteByIDImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetRecipeEquipmentByID handles GET /recipes/{id}/equipmentWidget.json
func (s *generatorService) GetRecipeEquipmentByID(ctx context.Context, opts *GetRecipeEquipmentByIDServiceRequestOptions) (*GetRecipeEquipmentByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRecipeEquipmentByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/equipmentWidget.json", "GET")
	if respSchema == nil {
		return NewGetRecipeEquipmentByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRecipeEquipmentByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRecipeEquipmentByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// EquipmentByIDImage handles GET /recipes/{id}/equipmentWidget.png
func (s *generatorService) EquipmentByIDImage(ctx context.Context, opts *EquipmentByIDImageServiceRequestOptions) (*EquipmentByIDImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.EquipmentByIDImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/equipmentWidget.png", "GET")
	if respSchema == nil {
		return NewEquipmentByIDImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewEquipmentByIDImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetRecipePriceBreakdownByID handles GET /recipes/{id}/priceBreakdownWidget.json
func (s *generatorService) GetRecipePriceBreakdownByID(ctx context.Context, opts *GetRecipePriceBreakdownByIDServiceRequestOptions) (*GetRecipePriceBreakdownByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRecipePriceBreakdownByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/priceBreakdownWidget.json", "GET")
	if respSchema == nil {
		return NewGetRecipePriceBreakdownByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRecipePriceBreakdownByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRecipePriceBreakdownByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// PriceBreakdownByIDImage handles GET /recipes/{id}/priceBreakdownWidget.png
func (s *generatorService) PriceBreakdownByIDImage(ctx context.Context, opts *PriceBreakdownByIDImageServiceRequestOptions) (*PriceBreakdownByIDImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.PriceBreakdownByIDImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/priceBreakdownWidget.png", "GET")
	if respSchema == nil {
		return NewPriceBreakdownByIDImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewPriceBreakdownByIDImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetRecipeIngredientsByID handles GET /recipes/{id}/ingredientWidget.json
func (s *generatorService) GetRecipeIngredientsByID(ctx context.Context, opts *GetRecipeIngredientsByIDServiceRequestOptions) (*GetRecipeIngredientsByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRecipeIngredientsByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/ingredientWidget.json", "GET")
	if respSchema == nil {
		return NewGetRecipeIngredientsByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRecipeIngredientsByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRecipeIngredientsByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// IngredientsByIDImage handles GET /recipes/{id}/ingredientWidget.png
func (s *generatorService) IngredientsByIDImage(ctx context.Context, opts *IngredientsByIDImageServiceRequestOptions) (*IngredientsByIDImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.IngredientsByIDImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/ingredientWidget.png", "GET")
	if respSchema == nil {
		return NewIngredientsByIDImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewIngredientsByIDImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetRecipeNutritionWidgetByID handles GET /recipes/{id}/nutritionWidget.json
func (s *generatorService) GetRecipeNutritionWidgetByID(ctx context.Context, opts *GetRecipeNutritionWidgetByIDServiceRequestOptions) (*GetRecipeNutritionWidgetByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRecipeNutritionWidgetByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/nutritionWidget.json", "GET")
	if respSchema == nil {
		return NewGetRecipeNutritionWidgetByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRecipeNutritionWidgetByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRecipeNutritionWidgetByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// RecipeNutritionByIDImage handles GET /recipes/{id}/nutritionWidget.png
func (s *generatorService) RecipeNutritionByIDImage(ctx context.Context, opts *RecipeNutritionByIDImageServiceRequestOptions) (*RecipeNutritionByIDImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.RecipeNutritionByIDImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/nutritionWidget.png", "GET")
	if respSchema == nil {
		return NewRecipeNutritionByIDImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewRecipeNutritionByIDImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// RecipeNutritionLabelWidget handles GET /recipes/{id}/nutritionLabel
func (s *generatorService) RecipeNutritionLabelWidget(ctx context.Context, opts *RecipeNutritionLabelWidgetServiceRequestOptions) (*RecipeNutritionLabelWidgetResponseData, error) {
	// Call user's service first
	if resp, err := s.service.RecipeNutritionLabelWidget(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/nutritionLabel", "GET")
	if respSchema == nil {
		return NewRecipeNutritionLabelWidgetResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body RecipeNutritionLabelWidgetResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewRecipeNutritionLabelWidgetResponseData(&body).WithHeaders(res.Headers), nil
}

// RecipeNutritionLabelImage handles GET /recipes/{id}/nutritionLabel.png
func (s *generatorService) RecipeNutritionLabelImage(ctx context.Context, opts *RecipeNutritionLabelImageServiceRequestOptions) (*RecipeNutritionLabelImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.RecipeNutritionLabelImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/nutritionLabel.png", "GET")
	if respSchema == nil {
		return NewRecipeNutritionLabelImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewRecipeNutritionLabelImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetAnalyzedRecipeInstructions handles GET /recipes/{id}/analyzedInstructions
func (s *generatorService) GetAnalyzedRecipeInstructions(ctx context.Context, opts *GetAnalyzedRecipeInstructionsServiceRequestOptions) (*GetAnalyzedRecipeInstructionsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetAnalyzedRecipeInstructions(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/analyzedInstructions", "GET")
	if respSchema == nil {
		return NewGetAnalyzedRecipeInstructionsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetAnalyzedRecipeInstructionsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetAnalyzedRecipeInstructionsResponseData(&body).WithHeaders(res.Headers), nil
}

// ExtractRecipeFromWebsite handles GET /recipes/extract
func (s *generatorService) ExtractRecipeFromWebsite(ctx context.Context, opts *ExtractRecipeFromWebsiteServiceRequestOptions) (*ExtractRecipeFromWebsiteResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ExtractRecipeFromWebsite(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/extract", "GET")
	if respSchema == nil {
		return NewExtractRecipeFromWebsiteResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ExtractRecipeFromWebsiteResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewExtractRecipeFromWebsiteResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeRecipeIngredientsByID handles GET /recipes/{id}/ingredientWidget
func (s *generatorService) VisualizeRecipeIngredientsByID(ctx context.Context, opts *VisualizeRecipeIngredientsByIDServiceRequestOptions) (*VisualizeRecipeIngredientsByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeRecipeIngredientsByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/ingredientWidget", "GET")
	if respSchema == nil {
		return NewVisualizeRecipeIngredientsByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeRecipeIngredientsByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeRecipeIngredientsByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeRecipeTasteByID handles GET /recipes/{id}/tasteWidget
func (s *generatorService) VisualizeRecipeTasteByID(ctx context.Context, opts *VisualizeRecipeTasteByIDServiceRequestOptions) (*VisualizeRecipeTasteByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeRecipeTasteByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/tasteWidget", "GET")
	if respSchema == nil {
		return NewVisualizeRecipeTasteByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeRecipeTasteByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeRecipeTasteByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeRecipeEquipmentByID handles GET /recipes/{id}/equipmentWidget
func (s *generatorService) VisualizeRecipeEquipmentByID(ctx context.Context, opts *VisualizeRecipeEquipmentByIDServiceRequestOptions) (*VisualizeRecipeEquipmentByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeRecipeEquipmentByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/equipmentWidget", "GET")
	if respSchema == nil {
		return NewVisualizeRecipeEquipmentByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeRecipeEquipmentByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeRecipeEquipmentByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeRecipePriceBreakdownByID handles GET /recipes/{id}/priceBreakdownWidget
func (s *generatorService) VisualizeRecipePriceBreakdownByID(ctx context.Context, opts *VisualizeRecipePriceBreakdownByIDServiceRequestOptions) (*VisualizeRecipePriceBreakdownByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeRecipePriceBreakdownByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/priceBreakdownWidget", "GET")
	if respSchema == nil {
		return NewVisualizeRecipePriceBreakdownByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeRecipePriceBreakdownByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeRecipePriceBreakdownByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeRecipeTaste handles POST /recipes/visualizeTaste
func (s *generatorService) VisualizeRecipeTaste(ctx context.Context, opts *VisualizeRecipeTasteServiceRequestOptions) (*VisualizeRecipeTasteResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeRecipeTaste(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/visualizeTaste", "POST")
	if respSchema == nil {
		return NewVisualizeRecipeTasteResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeRecipeTasteResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeRecipeTasteResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeRecipeNutrition handles POST /recipes/visualizeNutrition
func (s *generatorService) VisualizeRecipeNutrition(ctx context.Context, opts *VisualizeRecipeNutritionServiceRequestOptions) (*VisualizeRecipeNutritionResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeRecipeNutrition(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/visualizeNutrition", "POST")
	if respSchema == nil {
		return NewVisualizeRecipeNutritionResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeRecipeNutritionResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeRecipeNutritionResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizePriceBreakdown handles POST /recipes/visualizePriceEstimator
func (s *generatorService) VisualizePriceBreakdown(ctx context.Context, opts *VisualizePriceBreakdownServiceRequestOptions) (*VisualizePriceBreakdownResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizePriceBreakdown(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/visualizePriceEstimator", "POST")
	if respSchema == nil {
		return NewVisualizePriceBreakdownResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizePriceBreakdownResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizePriceBreakdownResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeEquipment handles POST /recipes/visualizeEquipment
func (s *generatorService) VisualizeEquipment(ctx context.Context, opts *VisualizeEquipmentServiceRequestOptions) (*VisualizeEquipmentResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeEquipment(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/visualizeEquipment", "POST")
	if respSchema == nil {
		return NewVisualizeEquipmentResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeEquipmentResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeEquipmentResponseData(&body).WithHeaders(res.Headers), nil
}

// AnalyzeRecipe handles POST /recipes/analyze
func (s *generatorService) AnalyzeRecipe(ctx context.Context, opts *AnalyzeRecipeServiceRequestOptions) (*AnalyzeRecipeResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AnalyzeRecipe(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/analyze", "POST")
	if respSchema == nil {
		return NewAnalyzeRecipeResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AnalyzeRecipeResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAnalyzeRecipeResponseData(&body).WithHeaders(res.Headers), nil
}

// SummarizeRecipe handles GET /recipes/{id}/summary
func (s *generatorService) SummarizeRecipe(ctx context.Context, opts *SummarizeRecipeServiceRequestOptions) (*SummarizeRecipeResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SummarizeRecipe(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/summary", "GET")
	if respSchema == nil {
		return NewSummarizeRecipeResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SummarizeRecipeResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSummarizeRecipeResponseData(&body).WithHeaders(res.Headers), nil
}

// CreateRecipeCardGet handles GET /recipes/{id}/card
func (s *generatorService) CreateRecipeCardGet(ctx context.Context, opts *CreateRecipeCardGetServiceRequestOptions) (*CreateRecipeCardGetResponseData, error) {
	// Call user's service first
	if resp, err := s.service.CreateRecipeCardGet(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/card", "GET")
	if respSchema == nil {
		return NewCreateRecipeCardGetResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body CreateRecipeCardGetResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewCreateRecipeCardGetResponseData(&body).WithHeaders(res.Headers), nil
}

// CreateRecipeCard handles POST /recipes/visualizeRecipe
func (s *generatorService) CreateRecipeCard(ctx context.Context, opts *CreateRecipeCardServiceRequestOptions) (*CreateRecipeCardResponseData, error) {
	// Call user's service first
	if resp, err := s.service.CreateRecipeCard(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/visualizeRecipe", "POST")
	if respSchema == nil {
		return NewCreateRecipeCardResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body CreateRecipeCardResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewCreateRecipeCardResponseData(&body).WithHeaders(res.Headers), nil
}

// AnalyzeRecipeInstructions handles POST /recipes/analyzeInstructions
func (s *generatorService) AnalyzeRecipeInstructions(ctx context.Context, opts *AnalyzeRecipeInstructionsServiceRequestOptions) (*AnalyzeRecipeInstructionsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AnalyzeRecipeInstructions(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/analyzeInstructions", "POST")
	if respSchema == nil {
		return NewAnalyzeRecipeInstructionsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AnalyzeRecipeInstructionsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAnalyzeRecipeInstructionsResponseData(&body).WithHeaders(res.Headers), nil
}

// ClassifyCuisine handles POST /recipes/cuisine
func (s *generatorService) ClassifyCuisine(ctx context.Context, opts *ClassifyCuisineServiceRequestOptions) (*ClassifyCuisineResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ClassifyCuisine(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/cuisine", "POST")
	if respSchema == nil {
		return NewClassifyCuisineResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ClassifyCuisineResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewClassifyCuisineResponseData(&body).WithHeaders(res.Headers), nil
}

// AnalyzeARecipeSearchQuery handles GET /recipes/queries/analyze
func (s *generatorService) AnalyzeARecipeSearchQuery(ctx context.Context, opts *AnalyzeARecipeSearchQueryServiceRequestOptions) (*AnalyzeARecipeSearchQueryResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AnalyzeARecipeSearchQuery(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/queries/analyze", "GET")
	if respSchema == nil {
		return NewAnalyzeARecipeSearchQueryResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AnalyzeARecipeSearchQueryResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAnalyzeARecipeSearchQueryResponseData(&body).WithHeaders(res.Headers), nil
}

// ConvertAmounts handles GET /recipes/convert
func (s *generatorService) ConvertAmounts(ctx context.Context, opts *ConvertAmountsServiceRequestOptions) (*ConvertAmountsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ConvertAmounts(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/convert", "GET")
	if respSchema == nil {
		return NewConvertAmountsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ConvertAmountsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewConvertAmountsResponseData(&body).WithHeaders(res.Headers), nil
}

// ParseIngredients handles POST /recipes/parseIngredients
func (s *generatorService) ParseIngredients(ctx context.Context, opts *ParseIngredientsServiceRequestOptions) (*ParseIngredientsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ParseIngredients(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/parseIngredients", "POST")
	if respSchema == nil {
		return NewParseIngredientsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ParseIngredientsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewParseIngredientsResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeRecipeNutritionByID handles GET /recipes/{id}/nutritionWidget
func (s *generatorService) VisualizeRecipeNutritionByID(ctx context.Context, opts *VisualizeRecipeNutritionByIDServiceRequestOptions) (*VisualizeRecipeNutritionByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeRecipeNutritionByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/{id}/nutritionWidget", "GET")
	if respSchema == nil {
		return NewVisualizeRecipeNutritionByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeRecipeNutritionByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeRecipeNutritionByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeIngredients handles POST /recipes/visualizeIngredients
func (s *generatorService) VisualizeIngredients(ctx context.Context, opts *VisualizeIngredientsServiceRequestOptions) (*VisualizeIngredientsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeIngredients(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/visualizeIngredients", "POST")
	if respSchema == nil {
		return NewVisualizeIngredientsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeIngredientsResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeIngredientsResponseData(&body).WithHeaders(res.Headers), nil
}

// GuessNutritionByDishName handles GET /recipes/guessNutrition
func (s *generatorService) GuessNutritionByDishName(ctx context.Context, opts *GuessNutritionByDishNameServiceRequestOptions) (*GuessNutritionByDishNameResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GuessNutritionByDishName(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/guessNutrition", "GET")
	if respSchema == nil {
		return NewGuessNutritionByDishNameResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GuessNutritionByDishNameResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGuessNutritionByDishNameResponseData(&body).WithHeaders(res.Headers), nil
}

// GetIngredientInformation handles GET /food/ingredients/{id}/information
func (s *generatorService) GetIngredientInformation(ctx context.Context, opts *GetIngredientInformationServiceRequestOptions) (*GetIngredientInformationResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetIngredientInformation(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/ingredients/{id}/information", "GET")
	if respSchema == nil {
		return NewGetIngredientInformationResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetIngredientInformationResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetIngredientInformationResponseData(&body).WithHeaders(res.Headers), nil
}

// ComputeIngredientAmount handles GET /food/ingredients/{id}/amount
func (s *generatorService) ComputeIngredientAmount(ctx context.Context, opts *ComputeIngredientAmountServiceRequestOptions) (*ComputeIngredientAmountResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ComputeIngredientAmount(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/ingredients/{id}/amount", "GET")
	if respSchema == nil {
		return NewComputeIngredientAmountResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ComputeIngredientAmountResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewComputeIngredientAmountResponseData(&body).WithHeaders(res.Headers), nil
}

// ComputeGlycemicLoad handles POST /food/ingredients/glycemicLoad
func (s *generatorService) ComputeGlycemicLoad(ctx context.Context, opts *ComputeGlycemicLoadServiceRequestOptions) (*ComputeGlycemicLoadResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ComputeGlycemicLoad(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/ingredients/glycemicLoad", "POST")
	if respSchema == nil {
		return NewComputeGlycemicLoadResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ComputeGlycemicLoadResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewComputeGlycemicLoadResponseData(&body).WithHeaders(res.Headers), nil
}

// AutocompleteIngredientSearch handles GET /food/ingredients/autocomplete
func (s *generatorService) AutocompleteIngredientSearch(ctx context.Context, opts *AutocompleteIngredientSearchServiceRequestOptions) (*AutocompleteIngredientSearchResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AutocompleteIngredientSearch(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/ingredients/autocomplete", "GET")
	if respSchema == nil {
		return NewAutocompleteIngredientSearchResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AutocompleteIngredientSearchResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAutocompleteIngredientSearchResponseData(&body).WithHeaders(res.Headers), nil
}

// IngredientSearch handles GET /food/ingredients/search
func (s *generatorService) IngredientSearch(ctx context.Context, opts *IngredientSearchServiceRequestOptions) (*IngredientSearchResponseData, error) {
	// Call user's service first
	if resp, err := s.service.IngredientSearch(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/ingredients/search", "GET")
	if respSchema == nil {
		return NewIngredientSearchResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body IngredientSearchResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewIngredientSearchResponseData(&body).WithHeaders(res.Headers), nil
}

// GetIngredientSubstitutes handles GET /food/ingredients/substitutes
func (s *generatorService) GetIngredientSubstitutes(ctx context.Context, opts *GetIngredientSubstitutesServiceRequestOptions) (*GetIngredientSubstitutesResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetIngredientSubstitutes(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/ingredients/substitutes", "GET")
	if respSchema == nil {
		return NewGetIngredientSubstitutesResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetIngredientSubstitutesResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetIngredientSubstitutesResponseData(&body).WithHeaders(res.Headers), nil
}

// GetIngredientSubstitutesByID handles GET /food/ingredients/{id}/substitutes
func (s *generatorService) GetIngredientSubstitutesByID(ctx context.Context, opts *GetIngredientSubstitutesByIDServiceRequestOptions) (*GetIngredientSubstitutesByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetIngredientSubstitutesByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/ingredients/{id}/substitutes", "GET")
	if respSchema == nil {
		return NewGetIngredientSubstitutesByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetIngredientSubstitutesByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetIngredientSubstitutesByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchGroceryProducts handles GET /food/products/search
func (s *generatorService) SearchGroceryProducts(ctx context.Context, opts *SearchGroceryProductsServiceRequestOptions) (*SearchGroceryProductsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchGroceryProducts(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/search", "GET")
	if respSchema == nil {
		return NewSearchGroceryProductsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchGroceryProductsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchGroceryProductsResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchGroceryProductsByUPC handles GET /food/products/upc/{upc}
func (s *generatorService) SearchGroceryProductsByUPC(ctx context.Context, opts *SearchGroceryProductsByUPCServiceRequestOptions) (*SearchGroceryProductsByUPCResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchGroceryProductsByUPC(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/upc/{upc}", "GET")
	if respSchema == nil {
		return NewSearchGroceryProductsByUPCResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchGroceryProductsByUPCResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchGroceryProductsByUPCResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchCustomFoods handles GET /food/customFoods/search
func (s *generatorService) SearchCustomFoods(ctx context.Context, opts *SearchCustomFoodsServiceRequestOptions) (*SearchCustomFoodsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchCustomFoods(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/customFoods/search", "GET")
	if respSchema == nil {
		return NewSearchCustomFoodsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchCustomFoodsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchCustomFoodsResponseData(&body).WithHeaders(res.Headers), nil
}

// GetProductInformation handles GET /food/products/{id}
func (s *generatorService) GetProductInformation(ctx context.Context, opts *GetProductInformationServiceRequestOptions) (*GetProductInformationResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetProductInformation(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/{id}", "GET")
	if respSchema == nil {
		return NewGetProductInformationResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetProductInformationResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetProductInformationResponseData(&body).WithHeaders(res.Headers), nil
}

// GetComparableProducts handles GET /food/products/upc/{upc}/comparable
func (s *generatorService) GetComparableProducts(ctx context.Context, opts *GetComparableProductsServiceRequestOptions) (*GetComparableProductsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetComparableProducts(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/upc/{upc}/comparable", "GET")
	if respSchema == nil {
		return NewGetComparableProductsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetComparableProductsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetComparableProductsResponseData(&body).WithHeaders(res.Headers), nil
}

// AutocompleteProductSearch handles GET /food/products/suggest
func (s *generatorService) AutocompleteProductSearch(ctx context.Context, opts *AutocompleteProductSearchServiceRequestOptions) (*AutocompleteProductSearchResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AutocompleteProductSearch(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/suggest", "GET")
	if respSchema == nil {
		return NewAutocompleteProductSearchResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AutocompleteProductSearchResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAutocompleteProductSearchResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeProductNutritionByID handles GET /food/products/{id}/nutritionWidget
func (s *generatorService) VisualizeProductNutritionByID(ctx context.Context, opts *VisualizeProductNutritionByIDServiceRequestOptions) (*VisualizeProductNutritionByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeProductNutritionByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/{id}/nutritionWidget", "GET")
	if respSchema == nil {
		return NewVisualizeProductNutritionByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeProductNutritionByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeProductNutritionByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// ProductNutritionByIDImage handles GET /food/products/{id}/nutritionWidget.png
func (s *generatorService) ProductNutritionByIDImage(ctx context.Context, opts *ProductNutritionByIDImageServiceRequestOptions) (*ProductNutritionByIDImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ProductNutritionByIDImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/{id}/nutritionWidget.png", "GET")
	if respSchema == nil {
		return NewProductNutritionByIDImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewProductNutritionByIDImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// ProductNutritionLabelWidget handles GET /food/products/{id}/nutritionLabel
func (s *generatorService) ProductNutritionLabelWidget(ctx context.Context, opts *ProductNutritionLabelWidgetServiceRequestOptions) (*ProductNutritionLabelWidgetResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ProductNutritionLabelWidget(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/{id}/nutritionLabel", "GET")
	if respSchema == nil {
		return NewProductNutritionLabelWidgetResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ProductNutritionLabelWidgetResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewProductNutritionLabelWidgetResponseData(&body).WithHeaders(res.Headers), nil
}

// ProductNutritionLabelImage handles GET /food/products/{id}/nutritionLabel.png
func (s *generatorService) ProductNutritionLabelImage(ctx context.Context, opts *ProductNutritionLabelImageServiceRequestOptions) (*ProductNutritionLabelImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ProductNutritionLabelImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/{id}/nutritionLabel.png", "GET")
	if respSchema == nil {
		return NewProductNutritionLabelImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewProductNutritionLabelImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// ClassifyGroceryProduct handles POST /food/products/classify
func (s *generatorService) ClassifyGroceryProduct(ctx context.Context, opts *ClassifyGroceryProductServiceRequestOptions) (*ClassifyGroceryProductResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ClassifyGroceryProduct(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/classify", "POST")
	if respSchema == nil {
		return NewClassifyGroceryProductResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ClassifyGroceryProductResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewClassifyGroceryProductResponseData(&body).WithHeaders(res.Headers), nil
}

// ClassifyGroceryProductBulk handles POST /food/products/classifyBatch
func (s *generatorService) ClassifyGroceryProductBulk(ctx context.Context, opts *ClassifyGroceryProductBulkServiceRequestOptions) (*ClassifyGroceryProductBulkResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ClassifyGroceryProductBulk(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/products/classifyBatch", "POST")
	if respSchema == nil {
		return NewClassifyGroceryProductBulkResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ClassifyGroceryProductBulkResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewClassifyGroceryProductBulkResponseData(&body).WithHeaders(res.Headers), nil
}

// MapIngredientsToGroceryProducts handles POST /food/ingredients/map
func (s *generatorService) MapIngredientsToGroceryProducts(ctx context.Context, opts *MapIngredientsToGroceryProductsServiceRequestOptions) (*MapIngredientsToGroceryProductsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.MapIngredientsToGroceryProducts(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/ingredients/map", "POST")
	if respSchema == nil {
		return NewMapIngredientsToGroceryProductsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body MapIngredientsToGroceryProductsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewMapIngredientsToGroceryProductsResponseData(&body).WithHeaders(res.Headers), nil
}

// AutocompleteMenuItemSearch handles GET /food/menuItems/suggest
func (s *generatorService) AutocompleteMenuItemSearch(ctx context.Context, opts *AutocompleteMenuItemSearchServiceRequestOptions) (*AutocompleteMenuItemSearchResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AutocompleteMenuItemSearch(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/menuItems/suggest", "GET")
	if respSchema == nil {
		return NewAutocompleteMenuItemSearchResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AutocompleteMenuItemSearchResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAutocompleteMenuItemSearchResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchMenuItems handles GET /food/menuItems/search
func (s *generatorService) SearchMenuItems(ctx context.Context, opts *SearchMenuItemsServiceRequestOptions) (*SearchMenuItemsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchMenuItems(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/menuItems/search", "GET")
	if respSchema == nil {
		return NewSearchMenuItemsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchMenuItemsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchMenuItemsResponseData(&body).WithHeaders(res.Headers), nil
}

// GetMenuItemInformation handles GET /food/menuItems/{id}
func (s *generatorService) GetMenuItemInformation(ctx context.Context, opts *GetMenuItemInformationServiceRequestOptions) (*GetMenuItemInformationResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetMenuItemInformation(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/menuItems/{id}", "GET")
	if respSchema == nil {
		return NewGetMenuItemInformationResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetMenuItemInformationResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetMenuItemInformationResponseData(&body).WithHeaders(res.Headers), nil
}

// VisualizeMenuItemNutritionByID handles GET /food/menuItems/{id}/nutritionWidget
func (s *generatorService) VisualizeMenuItemNutritionByID(ctx context.Context, opts *VisualizeMenuItemNutritionByIDServiceRequestOptions) (*VisualizeMenuItemNutritionByIDResponseData, error) {
	// Call user's service first
	if resp, err := s.service.VisualizeMenuItemNutritionByID(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/menuItems/{id}/nutritionWidget", "GET")
	if respSchema == nil {
		return NewVisualizeMenuItemNutritionByIDResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body VisualizeMenuItemNutritionByIDResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewVisualizeMenuItemNutritionByIDResponseData(&body).WithHeaders(res.Headers), nil
}

// MenuItemNutritionByIDImage handles GET /food/menuItems/{id}/nutritionWidget.png
func (s *generatorService) MenuItemNutritionByIDImage(ctx context.Context, opts *MenuItemNutritionByIDImageServiceRequestOptions) (*MenuItemNutritionByIDImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.MenuItemNutritionByIDImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/menuItems/{id}/nutritionWidget.png", "GET")
	if respSchema == nil {
		return NewMenuItemNutritionByIDImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewMenuItemNutritionByIDImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// MenuItemNutritionLabelWidget handles GET /food/menuItems/{id}/nutritionLabel
func (s *generatorService) MenuItemNutritionLabelWidget(ctx context.Context, opts *MenuItemNutritionLabelWidgetServiceRequestOptions) (*MenuItemNutritionLabelWidgetResponseData, error) {
	// Call user's service first
	if resp, err := s.service.MenuItemNutritionLabelWidget(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/menuItems/{id}/nutritionLabel", "GET")
	if respSchema == nil {
		return NewMenuItemNutritionLabelWidgetResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body MenuItemNutritionLabelWidgetResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html", &body); err != nil {
		return nil, err
	}
	return NewMenuItemNutritionLabelWidgetResponseData(&body).WithHeaders(res.Headers), nil
}

// MenuItemNutritionLabelImage handles GET /food/menuItems/{id}/nutritionLabel.png
func (s *generatorService) MenuItemNutritionLabelImage(ctx context.Context, opts *MenuItemNutritionLabelImageServiceRequestOptions) (*MenuItemNutritionLabelImageResponseData, error) {
	// Call user's service first
	if resp, err := s.service.MenuItemNutritionLabelImage(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/menuItems/{id}/nutritionLabel.png", "GET")
	if respSchema == nil {
		return NewMenuItemNutritionLabelImageResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewMenuItemNutritionLabelImageResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GenerateMealPlan handles GET /mealplanner/generate
func (s *generatorService) GenerateMealPlan(ctx context.Context, opts *GenerateMealPlanServiceRequestOptions) (*GenerateMealPlanResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GenerateMealPlan(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/generate", "GET")
	if respSchema == nil {
		return NewGenerateMealPlanResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GenerateMealPlanResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGenerateMealPlanResponseData(&body).WithHeaders(res.Headers), nil
}

// GetMealPlanWeek handles GET /mealplanner/{username}/week/{start-date}
func (s *generatorService) GetMealPlanWeek(ctx context.Context, opts *GetMealPlanWeekServiceRequestOptions) (*GetMealPlanWeekResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetMealPlanWeek(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/week/{start-date}", "GET")
	if respSchema == nil {
		return NewGetMealPlanWeekResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetMealPlanWeekResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetMealPlanWeekResponseData(&body).WithHeaders(res.Headers), nil
}

// ClearMealPlanDay handles DELETE /mealplanner/{username}/day/{date}
func (s *generatorService) ClearMealPlanDay(ctx context.Context, opts *ClearMealPlanDayServiceRequestOptions) (*ClearMealPlanDayResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ClearMealPlanDay(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/day/{date}", "DELETE")
	if respSchema == nil {
		return NewClearMealPlanDayResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ClearMealPlanDayResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewClearMealPlanDayResponseData(&body).WithHeaders(res.Headers), nil
}

// AddToMealPlan handles POST /mealplanner/{username}/items
func (s *generatorService) AddToMealPlan(ctx context.Context, opts *AddToMealPlanServiceRequestOptions) (*AddToMealPlanResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AddToMealPlan(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/items", "POST")
	if respSchema == nil {
		return NewAddToMealPlanResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AddToMealPlanResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAddToMealPlanResponseData(&body).WithHeaders(res.Headers), nil
}

// DeleteFromMealPlan handles DELETE /mealplanner/{username}/items/{id}
func (s *generatorService) DeleteFromMealPlan(ctx context.Context, opts *DeleteFromMealPlanServiceRequestOptions) (*DeleteFromMealPlanResponseData, error) {
	// Call user's service first
	if resp, err := s.service.DeleteFromMealPlan(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/items/{id}", "DELETE")
	if respSchema == nil {
		return NewDeleteFromMealPlanResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body DeleteFromMealPlanResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewDeleteFromMealPlanResponseData(&body).WithHeaders(res.Headers), nil
}

// GetMealPlanTemplates handles GET /mealplanner/{username}/templates
func (s *generatorService) GetMealPlanTemplates(ctx context.Context, opts *GetMealPlanTemplatesServiceRequestOptions) (*GetMealPlanTemplatesResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetMealPlanTemplates(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/templates", "GET")
	if respSchema == nil {
		return NewGetMealPlanTemplatesResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetMealPlanTemplatesResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetMealPlanTemplatesResponseData(&body).WithHeaders(res.Headers), nil
}

// AddMealPlanTemplate handles POST /mealplanner/{username}/templates
func (s *generatorService) AddMealPlanTemplate(ctx context.Context, opts *AddMealPlanTemplateServiceRequestOptions) (*AddMealPlanTemplateResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AddMealPlanTemplate(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/templates", "POST")
	if respSchema == nil {
		return NewAddMealPlanTemplateResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AddMealPlanTemplateResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAddMealPlanTemplateResponseData(&body).WithHeaders(res.Headers), nil
}

// GetMealPlanTemplate handles GET /mealplanner/{username}/templates/{id}
func (s *generatorService) GetMealPlanTemplate(ctx context.Context, opts *GetMealPlanTemplateServiceRequestOptions) (*GetMealPlanTemplateResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetMealPlanTemplate(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/templates/{id}", "GET")
	if respSchema == nil {
		return NewGetMealPlanTemplateResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetMealPlanTemplateResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetMealPlanTemplateResponseData(&body).WithHeaders(res.Headers), nil
}

// DeleteMealPlanTemplate handles DELETE /mealplanner/{username}/templates/{id}
func (s *generatorService) DeleteMealPlanTemplate(ctx context.Context, opts *DeleteMealPlanTemplateServiceRequestOptions) (*DeleteMealPlanTemplateResponseData, error) {
	// Call user's service first
	if resp, err := s.service.DeleteMealPlanTemplate(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/templates/{id}", "DELETE")
	if respSchema == nil {
		return NewDeleteMealPlanTemplateResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body DeleteMealPlanTemplateResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewDeleteMealPlanTemplateResponseData(&body).WithHeaders(res.Headers), nil
}

// GetShoppingList handles GET /mealplanner/{username}/shopping-list
func (s *generatorService) GetShoppingList(ctx context.Context, opts *GetShoppingListServiceRequestOptions) (*GetShoppingListResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetShoppingList(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/shopping-list", "GET")
	if respSchema == nil {
		return NewGetShoppingListResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetShoppingListResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetShoppingListResponseData(&body).WithHeaders(res.Headers), nil
}

// GenerateShoppingList handles POST /mealplanner/{username}/shopping-list/{start-date}/{end-date}
func (s *generatorService) GenerateShoppingList(ctx context.Context, opts *GenerateShoppingListServiceRequestOptions) (*GenerateShoppingListResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GenerateShoppingList(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/shopping-list/{start-date}/{end-date}", "POST")
	if respSchema == nil {
		return NewGenerateShoppingListResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GenerateShoppingListResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGenerateShoppingListResponseData(&body).WithHeaders(res.Headers), nil
}

// ConnectUser handles POST /users/connect
func (s *generatorService) ConnectUser(ctx context.Context, opts *ConnectUserServiceRequestOptions) (*ConnectUserResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ConnectUser(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/connect", "POST")
	if respSchema == nil {
		return NewConnectUserResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ConnectUserResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewConnectUserResponseData(&body).WithHeaders(res.Headers), nil
}

// AddToShoppingList handles POST /mealplanner/{username}/shopping-list/items
func (s *generatorService) AddToShoppingList(ctx context.Context, opts *AddToShoppingListServiceRequestOptions) (*AddToShoppingListResponseData, error) {
	// Call user's service first
	if resp, err := s.service.AddToShoppingList(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/shopping-list/items", "POST")
	if respSchema == nil {
		return NewAddToShoppingListResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body AddToShoppingListResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewAddToShoppingListResponseData(&body).WithHeaders(res.Headers), nil
}

// DeleteFromShoppingList handles DELETE /mealplanner/{username}/shopping-list/items/{id}
func (s *generatorService) DeleteFromShoppingList(ctx context.Context, opts *DeleteFromShoppingListServiceRequestOptions) (*DeleteFromShoppingListResponseData, error) {
	// Call user's service first
	if resp, err := s.service.DeleteFromShoppingList(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/mealplanner/{username}/shopping-list/items/{id}", "DELETE")
	if respSchema == nil {
		return NewDeleteFromShoppingListResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body DeleteFromShoppingListResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewDeleteFromShoppingListResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchRestaurants handles GET /food/restaurants/search
func (s *generatorService) SearchRestaurants(ctx context.Context, opts *SearchRestaurantsServiceRequestOptions) (*SearchRestaurantsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchRestaurants(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/restaurants/search", "GET")
	if respSchema == nil {
		return NewSearchRestaurantsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchRestaurantsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchRestaurantsResponseData(&body).WithHeaders(res.Headers), nil
}

// GetDishPairingForWine handles GET /food/wine/dishes
func (s *generatorService) GetDishPairingForWine(ctx context.Context, opts *GetDishPairingForWineServiceRequestOptions) (*GetDishPairingForWineResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetDishPairingForWine(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/wine/dishes", "GET")
	if respSchema == nil {
		return NewGetDishPairingForWineResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetDishPairingForWineResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetDishPairingForWineResponseData(&body).WithHeaders(res.Headers), nil
}

// GetWinePairing handles GET /food/wine/pairing
func (s *generatorService) GetWinePairing(ctx context.Context, opts *GetWinePairingServiceRequestOptions) (*GetWinePairingResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetWinePairing(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/wine/pairing", "GET")
	if respSchema == nil {
		return NewGetWinePairingResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetWinePairingResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetWinePairingResponseData(&body).WithHeaders(res.Headers), nil
}

// GetWineDescription handles GET /food/wine/description
func (s *generatorService) GetWineDescription(ctx context.Context, opts *GetWineDescriptionServiceRequestOptions) (*GetWineDescriptionResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetWineDescription(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/wine/description", "GET")
	if respSchema == nil {
		return NewGetWineDescriptionResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetWineDescriptionResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetWineDescriptionResponseData(&body).WithHeaders(res.Headers), nil
}

// GetWineRecommendation handles GET /food/wine/recommendation
func (s *generatorService) GetWineRecommendation(ctx context.Context, opts *GetWineRecommendationServiceRequestOptions) (*GetWineRecommendationResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetWineRecommendation(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/wine/recommendation", "GET")
	if respSchema == nil {
		return NewGetWineRecommendationResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetWineRecommendationResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetWineRecommendationResponseData(&body).WithHeaders(res.Headers), nil
}

// ImageClassificationByURL handles GET /food/images/classify
func (s *generatorService) ImageClassificationByURL(ctx context.Context, opts *ImageClassificationByURLServiceRequestOptions) (*ImageClassificationByURLResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ImageClassificationByURL(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/images/classify", "GET")
	if respSchema == nil {
		return NewImageClassificationByURLResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ImageClassificationByURLResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewImageClassificationByURLResponseData(&body).WithHeaders(res.Headers), nil
}

// ImageAnalysisByURL handles GET /food/images/analyze
func (s *generatorService) ImageAnalysisByURL(ctx context.Context, opts *ImageAnalysisByURLServiceRequestOptions) (*ImageAnalysisByURLResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ImageAnalysisByURL(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/images/analyze", "GET")
	if respSchema == nil {
		return NewImageAnalysisByURLResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ImageAnalysisByURLResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewImageAnalysisByURLResponseData(&body).WithHeaders(res.Headers), nil
}

// QuickAnswer handles GET /recipes/quickAnswer
func (s *generatorService) QuickAnswer(ctx context.Context, opts *QuickAnswerServiceRequestOptions) (*QuickAnswerResponseData, error) {
	// Call user's service first
	if resp, err := s.service.QuickAnswer(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/recipes/quickAnswer", "GET")
	if respSchema == nil {
		return NewQuickAnswerResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body QuickAnswerResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewQuickAnswerResponseData(&body).WithHeaders(res.Headers), nil
}

// DetectFoodInText handles POST /food/detect
func (s *generatorService) DetectFoodInText(ctx context.Context, opts *DetectFoodInTextServiceRequestOptions) (*DetectFoodInTextResponseData, error) {
	// Call user's service first
	if resp, err := s.service.DetectFoodInText(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/detect", "POST")
	if respSchema == nil {
		return NewDetectFoodInTextResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body DetectFoodInTextResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewDetectFoodInTextResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchSiteContent handles GET /food/site/search
func (s *generatorService) SearchSiteContent(ctx context.Context, opts *SearchSiteContentServiceRequestOptions) (*SearchSiteContentResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchSiteContent(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/site/search", "GET")
	if respSchema == nil {
		return NewSearchSiteContentResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchSiteContentResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchSiteContentResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchAllFood handles GET /food/search
func (s *generatorService) SearchAllFood(ctx context.Context, opts *SearchAllFoodServiceRequestOptions) (*SearchAllFoodResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchAllFood(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/search", "GET")
	if respSchema == nil {
		return NewSearchAllFoodResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchAllFoodResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchAllFoodResponseData(&body).WithHeaders(res.Headers), nil
}

// SearchFoodVideos handles GET /food/videos/search
func (s *generatorService) SearchFoodVideos(ctx context.Context, opts *SearchFoodVideosServiceRequestOptions) (*SearchFoodVideosResponseData, error) {
	// Call user's service first
	if resp, err := s.service.SearchFoodVideos(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/videos/search", "GET")
	if respSchema == nil {
		return NewSearchFoodVideosResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body SearchFoodVideosResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewSearchFoodVideosResponseData(&body).WithHeaders(res.Headers), nil
}

// GetARandomFoodJoke handles GET /food/jokes/random
func (s *generatorService) GetARandomFoodJoke(ctx context.Context) (*GetARandomFoodJokeResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetARandomFoodJoke(ctx); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/jokes/random", "GET")
	if respSchema == nil {
		return NewGetARandomFoodJokeResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetARandomFoodJokeResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetARandomFoodJokeResponseData(&body).WithHeaders(res.Headers), nil
}

// GetRandomFoodTrivia handles GET /food/trivia/random
func (s *generatorService) GetRandomFoodTrivia(ctx context.Context) (*GetRandomFoodTriviaResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetRandomFoodTrivia(ctx); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/trivia/random", "GET")
	if respSchema == nil {
		return NewGetRandomFoodTriviaResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetRandomFoodTriviaResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetRandomFoodTriviaResponseData(&body).WithHeaders(res.Headers), nil
}

// TalkToChatbot handles GET /food/converse
func (s *generatorService) TalkToChatbot(ctx context.Context, opts *TalkToChatbotServiceRequestOptions) (*TalkToChatbotResponseData, error) {
	// Call user's service first
	if resp, err := s.service.TalkToChatbot(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/converse", "GET")
	if respSchema == nil {
		return NewTalkToChatbotResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body TalkToChatbotResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewTalkToChatbotResponseData(&body).WithHeaders(res.Headers), nil
}

// GetConversationSuggests handles GET /food/converse/suggest
func (s *generatorService) GetConversationSuggests(ctx context.Context, opts *GetConversationSuggestsServiceRequestOptions) (*GetConversationSuggestsResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetConversationSuggests(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/food/converse/suggest", "GET")
	if respSchema == nil {
		return NewGetConversationSuggestsResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetConversationSuggestsResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewGetConversationSuggestsResponseData(&body).WithHeaders(res.Headers), nil
}

type VisualizeRecipeTasteHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
	Accept      *Accept      `json:"Accept,omitempty"`
}

type VisualizeRecipeNutritionHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
	Accept      *Accept      `json:"Accept,omitempty"`
}

type VisualizePriceBreakdownHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
	Accept      *Accept      `json:"Accept,omitempty"`
}

type VisualizeEquipmentHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
	Accept      *Accept      `json:"Accept,omitempty"`
}

type CreateRecipeCardHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
}

type AnalyzeRecipeInstructionsHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
}

type ClassifyCuisineHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
}

type ParseIngredientsHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
}

type VisualizeRecipeNutritionByIDHeaders struct {
	Accept *Accept `json:"Accept,omitempty"`
}

type VisualizeIngredientsHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
	Accept      *Accept      `json:"Accept,omitempty"`
}

type VisualizeProductNutritionByIDHeaders struct {
	Accept *Accept `json:"Accept,omitempty"`
}

type VisualizeMenuItemNutritionByIDHeaders struct {
	Accept *Accept `json:"Accept,omitempty"`
}

type DetectFoodInTextHeaders struct {
	ContentType *ContentType `json:"Content-Type,omitempty"`
}

type ID = int64

type Username = string

type GetRecipeInformationPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetRecipeInformationPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSimilarRecipesPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetSimilarRecipesPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeTasteByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetRecipeTasteByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type RecipeTasteByIDImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (r RecipeTasteByIDImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type GetRecipeEquipmentByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetRecipeEquipmentByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type EquipmentByIDImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (e EquipmentByIDImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type GetRecipePriceBreakdownByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetRecipePriceBreakdownByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type PriceBreakdownByIDImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (p PriceBreakdownByIDImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type GetRecipeIngredientsByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetRecipeIngredientsByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type IngredientsByIDImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (i IngredientsByIDImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type GetRecipeNutritionWidgetByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetRecipeNutritionWidgetByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type RecipeNutritionByIDImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (r RecipeNutritionByIDImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type RecipeNutritionLabelWidgetPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (r RecipeNutritionLabelWidgetPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type RecipeNutritionLabelImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (r RecipeNutritionLabelImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type GetAnalyzedRecipeInstructionsPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetAnalyzedRecipeInstructionsPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type VisualizeRecipeIngredientsByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (v VisualizeRecipeIngredientsByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type VisualizeRecipeTasteByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (v VisualizeRecipeTasteByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type VisualizeRecipeEquipmentByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (v VisualizeRecipeEquipmentByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type VisualizeRecipePriceBreakdownByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (v VisualizeRecipePriceBreakdownByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type SummarizeRecipePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (s SummarizeRecipePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type CreateRecipeCardGetPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (c CreateRecipeCardGetPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type VisualizeRecipeNutritionByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (v VisualizeRecipeNutritionByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type GetIngredientInformationPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetIngredientInformationPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ComputeIngredientAmountPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (c ComputeIngredientAmountPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type GetIngredientSubstitutesByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetIngredientSubstitutesByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type SearchGroceryProductsByUPCPath struct {
	Upc float32 `json:"upc" validate:"required"`
}

func (s SearchGroceryProductsByUPCPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetProductInformationPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetProductInformationPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetComparableProductsPath struct {
	Upc float32 `json:"upc" validate:"required"`
}

func (g GetComparableProductsPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type VisualizeProductNutritionByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (v VisualizeProductNutritionByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type ProductNutritionByIDImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (p ProductNutritionByIDImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ProductNutritionLabelWidgetPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (p ProductNutritionLabelWidgetPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ProductNutritionLabelImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (p ProductNutritionLabelImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type GetMenuItemInformationPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (g GetMenuItemInformationPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type VisualizeMenuItemNutritionByIDPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (v VisualizeMenuItemNutritionByIDPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type MenuItemNutritionByIDImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (m MenuItemNutritionByIDImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type MenuItemNutritionLabelWidgetPath struct {
	ID float32 `json:"id" validate:"required"`
}

func (m MenuItemNutritionLabelWidgetPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type MenuItemNutritionLabelImagePath struct {
	ID float32 `json:"id" validate:"required"`
}

func (m MenuItemNutritionLabelImagePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type GetMealPlanWeekPath struct {
	Username  string `json:"username" validate:"required"`
	StartDate string `json:"start-date" validate:"required"`
}

func (g GetMealPlanWeekPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ClearMealPlanDayPath struct {
	Username string `json:"username" validate:"required"`
	Date     string `json:"date" validate:"required"`
}

func (c ClearMealPlanDayPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AddToMealPlanPath struct {
	Username string `json:"username" validate:"required"`
}

func (a AddToMealPlanPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteFromMealPlanPath struct {
	Username string  `json:"username" validate:"required"`
	ID       float32 `json:"id" validate:"required"`
}

func (d DeleteFromMealPlanPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetMealPlanTemplatesPath struct {
	Username string `json:"username" validate:"required"`
}

func (g GetMealPlanTemplatesPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AddMealPlanTemplatePath struct {
	Username string `json:"username" validate:"required"`
}

func (a AddMealPlanTemplatePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type GetMealPlanTemplatePath struct {
	Username string  `json:"username" validate:"required"`
	ID       float32 `json:"id" validate:"required"`
}

func (g GetMealPlanTemplatePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type DeleteMealPlanTemplatePath struct {
	Username string  `json:"username" validate:"required"`
	ID       float32 `json:"id" validate:"required"`
}

func (d DeleteMealPlanTemplatePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetShoppingListPath struct {
	Username string `json:"username" validate:"required"`
}

func (g GetShoppingListPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingListPath struct {
	Username  string `json:"username" validate:"required"`
	StartDate string `json:"start-date" validate:"required"`
	EndDate   string `json:"end-date" validate:"required"`
}

func (g GenerateShoppingListPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AddToShoppingListPath struct {
	Username string `json:"username" validate:"required"`
}

func (a AddToShoppingListPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteFromShoppingListPath struct {
	Username string  `json:"username" validate:"required"`
	ID       float32 `json:"id" validate:"required"`
}

func (d DeleteFromShoppingListPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type VisualizeRecipeTasteBody = string

type VisualizeRecipeNutritionBody = string

type VisualizePriceBreakdownBody = string

type VisualizeEquipmentBody = string

type AnalyzeRecipeBody struct {
	Language         *string `json:"language,omitempty"`
	IncludeNutrition *bool   `json:"includeNutrition,omitempty"`
	IncludeTaste     *bool   `json:"includeTaste,omitempty"`
}

type CreateRecipeCardBody = string

type AnalyzeRecipeInstructionsBody = string

type ClassifyCuisineBody = string

type ParseIngredientsBody = string

type VisualizeIngredientsBody = string

type ComputeGlycemicLoadBody struct {
	Ingredients []string `json:"ingredients" validate:"required"`
}

func (c ComputeGlycemicLoadBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ClassifyGroceryProductBody struct {
	Title   string `json:"title" validate:"required,min=1"`
	Upc     string `json:"upc" validate:"required"`
	PluCode string `json:"plu_code" validate:"required"`
}

func (c ClassifyGroceryProductBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ClassifyGroceryProductBulkBody []ClassifyGroceryProductBulkBody_Item

func (c ClassifyGroceryProductBulkBody) Validate() error {
	if c == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(c) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(c)))
	}
	for i, item := range c {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MapIngredientsToGroceryProductsBody struct {
	Ingredients []string `json:"ingredients" validate:"required"`
	Servings    float32  `json:"servings" validate:"required"`
}

func (m MapIngredientsToGroceryProductsBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type ClearMealPlanDayBody struct {
	Username string `json:"username" validate:"required"`
	Date     string `json:"date" validate:"required"`
	Hash     string `json:"hash" validate:"required"`
}

func (c ClearMealPlanDayBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AddToMealPlanBody struct {
	Username string `json:"username" validate:"required"`
	Hash     string `json:"hash" validate:"required"`
}

func (a AddToMealPlanBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteFromMealPlanBody struct {
	Username string  `json:"username" validate:"required"`
	ID       float32 `json:"id" validate:"required"`
	Hash     string  `json:"hash" validate:"required"`
}

func (d DeleteFromMealPlanBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type AddMealPlanTemplateBody struct {
	Username string `json:"username" validate:"required"`
	Hash     string `json:"hash" validate:"required"`
}

func (a AddMealPlanTemplateBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteMealPlanTemplateBody struct {
	Username string  `json:"username" validate:"required"`
	ID       float32 `json:"id" validate:"required"`
	Hash     string  `json:"hash" validate:"required"`
}

func (d DeleteMealPlanTemplateBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GenerateShoppingListBody struct {
	Username  string `json:"username" validate:"required"`
	StartDate string `json:"start-date" validate:"required"`
	EndDate   string `json:"end-date" validate:"required"`
	Hash      string `json:"hash" validate:"required"`
}

func (g GenerateShoppingListBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ConnectUserBody = map[string]any

type AddToShoppingListBody struct {
	Username string `json:"username" validate:"required"`
	Hash     string `json:"hash" validate:"required"`
}

func (a AddToShoppingListBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteFromShoppingListBody struct {
	Username string  `json:"username" validate:"required"`
	ID       float32 `json:"id" validate:"required"`
	Hash     string  `json:"hash" validate:"required"`
}

func (d DeleteFromShoppingListBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DetectFoodInTextBody = string

type Ingredients = string

type Number = int64

type IgnorePantry = bool

type LimitLicense = bool

type Query = string

type Offset = int64

type IncludeNutrition = bool

type Tags = string

type IncludeTaste = bool

type DefaultCSS = bool

type Hash = string

type Rgb = string

type SearchRecipesQuery struct {
	Query                *Query        `json:"query,omitempty"`
	Cuisine              *string       `json:"cuisine,omitempty"`
	ExcludeCuisine       *string       `json:"excludeCuisine,omitempty"`
	Diet                 *string       `json:"diet,omitempty"`
	Intolerances         *string       `json:"intolerances,omitempty"`
	Equipment            *string       `json:"equipment,omitempty"`
	IncludeIngredients   *string       `json:"includeIngredients,omitempty"`
	ExcludeIngredients   *string       `json:"excludeIngredients,omitempty"`
	Type                 *string       `json:"type,omitempty"`
	InstructionsRequired *bool         `json:"instructionsRequired,omitempty"`
	FillIngredients      *bool         `json:"fillIngredients,omitempty"`
	AddRecipeInformation *bool         `json:"addRecipeInformation,omitempty"`
	AddRecipeNutrition   *bool         `json:"addRecipeNutrition,omitempty"`
	Author               *string       `json:"author,omitempty"`
	Tags                 *Tags         `json:"tags,omitempty"`
	RecipeBoxID          *float32      `json:"recipeBoxId,omitempty"`
	TitleMatch           *string       `json:"titleMatch,omitempty"`
	MaxReadyTime         *float32      `json:"maxReadyTime,omitempty"`
	IgnorePantry         *IgnorePantry `json:"ignorePantry,omitempty"`
	Sort                 *string       `json:"sort,omitempty"`
	SortDirection        *string       `json:"sortDirection,omitempty"`
	MinCarbs             *float32      `json:"minCarbs,omitempty"`
	MaxCarbs             *float32      `json:"maxCarbs,omitempty"`
	MinProtein           *float32      `json:"minProtein,omitempty"`
	MaxProtein           *float32      `json:"maxProtein,omitempty"`
	MinCalories          *float32      `json:"minCalories,omitempty"`
	MaxCalories          *float32      `json:"maxCalories,omitempty"`
	MinFat               *float32      `json:"minFat,omitempty"`
	MaxFat               *float32      `json:"maxFat,omitempty"`
	MinAlcohol           *float32      `json:"minAlcohol,omitempty"`
	MaxAlcohol           *float32      `json:"maxAlcohol,omitempty"`
	MinCaffeine          *float32      `json:"minCaffeine,omitempty"`
	MaxCaffeine          *float32      `json:"maxCaffeine,omitempty"`
	MinCopper            *float32      `json:"minCopper,omitempty"`
	MaxCopper            *float32      `json:"maxCopper,omitempty"`
	MinCalcium           *float32      `json:"minCalcium,omitempty"`
	MaxCalcium           *float32      `json:"maxCalcium,omitempty"`
	MinCholine           *float32      `json:"minCholine,omitempty"`
	MaxCholine           *float32      `json:"maxCholine,omitempty"`
	MinCholesterol       *float32      `json:"minCholesterol,omitempty"`
	MaxCholesterol       *float32      `json:"maxCholesterol,omitempty"`
	MinFluoride          *float32      `json:"minFluoride,omitempty"`
	MaxFluoride          *float32      `json:"maxFluoride,omitempty"`
	MinSaturatedFat      *float32      `json:"minSaturatedFat,omitempty"`
	MaxSaturatedFat      *float32      `json:"maxSaturatedFat,omitempty"`
	MinVitaminA          *float32      `json:"minVitaminA,omitempty"`
	MaxVitaminA          *float32      `json:"maxVitaminA,omitempty"`
	MinVitaminC          *float32      `json:"minVitaminC,omitempty"`
	MaxVitaminC          *float32      `json:"maxVitaminC,omitempty"`
	MinVitaminD          *float32      `json:"minVitaminD,omitempty"`
	MaxVitaminD          *float32      `json:"maxVitaminD,omitempty"`
	MinVitaminE          *float32      `json:"minVitaminE,omitempty"`
	MaxVitaminE          *float32      `json:"maxVitaminE,omitempty"`
	MinVitaminK          *float32      `json:"minVitaminK,omitempty"`
	MaxVitaminK          *float32      `json:"maxVitaminK,omitempty"`
	MinVitaminB1         *float32      `json:"minVitaminB1,omitempty"`
	MaxVitaminB1         *float32      `json:"maxVitaminB1,omitempty"`
	MinVitaminB2         *float32      `json:"minVitaminB2,omitempty"`
	MaxVitaminB2         *float32      `json:"maxVitaminB2,omitempty"`
	MinVitaminB5         *float32      `json:"minVitaminB5,omitempty"`
	MaxVitaminB5         *float32      `json:"maxVitaminB5,omitempty"`
	MinVitaminB3         *float32      `json:"minVitaminB3,omitempty"`
	MaxVitaminB3         *float32      `json:"maxVitaminB3,omitempty"`
	MinVitaminB6         *float32      `json:"minVitaminB6,omitempty"`
	MaxVitaminB6         *float32      `json:"maxVitaminB6,omitempty"`
	MinVitaminB12        *float32      `json:"minVitaminB12,omitempty"`
	MaxVitaminB12        *float32      `json:"maxVitaminB12,omitempty"`
	MinFiber             *float32      `json:"minFiber,omitempty"`
	MaxFiber             *float32      `json:"maxFiber,omitempty"`
	MinFolate            *float32      `json:"minFolate,omitempty"`
	MaxFolate            *float32      `json:"maxFolate,omitempty"`
	MinFolicAcid         *float32      `json:"minFolicAcid,omitempty"`
	MaxFolicAcid         *float32      `json:"maxFolicAcid,omitempty"`
	MinIodine            *float32      `json:"minIodine,omitempty"`
	MaxIodine            *float32      `json:"maxIodine,omitempty"`
	MinIron              *float32      `json:"minIron,omitempty"`
	MaxIron              *float32      `json:"maxIron,omitempty"`
	MinMagnesium         *float32      `json:"minMagnesium,omitempty"`
	MaxMagnesium         *float32      `json:"maxMagnesium,omitempty"`
	MinManganese         *float32      `json:"minManganese,omitempty"`
	MaxManganese         *float32      `json:"maxManganese,omitempty"`
	MinPhosphorus        *float32      `json:"minPhosphorus,omitempty"`
	MaxPhosphorus        *float32      `json:"maxPhosphorus,omitempty"`
	MinPotassium         *float32      `json:"minPotassium,omitempty"`
	MaxPotassium         *float32      `json:"maxPotassium,omitempty"`
	MinSelenium          *float32      `json:"minSelenium,omitempty"`
	MaxSelenium          *float32      `json:"maxSelenium,omitempty"`
	MinSodium            *float32      `json:"minSodium,omitempty"`
	MaxSodium            *float32      `json:"maxSodium,omitempty"`
	MinSugar             *float32      `json:"minSugar,omitempty"`
	MaxSugar             *float32      `json:"maxSugar,omitempty"`
	MinZinc              *float32      `json:"minZinc,omitempty"`
	MaxZinc              *float32      `json:"maxZinc,omitempty"`
	Offset               *Offset       `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number               *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	LimitLicense         *LimitLicense `json:"limitLicense,omitempty"`
}

func (s SearchRecipesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByIngredientsQuery struct {
	Ingredients  *Ingredients  `json:"ingredients,omitempty"`
	Number       *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	LimitLicense *LimitLicense `json:"limitLicense,omitempty"`
	Ranking      *float32      `json:"ranking,omitempty"`
	IgnorePantry *IgnorePantry `json:"ignorePantry,omitempty"`
}

func (s SearchRecipesByIngredientsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByNutrientsQuery struct {
	MinCarbs        *float32      `json:"minCarbs,omitempty"`
	MaxCarbs        *float32      `json:"maxCarbs,omitempty"`
	MinProtein      *float32      `json:"minProtein,omitempty"`
	MaxProtein      *float32      `json:"maxProtein,omitempty"`
	MinCalories     *float32      `json:"minCalories,omitempty"`
	MaxCalories     *float32      `json:"maxCalories,omitempty"`
	MinFat          *float32      `json:"minFat,omitempty"`
	MaxFat          *float32      `json:"maxFat,omitempty"`
	MinAlcohol      *float32      `json:"minAlcohol,omitempty"`
	MaxAlcohol      *float32      `json:"maxAlcohol,omitempty"`
	MinCaffeine     *float32      `json:"minCaffeine,omitempty"`
	MaxCaffeine     *float32      `json:"maxCaffeine,omitempty"`
	MinCopper       *float32      `json:"minCopper,omitempty"`
	MaxCopper       *float32      `json:"maxCopper,omitempty"`
	MinCalcium      *float32      `json:"minCalcium,omitempty"`
	MaxCalcium      *float32      `json:"maxCalcium,omitempty"`
	MinCholine      *float32      `json:"minCholine,omitempty"`
	MaxCholine      *float32      `json:"maxCholine,omitempty"`
	MinCholesterol  *float32      `json:"minCholesterol,omitempty"`
	MaxCholesterol  *float32      `json:"maxCholesterol,omitempty"`
	MinFluoride     *float32      `json:"minFluoride,omitempty"`
	MaxFluoride     *float32      `json:"maxFluoride,omitempty"`
	MinSaturatedFat *float32      `json:"minSaturatedFat,omitempty"`
	MaxSaturatedFat *float32      `json:"maxSaturatedFat,omitempty"`
	MinVitaminA     *float32      `json:"minVitaminA,omitempty"`
	MaxVitaminA     *float32      `json:"maxVitaminA,omitempty"`
	MinVitaminC     *float32      `json:"minVitaminC,omitempty"`
	MaxVitaminC     *float32      `json:"maxVitaminC,omitempty"`
	MinVitaminD     *float32      `json:"minVitaminD,omitempty"`
	MaxVitaminD     *float32      `json:"maxVitaminD,omitempty"`
	MinVitaminE     *float32      `json:"minVitaminE,omitempty"`
	MaxVitaminE     *float32      `json:"maxVitaminE,omitempty"`
	MinVitaminK     *float32      `json:"minVitaminK,omitempty"`
	MaxVitaminK     *float32      `json:"maxVitaminK,omitempty"`
	MinVitaminB1    *float32      `json:"minVitaminB1,omitempty"`
	MaxVitaminB1    *float32      `json:"maxVitaminB1,omitempty"`
	MinVitaminB2    *float32      `json:"minVitaminB2,omitempty"`
	MaxVitaminB2    *float32      `json:"maxVitaminB2,omitempty"`
	MinVitaminB5    *float32      `json:"minVitaminB5,omitempty"`
	MaxVitaminB5    *float32      `json:"maxVitaminB5,omitempty"`
	MinVitaminB3    *float32      `json:"minVitaminB3,omitempty"`
	MaxVitaminB3    *float32      `json:"maxVitaminB3,omitempty"`
	MinVitaminB6    *float32      `json:"minVitaminB6,omitempty"`
	MaxVitaminB6    *float32      `json:"maxVitaminB6,omitempty"`
	MinVitaminB12   *float32      `json:"minVitaminB12,omitempty"`
	MaxVitaminB12   *float32      `json:"maxVitaminB12,omitempty"`
	MinFiber        *float32      `json:"minFiber,omitempty"`
	MaxFiber        *float32      `json:"maxFiber,omitempty"`
	MinFolate       *float32      `json:"minFolate,omitempty"`
	MaxFolate       *float32      `json:"maxFolate,omitempty"`
	MinFolicAcid    *float32      `json:"minFolicAcid,omitempty"`
	MaxFolicAcid    *float32      `json:"maxFolicAcid,omitempty"`
	MinIodine       *float32      `json:"minIodine,omitempty"`
	MaxIodine       *float32      `json:"maxIodine,omitempty"`
	MinIron         *float32      `json:"minIron,omitempty"`
	MaxIron         *float32      `json:"maxIron,omitempty"`
	MinMagnesium    *float32      `json:"minMagnesium,omitempty"`
	MaxMagnesium    *float32      `json:"maxMagnesium,omitempty"`
	MinManganese    *float32      `json:"minManganese,omitempty"`
	MaxManganese    *float32      `json:"maxManganese,omitempty"`
	MinPhosphorus   *float32      `json:"minPhosphorus,omitempty"`
	MaxPhosphorus   *float32      `json:"maxPhosphorus,omitempty"`
	MinPotassium    *float32      `json:"minPotassium,omitempty"`
	MaxPotassium    *float32      `json:"maxPotassium,omitempty"`
	MinSelenium     *float32      `json:"minSelenium,omitempty"`
	MaxSelenium     *float32      `json:"maxSelenium,omitempty"`
	MinSodium       *float32      `json:"minSodium,omitempty"`
	MaxSodium       *float32      `json:"maxSodium,omitempty"`
	MinSugar        *float32      `json:"minSugar,omitempty"`
	MaxSugar        *float32      `json:"maxSugar,omitempty"`
	MinZinc         *float32      `json:"minZinc,omitempty"`
	MaxZinc         *float32      `json:"maxZinc,omitempty"`
	Offset          *Offset       `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number          *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	Random          *bool         `json:"random,omitempty"`
	LimitLicense    *LimitLicense `json:"limitLicense,omitempty"`
}

func (s SearchRecipesByNutrientsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetRecipeInformationQuery struct {
	IncludeNutrition *IncludeNutrition `json:"includeNutrition,omitempty"`
}

type GetRecipeInformationBulkQuery struct {
	Ids              string            `json:"ids" validate:"required"`
	IncludeNutrition *IncludeNutrition `json:"includeNutrition,omitempty"`
}

func (g GetRecipeInformationBulkQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSimilarRecipesQuery struct {
	Number       *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	LimitLicense *LimitLicense `json:"limitLicense,omitempty"`
}

func (g GetSimilarRecipesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipesQuery struct {
	LimitLicense *LimitLicense `json:"limitLicense,omitempty"`
	Tags         *Tags         `json:"tags,omitempty"`
	Number       *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (g GetRandomRecipesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AutocompleteRecipeSearchQuery struct {
	Query  *Query  `json:"query,omitempty"`
	Number *Number `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (a AutocompleteRecipeSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type GetRecipeTasteByIDQuery struct {
	Normalize *GetRecipeTasteByIDQueryNormalize `json:"normalize,omitempty"`
}

func (g GetRecipeTasteByIDQuery) Validate() error {
	var errors runtime.ValidationErrors
	if g.Normalize != nil {
		if v, ok := any(g.Normalize).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Normalize", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RecipeTasteByIDImageQuery struct {
	Normalize *bool `json:"normalize,omitempty"`
	Rgb       *Rgb  `json:"rgb,omitempty"`
}

type IngredientsByIDImageQuery struct {
	Measure *IngredientsByIDImageQueryMeasure `json:"measure,omitempty"`
}

func (i IngredientsByIDImageQuery) Validate() error {
	var errors runtime.ValidationErrors
	if i.Measure != nil {
		if v, ok := any(i.Measure).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measure", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RecipeNutritionLabelWidgetQuery struct {
	DefaultCSS            *DefaultCSS `json:"defaultCss,omitempty"`
	ShowOptionalNutrients *bool       `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool       `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool       `json:"showIngredients,omitempty"`
}

type RecipeNutritionLabelImageQuery struct {
	ShowOptionalNutrients *bool `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool `json:"showIngredients,omitempty"`
}

type GetAnalyzedRecipeInstructionsQuery struct {
	StepBreakdown *bool `json:"stepBreakdown,omitempty"`
}

type ExtractRecipeFromWebsiteQuery struct {
	URL              string            `json:"url" validate:"required"`
	ForceExtraction  *bool             `json:"forceExtraction,omitempty"`
	Analyze          *bool             `json:"analyze,omitempty"`
	IncludeNutrition *IncludeNutrition `json:"includeNutrition,omitempty"`
	IncludeTaste     *IncludeTaste     `json:"includeTaste,omitempty"`
}

func (e ExtractRecipeFromWebsiteQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type VisualizeRecipeIngredientsByIDQuery struct {
	DefaultCSS *DefaultCSS                                 `json:"defaultCss,omitempty"`
	Measure    *VisualizeRecipeIngredientsByIDQueryMeasure `json:"measure,omitempty"`
}

func (v VisualizeRecipeIngredientsByIDQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v.Measure != nil {
		if v, ok := any(v.Measure).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measure", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeRecipeTasteByIDQuery struct {
	Normalize *VisualizeRecipeTasteByIDQueryNormalize `json:"normalize,omitempty"`
	Rgb       *Rgb                                    `json:"rgb,omitempty"`
}

func (v VisualizeRecipeTasteByIDQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v.Normalize != nil {
		if v, ok := any(v.Normalize).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Normalize", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeRecipeEquipmentByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type VisualizeRecipePriceBreakdownByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type VisualizeRecipeTasteQuery struct {
	Language  *Language `json:"language,omitempty"`
	Normalize *bool     `json:"normalize,omitempty"`
	Rgb       *Rgb      `json:"rgb,omitempty"`
}

type VisualizeRecipeNutritionQuery struct {
	Language *Language `json:"language,omitempty"`
}

type VisualizePriceBreakdownQuery struct {
	Language *Language `json:"language,omitempty"`
}

type AnalyzeRecipeQuery struct {
	Language         *string `json:"language,omitempty"`
	IncludeNutrition *bool   `json:"includeNutrition,omitempty"`
	IncludeTaste     *bool   `json:"includeTaste,omitempty"`
}

type CreateRecipeCardGetQuery struct {
	Mask            *string `json:"mask,omitempty"`
	BackgroundImage *string `json:"backgroundImage,omitempty"`
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	FontColor       *string `json:"fontColor,omitempty"`
}

type AnalyzeARecipeSearchQueryQuery struct {
	Q string `json:"q" validate:"required"`
}

func (a AnalyzeARecipeSearchQueryQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type ConvertAmountsQuery struct {
	IngredientName string  `json:"ingredientName" validate:"required"`
	SourceAmount   float32 `json:"sourceAmount" validate:"required"`
	SourceUnit     string  `json:"sourceUnit" validate:"required"`
	TargetUnit     string  `json:"targetUnit" validate:"required"`
}

func (c ConvertAmountsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ParseIngredientsQuery struct {
	Language *Language `json:"language,omitempty"`
}

type VisualizeRecipeNutritionByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type VisualizeIngredientsQuery struct {
	Language *Language `json:"language,omitempty"`
}

type GuessNutritionByDishNameQuery struct {
	Title string `json:"title" validate:"required"`
}

func (g GuessNutritionByDishNameQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformationQuery struct {
	Amount *float32 `json:"amount,omitempty"`
	Unit   *string  `json:"unit,omitempty"`
}

type ComputeIngredientAmountQuery struct {
	Nutrient string  `json:"nutrient" validate:"required"`
	Target   float32 `json:"target" validate:"required"`
	Unit     *string `json:"unit,omitempty"`
}

func (c ComputeIngredientAmountQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ComputeGlycemicLoadQuery struct {
	Language *Language `json:"language,omitempty"`
}

type AutocompleteIngredientSearchQuery struct {
	Query           *Query    `json:"query,omitempty"`
	Number          *Number   `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	MetaInformation *bool     `json:"metaInformation,omitempty"`
	Intolerances    *string   `json:"intolerances,omitempty"`
	Language        *Language `json:"language,omitempty"`
}

func (a AutocompleteIngredientSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type IngredientSearchQuery struct {
	Query             *Query    `json:"query,omitempty"`
	AddChildren       *bool     `json:"addChildren,omitempty"`
	MinProteinPercent *float32  `json:"minProteinPercent,omitempty"`
	MaxProteinPercent *float32  `json:"maxProteinPercent,omitempty"`
	MinFatPercent     *float32  `json:"minFatPercent,omitempty"`
	MaxFatPercent     *float32  `json:"maxFatPercent,omitempty"`
	MinCarbsPercent   *float32  `json:"minCarbsPercent,omitempty"`
	MaxCarbsPercent   *float32  `json:"maxCarbsPercent,omitempty"`
	MetaInformation   *bool     `json:"metaInformation,omitempty"`
	Intolerances      *string   `json:"intolerances,omitempty"`
	Sort              *string   `json:"sort,omitempty"`
	SortDirection     *string   `json:"sortDirection,omitempty"`
	Offset            *Offset   `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number            *Number   `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	Language          *Language `json:"language,omitempty"`
}

func (i IngredientSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type GetIngredientSubstitutesQuery struct {
	IngredientName string `json:"ingredientName" validate:"required"`
}

func (g GetIngredientSubstitutesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type SearchGroceryProductsQuery struct {
	Query                 *Query                                           `json:"query,omitempty"`
	MinCalories           *float32                                         `json:"minCalories,omitempty"`
	MaxCalories           *float32                                         `json:"maxCalories,omitempty"`
	MinCarbs              *float32                                         `json:"minCarbs,omitempty"`
	MaxCarbs              *float32                                         `json:"maxCarbs,omitempty"`
	MinProtein            *float32                                         `json:"minProtein,omitempty"`
	MaxProtein            *float32                                         `json:"maxProtein,omitempty"`
	MinFat                *float32                                         `json:"minFat,omitempty"`
	MaxFat                *float32                                         `json:"maxFat,omitempty"`
	AddProductInformation *SearchGroceryProductsQueryAddProductInformation `json:"addProductInformation,omitempty"`
	Offset                *Offset                                          `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number                *Number                                          `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchGroceryProductsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if s.AddProductInformation != nil {
		if v, ok := any(s.AddProductInformation).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AddProductInformation", err)
			}
		}
	}
	if s.Offset != nil {
		if err := typesValidator.Var(s.Offset, "omitempty,gte=0,lte=900"); err != nil {
			errors = errors.Append("Offset", err)
		}
	}
	if s.Number != nil {
		if err := typesValidator.Var(s.Number, "omitempty,gte=1,lte=100"); err != nil {
			errors = errors.Append("Number", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchCustomFoodsQuery struct {
	Query    *Query  `json:"query,omitempty"`
	Username string  `json:"username" validate:"required"`
	Hash     string  `json:"hash" validate:"required"`
	Offset   *Offset `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number   *Number `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchCustomFoodsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type AutocompleteProductSearchQuery struct {
	Query  string `json:"query" validate:"required"`
	Number *int64 `json:"number,omitempty" validate:"omitempty,gte=1,lte=25"`
}

func (a AutocompleteProductSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type VisualizeProductNutritionByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type ProductNutritionLabelWidgetQuery struct {
	DefaultCSS            *DefaultCSS `json:"defaultCss,omitempty"`
	ShowOptionalNutrients *bool       `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool       `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool       `json:"showIngredients,omitempty"`
}

type ProductNutritionLabelImageQuery struct {
	ShowOptionalNutrients *bool `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool `json:"showIngredients,omitempty"`
}

type ClassifyGroceryProductQuery struct {
	Locale *ClassifyGroceryProductQueryLocale `json:"locale,omitempty"`
}

func (c ClassifyGroceryProductQuery) Validate() error {
	var errors runtime.ValidationErrors
	if c.Locale != nil {
		if v, ok := any(c.Locale).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Locale", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ClassifyGroceryProductBulkQuery struct {
	Locale *string `json:"locale,omitempty"`
}

type AutocompleteMenuItemSearchQuery struct {
	Query  string   `json:"query" validate:"required"`
	Number *float32 `json:"number,omitempty" validate:"omitempty,gte=1,lte=25"`
}

func (a AutocompleteMenuItemSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type SearchMenuItemsQuery struct {
	Query                  *Query                                      `json:"query,omitempty"`
	MinCalories            *float32                                    `json:"minCalories,omitempty"`
	MaxCalories            *float32                                    `json:"maxCalories,omitempty"`
	MinCarbs               *float32                                    `json:"minCarbs,omitempty"`
	MaxCarbs               *float32                                    `json:"maxCarbs,omitempty"`
	MinProtein             *float32                                    `json:"minProtein,omitempty"`
	MaxProtein             *float32                                    `json:"maxProtein,omitempty"`
	MinFat                 *float32                                    `json:"minFat,omitempty"`
	MaxFat                 *float32                                    `json:"maxFat,omitempty"`
	AddMenuItemInformation *SearchMenuItemsQueryAddMenuItemInformation `json:"addMenuItemInformation,omitempty"`
	Offset                 *Offset                                     `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number                 *Number                                     `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchMenuItemsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if s.AddMenuItemInformation != nil {
		if v, ok := any(s.AddMenuItemInformation).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AddMenuItemInformation", err)
			}
		}
	}
	if s.Offset != nil {
		if err := typesValidator.Var(s.Offset, "omitempty,gte=0,lte=900"); err != nil {
			errors = errors.Append("Offset", err)
		}
	}
	if s.Number != nil {
		if err := typesValidator.Var(s.Number, "omitempty,gte=1,lte=100"); err != nil {
			errors = errors.Append("Number", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeMenuItemNutritionByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type MenuItemNutritionLabelWidgetQuery struct {
	DefaultCSS            *DefaultCSS `json:"defaultCss,omitempty"`
	ShowOptionalNutrients *bool       `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool       `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool       `json:"showIngredients,omitempty"`
}

type MenuItemNutritionLabelImageQuery struct {
	ShowOptionalNutrients *bool `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool `json:"showIngredients,omitempty"`
}

type GenerateMealPlanQuery struct {
	TimeFrame      *string  `json:"timeFrame,omitempty"`
	TargetCalories *float32 `json:"targetCalories,omitempty"`
	Diet           *string  `json:"diet,omitempty"`
	Exclude        *string  `json:"exclude,omitempty"`
}

type GetMealPlanWeekQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GetMealPlanWeekQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ClearMealPlanDayQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (c ClearMealPlanDayQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AddToMealPlanQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (a AddToMealPlanQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteFromMealPlanQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (d DeleteFromMealPlanQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetMealPlanTemplatesQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GetMealPlanTemplatesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AddMealPlanTemplateQuery struct {
	Hash string `json:"hash" validate:"required"`
}

func (a AddMealPlanTemplateQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type GetMealPlanTemplateQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GetMealPlanTemplateQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type DeleteMealPlanTemplateQuery struct {
	Hash string `json:"hash" validate:"required"`
}

func (d DeleteMealPlanTemplateQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetShoppingListQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GetShoppingListQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingListQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GenerateShoppingListQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AddToShoppingListQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (a AddToShoppingListQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteFromShoppingListQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (d DeleteFromShoppingListQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type SearchRestaurantsQuery struct {
	Query     *string  `json:"query,omitempty"`
	Lat       *float32 `json:"lat,omitempty"`
	Lng       *float32 `json:"lng,omitempty"`
	Distance  *float32 `json:"distance,omitempty"`
	Budget    *float32 `json:"budget,omitempty"`
	Cuisine   *string  `json:"cuisine,omitempty"`
	MinRating *float32 `json:"min-rating,omitempty"`
	IsOpen    *bool    `json:"is-open,omitempty"`
	Sort      *string  `json:"sort,omitempty"`
	Page      *float32 `json:"page,omitempty"`
}

type GetDishPairingForWineQuery struct {
	Wine string `json:"wine" validate:"required"`
}

func (g GetDishPairingForWineQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWinePairingQuery struct {
	Food     string   `json:"food" validate:"required"`
	MaxPrice *float32 `json:"maxPrice,omitempty"`
}

func (g GetWinePairingQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWineDescriptionQuery struct {
	Wine string `json:"wine" validate:"required"`
}

func (g GetWineDescriptionQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWineRecommendationQuery struct {
	Wine      string   `json:"wine" validate:"required"`
	MaxPrice  *float32 `json:"maxPrice,omitempty"`
	MinRating *float32 `json:"minRating,omitempty"`
	Number    *float32 `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (g GetWineRecommendationQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ImageClassificationByURLQuery struct {
	ImageURL string `json:"imageUrl" validate:"required"`
}

func (i ImageClassificationByURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURLQuery struct {
	ImageURL string `json:"imageUrl" validate:"required"`
}

func (i ImageAnalysisByURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type QuickAnswerQuery struct {
	Q string `json:"q" validate:"required"`
}

func (q QuickAnswerQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(q))
}

type SearchSiteContentQuery struct {
	Query string `json:"query" validate:"required"`
}

func (s SearchSiteContentQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchAllFoodQuery struct {
	Query  string  `json:"query" validate:"required"`
	Offset *Offset `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number *Number `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchAllFoodQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchFoodVideosQuery struct {
	Query              *Query   `json:"query,omitempty"`
	Type               *string  `json:"type,omitempty"`
	Cuisine            *string  `json:"cuisine,omitempty"`
	Diet               *string  `json:"diet,omitempty"`
	IncludeIngredients *string  `json:"includeIngredients,omitempty"`
	ExcludeIngredients *string  `json:"excludeIngredients,omitempty"`
	MinLength          *float32 `json:"minLength,omitempty"`
	MaxLength          *float32 `json:"maxLength,omitempty"`
	Offset             *Offset  `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number             *Number  `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchFoodVideosQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type TalkToChatbotQuery struct {
	Text      string  `json:"text" validate:"required"`
	ContextID *string `json:"contextId,omitempty"`
}

func (t TalkToChatbotQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type GetConversationSuggestsQuery struct {
	Query  string   `json:"query" validate:"required"`
	Number *float32 `json:"number,omitempty"`
}

func (g GetConversationSuggestsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

// SearchRecipesResponseData wraps the success response with optional headers and status override.
type SearchRecipesResponseData struct {
	Body    *SearchRecipesResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchRecipesResponseData creates a new SearchRecipesResponseData with the given body.
func NewSearchRecipesResponseData(body *SearchRecipesResponse) *SearchRecipesResponseData {
	return &SearchRecipesResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchRecipesResponseData) WithHeaders(h http.Header) *SearchRecipesResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchRecipesResponseData) WithStatus(code int) *SearchRecipesResponseData {
	r.Status = code
	return r
}

// SearchRecipesByIngredientsResponseData wraps the success response with optional headers and status override.
type SearchRecipesByIngredientsResponseData struct {
	Body    *SearchRecipesByIngredientsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchRecipesByIngredientsResponseData creates a new SearchRecipesByIngredientsResponseData with the given body.
func NewSearchRecipesByIngredientsResponseData(body *SearchRecipesByIngredientsResponse) *SearchRecipesByIngredientsResponseData {
	return &SearchRecipesByIngredientsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchRecipesByIngredientsResponseData) WithHeaders(h http.Header) *SearchRecipesByIngredientsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchRecipesByIngredientsResponseData) WithStatus(code int) *SearchRecipesByIngredientsResponseData {
	r.Status = code
	return r
}

// SearchRecipesByNutrientsResponseData wraps the success response with optional headers and status override.
type SearchRecipesByNutrientsResponseData struct {
	Body    *SearchRecipesByNutrientsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchRecipesByNutrientsResponseData creates a new SearchRecipesByNutrientsResponseData with the given body.
func NewSearchRecipesByNutrientsResponseData(body *SearchRecipesByNutrientsResponse) *SearchRecipesByNutrientsResponseData {
	return &SearchRecipesByNutrientsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchRecipesByNutrientsResponseData) WithHeaders(h http.Header) *SearchRecipesByNutrientsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchRecipesByNutrientsResponseData) WithStatus(code int) *SearchRecipesByNutrientsResponseData {
	r.Status = code
	return r
}

// GetRecipeInformationResponseData wraps the success response with optional headers and status override.
type GetRecipeInformationResponseData struct {
	Body    *GetRecipeInformationResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRecipeInformationResponseData creates a new GetRecipeInformationResponseData with the given body.
func NewGetRecipeInformationResponseData(body *GetRecipeInformationResponse) *GetRecipeInformationResponseData {
	return &GetRecipeInformationResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRecipeInformationResponseData) WithHeaders(h http.Header) *GetRecipeInformationResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRecipeInformationResponseData) WithStatus(code int) *GetRecipeInformationResponseData {
	r.Status = code
	return r
}

// GetRecipeInformationBulkResponseData wraps the success response with optional headers and status override.
type GetRecipeInformationBulkResponseData struct {
	Body    *GetRecipeInformationBulkResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRecipeInformationBulkResponseData creates a new GetRecipeInformationBulkResponseData with the given body.
func NewGetRecipeInformationBulkResponseData(body *GetRecipeInformationBulkResponse) *GetRecipeInformationBulkResponseData {
	return &GetRecipeInformationBulkResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRecipeInformationBulkResponseData) WithHeaders(h http.Header) *GetRecipeInformationBulkResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRecipeInformationBulkResponseData) WithStatus(code int) *GetRecipeInformationBulkResponseData {
	r.Status = code
	return r
}

// GetSimilarRecipesResponseData wraps the success response with optional headers and status override.
type GetSimilarRecipesResponseData struct {
	Body    *GetSimilarRecipesResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetSimilarRecipesResponseData creates a new GetSimilarRecipesResponseData with the given body.
func NewGetSimilarRecipesResponseData(body *GetSimilarRecipesResponse) *GetSimilarRecipesResponseData {
	return &GetSimilarRecipesResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetSimilarRecipesResponseData) WithHeaders(h http.Header) *GetSimilarRecipesResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetSimilarRecipesResponseData) WithStatus(code int) *GetSimilarRecipesResponseData {
	r.Status = code
	return r
}

// GetRandomRecipesResponseData wraps the success response with optional headers and status override.
type GetRandomRecipesResponseData struct {
	Body    *GetRandomRecipesResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRandomRecipesResponseData creates a new GetRandomRecipesResponseData with the given body.
func NewGetRandomRecipesResponseData(body *GetRandomRecipesResponse) *GetRandomRecipesResponseData {
	return &GetRandomRecipesResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRandomRecipesResponseData) WithHeaders(h http.Header) *GetRandomRecipesResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRandomRecipesResponseData) WithStatus(code int) *GetRandomRecipesResponseData {
	r.Status = code
	return r
}

// AutocompleteRecipeSearchResponseData wraps the success response with optional headers and status override.
type AutocompleteRecipeSearchResponseData struct {
	Body    *AutocompleteRecipeSearchResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAutocompleteRecipeSearchResponseData creates a new AutocompleteRecipeSearchResponseData with the given body.
func NewAutocompleteRecipeSearchResponseData(body *AutocompleteRecipeSearchResponse) *AutocompleteRecipeSearchResponseData {
	return &AutocompleteRecipeSearchResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AutocompleteRecipeSearchResponseData) WithHeaders(h http.Header) *AutocompleteRecipeSearchResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AutocompleteRecipeSearchResponseData) WithStatus(code int) *AutocompleteRecipeSearchResponseData {
	r.Status = code
	return r
}

// GetRecipeTasteByIDResponseData wraps the success response with optional headers and status override.
type GetRecipeTasteByIDResponseData struct {
	Body    *GetRecipeTasteByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRecipeTasteByIDResponseData creates a new GetRecipeTasteByIDResponseData with the given body.
func NewGetRecipeTasteByIDResponseData(body *GetRecipeTasteByIDResponse) *GetRecipeTasteByIDResponseData {
	return &GetRecipeTasteByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRecipeTasteByIDResponseData) WithHeaders(h http.Header) *GetRecipeTasteByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRecipeTasteByIDResponseData) WithStatus(code int) *GetRecipeTasteByIDResponseData {
	r.Status = code
	return r
}

// RecipeTasteByIDImageResponseData wraps the success response with optional headers and status override.
type RecipeTasteByIDImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewRecipeTasteByIDImageResponseData creates a new RecipeTasteByIDImageResponseData with the given body.
func NewRecipeTasteByIDImageResponseData(body []byte) *RecipeTasteByIDImageResponseData {
	return &RecipeTasteByIDImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *RecipeTasteByIDImageResponseData) WithHeaders(h http.Header) *RecipeTasteByIDImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *RecipeTasteByIDImageResponseData) WithStatus(code int) *RecipeTasteByIDImageResponseData {
	r.Status = code
	return r
}

// GetRecipeEquipmentByIDResponseData wraps the success response with optional headers and status override.
type GetRecipeEquipmentByIDResponseData struct {
	Body    *GetRecipeEquipmentByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRecipeEquipmentByIDResponseData creates a new GetRecipeEquipmentByIDResponseData with the given body.
func NewGetRecipeEquipmentByIDResponseData(body *GetRecipeEquipmentByIDResponse) *GetRecipeEquipmentByIDResponseData {
	return &GetRecipeEquipmentByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRecipeEquipmentByIDResponseData) WithHeaders(h http.Header) *GetRecipeEquipmentByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRecipeEquipmentByIDResponseData) WithStatus(code int) *GetRecipeEquipmentByIDResponseData {
	r.Status = code
	return r
}

// EquipmentByIDImageResponseData wraps the success response with optional headers and status override.
type EquipmentByIDImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewEquipmentByIDImageResponseData creates a new EquipmentByIDImageResponseData with the given body.
func NewEquipmentByIDImageResponseData(body []byte) *EquipmentByIDImageResponseData {
	return &EquipmentByIDImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *EquipmentByIDImageResponseData) WithHeaders(h http.Header) *EquipmentByIDImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *EquipmentByIDImageResponseData) WithStatus(code int) *EquipmentByIDImageResponseData {
	r.Status = code
	return r
}

// GetRecipePriceBreakdownByIDResponseData wraps the success response with optional headers and status override.
type GetRecipePriceBreakdownByIDResponseData struct {
	Body    *GetRecipePriceBreakdownByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRecipePriceBreakdownByIDResponseData creates a new GetRecipePriceBreakdownByIDResponseData with the given body.
func NewGetRecipePriceBreakdownByIDResponseData(body *GetRecipePriceBreakdownByIDResponse) *GetRecipePriceBreakdownByIDResponseData {
	return &GetRecipePriceBreakdownByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRecipePriceBreakdownByIDResponseData) WithHeaders(h http.Header) *GetRecipePriceBreakdownByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRecipePriceBreakdownByIDResponseData) WithStatus(code int) *GetRecipePriceBreakdownByIDResponseData {
	r.Status = code
	return r
}

// PriceBreakdownByIDImageResponseData wraps the success response with optional headers and status override.
type PriceBreakdownByIDImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewPriceBreakdownByIDImageResponseData creates a new PriceBreakdownByIDImageResponseData with the given body.
func NewPriceBreakdownByIDImageResponseData(body []byte) *PriceBreakdownByIDImageResponseData {
	return &PriceBreakdownByIDImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *PriceBreakdownByIDImageResponseData) WithHeaders(h http.Header) *PriceBreakdownByIDImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *PriceBreakdownByIDImageResponseData) WithStatus(code int) *PriceBreakdownByIDImageResponseData {
	r.Status = code
	return r
}

// GetRecipeIngredientsByIDResponseData wraps the success response with optional headers and status override.
type GetRecipeIngredientsByIDResponseData struct {
	Body    *GetRecipeIngredientsByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRecipeIngredientsByIDResponseData creates a new GetRecipeIngredientsByIDResponseData with the given body.
func NewGetRecipeIngredientsByIDResponseData(body *GetRecipeIngredientsByIDResponse) *GetRecipeIngredientsByIDResponseData {
	return &GetRecipeIngredientsByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRecipeIngredientsByIDResponseData) WithHeaders(h http.Header) *GetRecipeIngredientsByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRecipeIngredientsByIDResponseData) WithStatus(code int) *GetRecipeIngredientsByIDResponseData {
	r.Status = code
	return r
}

// IngredientsByIDImageResponseData wraps the success response with optional headers and status override.
type IngredientsByIDImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewIngredientsByIDImageResponseData creates a new IngredientsByIDImageResponseData with the given body.
func NewIngredientsByIDImageResponseData(body []byte) *IngredientsByIDImageResponseData {
	return &IngredientsByIDImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *IngredientsByIDImageResponseData) WithHeaders(h http.Header) *IngredientsByIDImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *IngredientsByIDImageResponseData) WithStatus(code int) *IngredientsByIDImageResponseData {
	r.Status = code
	return r
}

// GetRecipeNutritionWidgetByIDResponseData wraps the success response with optional headers and status override.
type GetRecipeNutritionWidgetByIDResponseData struct {
	Body    *GetRecipeNutritionWidgetByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRecipeNutritionWidgetByIDResponseData creates a new GetRecipeNutritionWidgetByIDResponseData with the given body.
func NewGetRecipeNutritionWidgetByIDResponseData(body *GetRecipeNutritionWidgetByIDResponse) *GetRecipeNutritionWidgetByIDResponseData {
	return &GetRecipeNutritionWidgetByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRecipeNutritionWidgetByIDResponseData) WithHeaders(h http.Header) *GetRecipeNutritionWidgetByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRecipeNutritionWidgetByIDResponseData) WithStatus(code int) *GetRecipeNutritionWidgetByIDResponseData {
	r.Status = code
	return r
}

// RecipeNutritionByIDImageResponseData wraps the success response with optional headers and status override.
type RecipeNutritionByIDImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewRecipeNutritionByIDImageResponseData creates a new RecipeNutritionByIDImageResponseData with the given body.
func NewRecipeNutritionByIDImageResponseData(body []byte) *RecipeNutritionByIDImageResponseData {
	return &RecipeNutritionByIDImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *RecipeNutritionByIDImageResponseData) WithHeaders(h http.Header) *RecipeNutritionByIDImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *RecipeNutritionByIDImageResponseData) WithStatus(code int) *RecipeNutritionByIDImageResponseData {
	r.Status = code
	return r
}

// RecipeNutritionLabelWidgetResponseData wraps the success response with optional headers and status override.
type RecipeNutritionLabelWidgetResponseData struct {
	Body    *RecipeNutritionLabelWidgetResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewRecipeNutritionLabelWidgetResponseData creates a new RecipeNutritionLabelWidgetResponseData with the given body.
func NewRecipeNutritionLabelWidgetResponseData(body *RecipeNutritionLabelWidgetResponse) *RecipeNutritionLabelWidgetResponseData {
	return &RecipeNutritionLabelWidgetResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *RecipeNutritionLabelWidgetResponseData) WithHeaders(h http.Header) *RecipeNutritionLabelWidgetResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *RecipeNutritionLabelWidgetResponseData) WithStatus(code int) *RecipeNutritionLabelWidgetResponseData {
	r.Status = code
	return r
}

// RecipeNutritionLabelImageResponseData wraps the success response with optional headers and status override.
type RecipeNutritionLabelImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewRecipeNutritionLabelImageResponseData creates a new RecipeNutritionLabelImageResponseData with the given body.
func NewRecipeNutritionLabelImageResponseData(body []byte) *RecipeNutritionLabelImageResponseData {
	return &RecipeNutritionLabelImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *RecipeNutritionLabelImageResponseData) WithHeaders(h http.Header) *RecipeNutritionLabelImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *RecipeNutritionLabelImageResponseData) WithStatus(code int) *RecipeNutritionLabelImageResponseData {
	r.Status = code
	return r
}

// GetAnalyzedRecipeInstructionsResponseData wraps the success response with optional headers and status override.
type GetAnalyzedRecipeInstructionsResponseData struct {
	Body    *GetAnalyzedRecipeInstructionsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetAnalyzedRecipeInstructionsResponseData creates a new GetAnalyzedRecipeInstructionsResponseData with the given body.
func NewGetAnalyzedRecipeInstructionsResponseData(body *GetAnalyzedRecipeInstructionsResponse) *GetAnalyzedRecipeInstructionsResponseData {
	return &GetAnalyzedRecipeInstructionsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetAnalyzedRecipeInstructionsResponseData) WithHeaders(h http.Header) *GetAnalyzedRecipeInstructionsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetAnalyzedRecipeInstructionsResponseData) WithStatus(code int) *GetAnalyzedRecipeInstructionsResponseData {
	r.Status = code
	return r
}

// ExtractRecipeFromWebsiteResponseData wraps the success response with optional headers and status override.
type ExtractRecipeFromWebsiteResponseData struct {
	Body    *ExtractRecipeFromWebsiteResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewExtractRecipeFromWebsiteResponseData creates a new ExtractRecipeFromWebsiteResponseData with the given body.
func NewExtractRecipeFromWebsiteResponseData(body *ExtractRecipeFromWebsiteResponse) *ExtractRecipeFromWebsiteResponseData {
	return &ExtractRecipeFromWebsiteResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ExtractRecipeFromWebsiteResponseData) WithHeaders(h http.Header) *ExtractRecipeFromWebsiteResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ExtractRecipeFromWebsiteResponseData) WithStatus(code int) *ExtractRecipeFromWebsiteResponseData {
	r.Status = code
	return r
}

// VisualizeRecipeIngredientsByIDResponseData wraps the success response with optional headers and status override.
type VisualizeRecipeIngredientsByIDResponseData struct {
	Body    *VisualizeRecipeIngredientsByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeRecipeIngredientsByIDResponseData creates a new VisualizeRecipeIngredientsByIDResponseData with the given body.
func NewVisualizeRecipeIngredientsByIDResponseData(body *VisualizeRecipeIngredientsByIDResponse) *VisualizeRecipeIngredientsByIDResponseData {
	return &VisualizeRecipeIngredientsByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeRecipeIngredientsByIDResponseData) WithHeaders(h http.Header) *VisualizeRecipeIngredientsByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeRecipeIngredientsByIDResponseData) WithStatus(code int) *VisualizeRecipeIngredientsByIDResponseData {
	r.Status = code
	return r
}

// VisualizeRecipeTasteByIDResponseData wraps the success response with optional headers and status override.
type VisualizeRecipeTasteByIDResponseData struct {
	Body    *VisualizeRecipeTasteByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeRecipeTasteByIDResponseData creates a new VisualizeRecipeTasteByIDResponseData with the given body.
func NewVisualizeRecipeTasteByIDResponseData(body *VisualizeRecipeTasteByIDResponse) *VisualizeRecipeTasteByIDResponseData {
	return &VisualizeRecipeTasteByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeRecipeTasteByIDResponseData) WithHeaders(h http.Header) *VisualizeRecipeTasteByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeRecipeTasteByIDResponseData) WithStatus(code int) *VisualizeRecipeTasteByIDResponseData {
	r.Status = code
	return r
}

// VisualizeRecipeEquipmentByIDResponseData wraps the success response with optional headers and status override.
type VisualizeRecipeEquipmentByIDResponseData struct {
	Body    *VisualizeRecipeEquipmentByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeRecipeEquipmentByIDResponseData creates a new VisualizeRecipeEquipmentByIDResponseData with the given body.
func NewVisualizeRecipeEquipmentByIDResponseData(body *VisualizeRecipeEquipmentByIDResponse) *VisualizeRecipeEquipmentByIDResponseData {
	return &VisualizeRecipeEquipmentByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeRecipeEquipmentByIDResponseData) WithHeaders(h http.Header) *VisualizeRecipeEquipmentByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeRecipeEquipmentByIDResponseData) WithStatus(code int) *VisualizeRecipeEquipmentByIDResponseData {
	r.Status = code
	return r
}

// VisualizeRecipePriceBreakdownByIDResponseData wraps the success response with optional headers and status override.
type VisualizeRecipePriceBreakdownByIDResponseData struct {
	Body    *VisualizeRecipePriceBreakdownByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeRecipePriceBreakdownByIDResponseData creates a new VisualizeRecipePriceBreakdownByIDResponseData with the given body.
func NewVisualizeRecipePriceBreakdownByIDResponseData(body *VisualizeRecipePriceBreakdownByIDResponse) *VisualizeRecipePriceBreakdownByIDResponseData {
	return &VisualizeRecipePriceBreakdownByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeRecipePriceBreakdownByIDResponseData) WithHeaders(h http.Header) *VisualizeRecipePriceBreakdownByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeRecipePriceBreakdownByIDResponseData) WithStatus(code int) *VisualizeRecipePriceBreakdownByIDResponseData {
	r.Status = code
	return r
}

// VisualizeRecipeTasteResponseData wraps the success response with optional headers and status override.
type VisualizeRecipeTasteResponseData struct {
	Body    *VisualizeRecipeTasteResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeRecipeTasteResponseData creates a new VisualizeRecipeTasteResponseData with the given body.
func NewVisualizeRecipeTasteResponseData(body *VisualizeRecipeTasteResponse) *VisualizeRecipeTasteResponseData {
	return &VisualizeRecipeTasteResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeRecipeTasteResponseData) WithHeaders(h http.Header) *VisualizeRecipeTasteResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeRecipeTasteResponseData) WithStatus(code int) *VisualizeRecipeTasteResponseData {
	r.Status = code
	return r
}

// VisualizeRecipeNutritionResponseData wraps the success response with optional headers and status override.
type VisualizeRecipeNutritionResponseData struct {
	Body    *VisualizeRecipeNutritionResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeRecipeNutritionResponseData creates a new VisualizeRecipeNutritionResponseData with the given body.
func NewVisualizeRecipeNutritionResponseData(body *VisualizeRecipeNutritionResponse) *VisualizeRecipeNutritionResponseData {
	return &VisualizeRecipeNutritionResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeRecipeNutritionResponseData) WithHeaders(h http.Header) *VisualizeRecipeNutritionResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeRecipeNutritionResponseData) WithStatus(code int) *VisualizeRecipeNutritionResponseData {
	r.Status = code
	return r
}

// VisualizePriceBreakdownResponseData wraps the success response with optional headers and status override.
type VisualizePriceBreakdownResponseData struct {
	Body    *VisualizePriceBreakdownResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizePriceBreakdownResponseData creates a new VisualizePriceBreakdownResponseData with the given body.
func NewVisualizePriceBreakdownResponseData(body *VisualizePriceBreakdownResponse) *VisualizePriceBreakdownResponseData {
	return &VisualizePriceBreakdownResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizePriceBreakdownResponseData) WithHeaders(h http.Header) *VisualizePriceBreakdownResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizePriceBreakdownResponseData) WithStatus(code int) *VisualizePriceBreakdownResponseData {
	r.Status = code
	return r
}

// VisualizeEquipmentResponseData wraps the success response with optional headers and status override.
type VisualizeEquipmentResponseData struct {
	Body    *VisualizeEquipmentResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeEquipmentResponseData creates a new VisualizeEquipmentResponseData with the given body.
func NewVisualizeEquipmentResponseData(body *VisualizeEquipmentResponse) *VisualizeEquipmentResponseData {
	return &VisualizeEquipmentResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeEquipmentResponseData) WithHeaders(h http.Header) *VisualizeEquipmentResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeEquipmentResponseData) WithStatus(code int) *VisualizeEquipmentResponseData {
	r.Status = code
	return r
}

// AnalyzeRecipeResponseData wraps the success response with optional headers and status override.
type AnalyzeRecipeResponseData struct {
	Body    *AnalyzeRecipeResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAnalyzeRecipeResponseData creates a new AnalyzeRecipeResponseData with the given body.
func NewAnalyzeRecipeResponseData(body *AnalyzeRecipeResponse) *AnalyzeRecipeResponseData {
	return &AnalyzeRecipeResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AnalyzeRecipeResponseData) WithHeaders(h http.Header) *AnalyzeRecipeResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AnalyzeRecipeResponseData) WithStatus(code int) *AnalyzeRecipeResponseData {
	r.Status = code
	return r
}

// SummarizeRecipeResponseData wraps the success response with optional headers and status override.
type SummarizeRecipeResponseData struct {
	Body    *SummarizeRecipeResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSummarizeRecipeResponseData creates a new SummarizeRecipeResponseData with the given body.
func NewSummarizeRecipeResponseData(body *SummarizeRecipeResponse) *SummarizeRecipeResponseData {
	return &SummarizeRecipeResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SummarizeRecipeResponseData) WithHeaders(h http.Header) *SummarizeRecipeResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SummarizeRecipeResponseData) WithStatus(code int) *SummarizeRecipeResponseData {
	r.Status = code
	return r
}

// CreateRecipeCardGetResponseData wraps the success response with optional headers and status override.
type CreateRecipeCardGetResponseData struct {
	Body    *CreateRecipeCardGetResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewCreateRecipeCardGetResponseData creates a new CreateRecipeCardGetResponseData with the given body.
func NewCreateRecipeCardGetResponseData(body *CreateRecipeCardGetResponse) *CreateRecipeCardGetResponseData {
	return &CreateRecipeCardGetResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *CreateRecipeCardGetResponseData) WithHeaders(h http.Header) *CreateRecipeCardGetResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *CreateRecipeCardGetResponseData) WithStatus(code int) *CreateRecipeCardGetResponseData {
	r.Status = code
	return r
}

// CreateRecipeCardResponseData wraps the success response with optional headers and status override.
type CreateRecipeCardResponseData struct {
	Body    *CreateRecipeCardResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewCreateRecipeCardResponseData creates a new CreateRecipeCardResponseData with the given body.
func NewCreateRecipeCardResponseData(body *CreateRecipeCardResponse) *CreateRecipeCardResponseData {
	return &CreateRecipeCardResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *CreateRecipeCardResponseData) WithHeaders(h http.Header) *CreateRecipeCardResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *CreateRecipeCardResponseData) WithStatus(code int) *CreateRecipeCardResponseData {
	r.Status = code
	return r
}

// AnalyzeRecipeInstructionsResponseData wraps the success response with optional headers and status override.
type AnalyzeRecipeInstructionsResponseData struct {
	Body    *AnalyzeRecipeInstructionsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAnalyzeRecipeInstructionsResponseData creates a new AnalyzeRecipeInstructionsResponseData with the given body.
func NewAnalyzeRecipeInstructionsResponseData(body *AnalyzeRecipeInstructionsResponse) *AnalyzeRecipeInstructionsResponseData {
	return &AnalyzeRecipeInstructionsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AnalyzeRecipeInstructionsResponseData) WithHeaders(h http.Header) *AnalyzeRecipeInstructionsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AnalyzeRecipeInstructionsResponseData) WithStatus(code int) *AnalyzeRecipeInstructionsResponseData {
	r.Status = code
	return r
}

// ClassifyCuisineResponseData wraps the success response with optional headers and status override.
type ClassifyCuisineResponseData struct {
	Body    *ClassifyCuisineResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewClassifyCuisineResponseData creates a new ClassifyCuisineResponseData with the given body.
func NewClassifyCuisineResponseData(body *ClassifyCuisineResponse) *ClassifyCuisineResponseData {
	return &ClassifyCuisineResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ClassifyCuisineResponseData) WithHeaders(h http.Header) *ClassifyCuisineResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ClassifyCuisineResponseData) WithStatus(code int) *ClassifyCuisineResponseData {
	r.Status = code
	return r
}

// AnalyzeARecipeSearchQueryResponseData wraps the success response with optional headers and status override.
type AnalyzeARecipeSearchQueryResponseData struct {
	Body    *AnalyzeARecipeSearchQueryResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAnalyzeARecipeSearchQueryResponseData creates a new AnalyzeARecipeSearchQueryResponseData with the given body.
func NewAnalyzeARecipeSearchQueryResponseData(body *AnalyzeARecipeSearchQueryResponse) *AnalyzeARecipeSearchQueryResponseData {
	return &AnalyzeARecipeSearchQueryResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AnalyzeARecipeSearchQueryResponseData) WithHeaders(h http.Header) *AnalyzeARecipeSearchQueryResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AnalyzeARecipeSearchQueryResponseData) WithStatus(code int) *AnalyzeARecipeSearchQueryResponseData {
	r.Status = code
	return r
}

// ConvertAmountsResponseData wraps the success response with optional headers and status override.
type ConvertAmountsResponseData struct {
	Body    *ConvertAmountsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewConvertAmountsResponseData creates a new ConvertAmountsResponseData with the given body.
func NewConvertAmountsResponseData(body *ConvertAmountsResponse) *ConvertAmountsResponseData {
	return &ConvertAmountsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ConvertAmountsResponseData) WithHeaders(h http.Header) *ConvertAmountsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ConvertAmountsResponseData) WithStatus(code int) *ConvertAmountsResponseData {
	r.Status = code
	return r
}

// ParseIngredientsResponseData wraps the success response with optional headers and status override.
type ParseIngredientsResponseData struct {
	Body    *ParseIngredientsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewParseIngredientsResponseData creates a new ParseIngredientsResponseData with the given body.
func NewParseIngredientsResponseData(body *ParseIngredientsResponse) *ParseIngredientsResponseData {
	return &ParseIngredientsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ParseIngredientsResponseData) WithHeaders(h http.Header) *ParseIngredientsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ParseIngredientsResponseData) WithStatus(code int) *ParseIngredientsResponseData {
	r.Status = code
	return r
}

// VisualizeRecipeNutritionByIDResponseData wraps the success response with optional headers and status override.
type VisualizeRecipeNutritionByIDResponseData struct {
	Body    *VisualizeRecipeNutritionByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeRecipeNutritionByIDResponseData creates a new VisualizeRecipeNutritionByIDResponseData with the given body.
func NewVisualizeRecipeNutritionByIDResponseData(body *VisualizeRecipeNutritionByIDResponse) *VisualizeRecipeNutritionByIDResponseData {
	return &VisualizeRecipeNutritionByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeRecipeNutritionByIDResponseData) WithHeaders(h http.Header) *VisualizeRecipeNutritionByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeRecipeNutritionByIDResponseData) WithStatus(code int) *VisualizeRecipeNutritionByIDResponseData {
	r.Status = code
	return r
}

// VisualizeIngredientsResponseData wraps the success response with optional headers and status override.
type VisualizeIngredientsResponseData struct {
	Body    *VisualizeIngredientsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeIngredientsResponseData creates a new VisualizeIngredientsResponseData with the given body.
func NewVisualizeIngredientsResponseData(body *VisualizeIngredientsResponse) *VisualizeIngredientsResponseData {
	return &VisualizeIngredientsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeIngredientsResponseData) WithHeaders(h http.Header) *VisualizeIngredientsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeIngredientsResponseData) WithStatus(code int) *VisualizeIngredientsResponseData {
	r.Status = code
	return r
}

// GuessNutritionByDishNameResponseData wraps the success response with optional headers and status override.
type GuessNutritionByDishNameResponseData struct {
	Body    *GuessNutritionByDishNameResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGuessNutritionByDishNameResponseData creates a new GuessNutritionByDishNameResponseData with the given body.
func NewGuessNutritionByDishNameResponseData(body *GuessNutritionByDishNameResponse) *GuessNutritionByDishNameResponseData {
	return &GuessNutritionByDishNameResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GuessNutritionByDishNameResponseData) WithHeaders(h http.Header) *GuessNutritionByDishNameResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GuessNutritionByDishNameResponseData) WithStatus(code int) *GuessNutritionByDishNameResponseData {
	r.Status = code
	return r
}

// GetIngredientInformationResponseData wraps the success response with optional headers and status override.
type GetIngredientInformationResponseData struct {
	Body    *GetIngredientInformationResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetIngredientInformationResponseData creates a new GetIngredientInformationResponseData with the given body.
func NewGetIngredientInformationResponseData(body *GetIngredientInformationResponse) *GetIngredientInformationResponseData {
	return &GetIngredientInformationResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetIngredientInformationResponseData) WithHeaders(h http.Header) *GetIngredientInformationResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetIngredientInformationResponseData) WithStatus(code int) *GetIngredientInformationResponseData {
	r.Status = code
	return r
}

// ComputeIngredientAmountResponseData wraps the success response with optional headers and status override.
type ComputeIngredientAmountResponseData struct {
	Body    *ComputeIngredientAmountResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewComputeIngredientAmountResponseData creates a new ComputeIngredientAmountResponseData with the given body.
func NewComputeIngredientAmountResponseData(body *ComputeIngredientAmountResponse) *ComputeIngredientAmountResponseData {
	return &ComputeIngredientAmountResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ComputeIngredientAmountResponseData) WithHeaders(h http.Header) *ComputeIngredientAmountResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ComputeIngredientAmountResponseData) WithStatus(code int) *ComputeIngredientAmountResponseData {
	r.Status = code
	return r
}

// ComputeGlycemicLoadResponseData wraps the success response with optional headers and status override.
type ComputeGlycemicLoadResponseData struct {
	Body    *ComputeGlycemicLoadResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewComputeGlycemicLoadResponseData creates a new ComputeGlycemicLoadResponseData with the given body.
func NewComputeGlycemicLoadResponseData(body *ComputeGlycemicLoadResponse) *ComputeGlycemicLoadResponseData {
	return &ComputeGlycemicLoadResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ComputeGlycemicLoadResponseData) WithHeaders(h http.Header) *ComputeGlycemicLoadResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ComputeGlycemicLoadResponseData) WithStatus(code int) *ComputeGlycemicLoadResponseData {
	r.Status = code
	return r
}

// AutocompleteIngredientSearchResponseData wraps the success response with optional headers and status override.
type AutocompleteIngredientSearchResponseData struct {
	Body    *AutocompleteIngredientSearchResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAutocompleteIngredientSearchResponseData creates a new AutocompleteIngredientSearchResponseData with the given body.
func NewAutocompleteIngredientSearchResponseData(body *AutocompleteIngredientSearchResponse) *AutocompleteIngredientSearchResponseData {
	return &AutocompleteIngredientSearchResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AutocompleteIngredientSearchResponseData) WithHeaders(h http.Header) *AutocompleteIngredientSearchResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AutocompleteIngredientSearchResponseData) WithStatus(code int) *AutocompleteIngredientSearchResponseData {
	r.Status = code
	return r
}

// IngredientSearchResponseData wraps the success response with optional headers and status override.
type IngredientSearchResponseData struct {
	Body    *IngredientSearchResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewIngredientSearchResponseData creates a new IngredientSearchResponseData with the given body.
func NewIngredientSearchResponseData(body *IngredientSearchResponse) *IngredientSearchResponseData {
	return &IngredientSearchResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *IngredientSearchResponseData) WithHeaders(h http.Header) *IngredientSearchResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *IngredientSearchResponseData) WithStatus(code int) *IngredientSearchResponseData {
	r.Status = code
	return r
}

// GetIngredientSubstitutesResponseData wraps the success response with optional headers and status override.
type GetIngredientSubstitutesResponseData struct {
	Body    *GetIngredientSubstitutesResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetIngredientSubstitutesResponseData creates a new GetIngredientSubstitutesResponseData with the given body.
func NewGetIngredientSubstitutesResponseData(body *GetIngredientSubstitutesResponse) *GetIngredientSubstitutesResponseData {
	return &GetIngredientSubstitutesResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetIngredientSubstitutesResponseData) WithHeaders(h http.Header) *GetIngredientSubstitutesResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetIngredientSubstitutesResponseData) WithStatus(code int) *GetIngredientSubstitutesResponseData {
	r.Status = code
	return r
}

// GetIngredientSubstitutesByIDResponseData wraps the success response with optional headers and status override.
type GetIngredientSubstitutesByIDResponseData struct {
	Body    *GetIngredientSubstitutesByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetIngredientSubstitutesByIDResponseData creates a new GetIngredientSubstitutesByIDResponseData with the given body.
func NewGetIngredientSubstitutesByIDResponseData(body *GetIngredientSubstitutesByIDResponse) *GetIngredientSubstitutesByIDResponseData {
	return &GetIngredientSubstitutesByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetIngredientSubstitutesByIDResponseData) WithHeaders(h http.Header) *GetIngredientSubstitutesByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetIngredientSubstitutesByIDResponseData) WithStatus(code int) *GetIngredientSubstitutesByIDResponseData {
	r.Status = code
	return r
}

// SearchGroceryProductsResponseData wraps the success response with optional headers and status override.
type SearchGroceryProductsResponseData struct {
	Body    *SearchGroceryProductsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchGroceryProductsResponseData creates a new SearchGroceryProductsResponseData with the given body.
func NewSearchGroceryProductsResponseData(body *SearchGroceryProductsResponse) *SearchGroceryProductsResponseData {
	return &SearchGroceryProductsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchGroceryProductsResponseData) WithHeaders(h http.Header) *SearchGroceryProductsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchGroceryProductsResponseData) WithStatus(code int) *SearchGroceryProductsResponseData {
	r.Status = code
	return r
}

// SearchGroceryProductsByUPCResponseData wraps the success response with optional headers and status override.
type SearchGroceryProductsByUPCResponseData struct {
	Body    *SearchGroceryProductsByUPCResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchGroceryProductsByUPCResponseData creates a new SearchGroceryProductsByUPCResponseData with the given body.
func NewSearchGroceryProductsByUPCResponseData(body *SearchGroceryProductsByUPCResponse) *SearchGroceryProductsByUPCResponseData {
	return &SearchGroceryProductsByUPCResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchGroceryProductsByUPCResponseData) WithHeaders(h http.Header) *SearchGroceryProductsByUPCResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchGroceryProductsByUPCResponseData) WithStatus(code int) *SearchGroceryProductsByUPCResponseData {
	r.Status = code
	return r
}

// SearchCustomFoodsResponseData wraps the success response with optional headers and status override.
type SearchCustomFoodsResponseData struct {
	Body    *SearchCustomFoodsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchCustomFoodsResponseData creates a new SearchCustomFoodsResponseData with the given body.
func NewSearchCustomFoodsResponseData(body *SearchCustomFoodsResponse) *SearchCustomFoodsResponseData {
	return &SearchCustomFoodsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchCustomFoodsResponseData) WithHeaders(h http.Header) *SearchCustomFoodsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchCustomFoodsResponseData) WithStatus(code int) *SearchCustomFoodsResponseData {
	r.Status = code
	return r
}

// GetProductInformationResponseData wraps the success response with optional headers and status override.
type GetProductInformationResponseData struct {
	Body    *GetProductInformationResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetProductInformationResponseData creates a new GetProductInformationResponseData with the given body.
func NewGetProductInformationResponseData(body *GetProductInformationResponse) *GetProductInformationResponseData {
	return &GetProductInformationResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetProductInformationResponseData) WithHeaders(h http.Header) *GetProductInformationResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetProductInformationResponseData) WithStatus(code int) *GetProductInformationResponseData {
	r.Status = code
	return r
}

// GetComparableProductsResponseData wraps the success response with optional headers and status override.
type GetComparableProductsResponseData struct {
	Body    *GetComparableProductsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetComparableProductsResponseData creates a new GetComparableProductsResponseData with the given body.
func NewGetComparableProductsResponseData(body *GetComparableProductsResponse) *GetComparableProductsResponseData {
	return &GetComparableProductsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetComparableProductsResponseData) WithHeaders(h http.Header) *GetComparableProductsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetComparableProductsResponseData) WithStatus(code int) *GetComparableProductsResponseData {
	r.Status = code
	return r
}

// AutocompleteProductSearchResponseData wraps the success response with optional headers and status override.
type AutocompleteProductSearchResponseData struct {
	Body    *AutocompleteProductSearchResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAutocompleteProductSearchResponseData creates a new AutocompleteProductSearchResponseData with the given body.
func NewAutocompleteProductSearchResponseData(body *AutocompleteProductSearchResponse) *AutocompleteProductSearchResponseData {
	return &AutocompleteProductSearchResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AutocompleteProductSearchResponseData) WithHeaders(h http.Header) *AutocompleteProductSearchResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AutocompleteProductSearchResponseData) WithStatus(code int) *AutocompleteProductSearchResponseData {
	r.Status = code
	return r
}

// VisualizeProductNutritionByIDResponseData wraps the success response with optional headers and status override.
type VisualizeProductNutritionByIDResponseData struct {
	Body    *VisualizeProductNutritionByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeProductNutritionByIDResponseData creates a new VisualizeProductNutritionByIDResponseData with the given body.
func NewVisualizeProductNutritionByIDResponseData(body *VisualizeProductNutritionByIDResponse) *VisualizeProductNutritionByIDResponseData {
	return &VisualizeProductNutritionByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeProductNutritionByIDResponseData) WithHeaders(h http.Header) *VisualizeProductNutritionByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeProductNutritionByIDResponseData) WithStatus(code int) *VisualizeProductNutritionByIDResponseData {
	r.Status = code
	return r
}

// ProductNutritionByIDImageResponseData wraps the success response with optional headers and status override.
type ProductNutritionByIDImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewProductNutritionByIDImageResponseData creates a new ProductNutritionByIDImageResponseData with the given body.
func NewProductNutritionByIDImageResponseData(body []byte) *ProductNutritionByIDImageResponseData {
	return &ProductNutritionByIDImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ProductNutritionByIDImageResponseData) WithHeaders(h http.Header) *ProductNutritionByIDImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ProductNutritionByIDImageResponseData) WithStatus(code int) *ProductNutritionByIDImageResponseData {
	r.Status = code
	return r
}

// ProductNutritionLabelWidgetResponseData wraps the success response with optional headers and status override.
type ProductNutritionLabelWidgetResponseData struct {
	Body    *ProductNutritionLabelWidgetResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewProductNutritionLabelWidgetResponseData creates a new ProductNutritionLabelWidgetResponseData with the given body.
func NewProductNutritionLabelWidgetResponseData(body *ProductNutritionLabelWidgetResponse) *ProductNutritionLabelWidgetResponseData {
	return &ProductNutritionLabelWidgetResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ProductNutritionLabelWidgetResponseData) WithHeaders(h http.Header) *ProductNutritionLabelWidgetResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ProductNutritionLabelWidgetResponseData) WithStatus(code int) *ProductNutritionLabelWidgetResponseData {
	r.Status = code
	return r
}

// ProductNutritionLabelImageResponseData wraps the success response with optional headers and status override.
type ProductNutritionLabelImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewProductNutritionLabelImageResponseData creates a new ProductNutritionLabelImageResponseData with the given body.
func NewProductNutritionLabelImageResponseData(body []byte) *ProductNutritionLabelImageResponseData {
	return &ProductNutritionLabelImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ProductNutritionLabelImageResponseData) WithHeaders(h http.Header) *ProductNutritionLabelImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ProductNutritionLabelImageResponseData) WithStatus(code int) *ProductNutritionLabelImageResponseData {
	r.Status = code
	return r
}

// ClassifyGroceryProductResponseData wraps the success response with optional headers and status override.
type ClassifyGroceryProductResponseData struct {
	Body    *ClassifyGroceryProductResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewClassifyGroceryProductResponseData creates a new ClassifyGroceryProductResponseData with the given body.
func NewClassifyGroceryProductResponseData(body *ClassifyGroceryProductResponse) *ClassifyGroceryProductResponseData {
	return &ClassifyGroceryProductResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ClassifyGroceryProductResponseData) WithHeaders(h http.Header) *ClassifyGroceryProductResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ClassifyGroceryProductResponseData) WithStatus(code int) *ClassifyGroceryProductResponseData {
	r.Status = code
	return r
}

// ClassifyGroceryProductBulkResponseData wraps the success response with optional headers and status override.
type ClassifyGroceryProductBulkResponseData struct {
	Body    *ClassifyGroceryProductBulkResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewClassifyGroceryProductBulkResponseData creates a new ClassifyGroceryProductBulkResponseData with the given body.
func NewClassifyGroceryProductBulkResponseData(body *ClassifyGroceryProductBulkResponse) *ClassifyGroceryProductBulkResponseData {
	return &ClassifyGroceryProductBulkResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ClassifyGroceryProductBulkResponseData) WithHeaders(h http.Header) *ClassifyGroceryProductBulkResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ClassifyGroceryProductBulkResponseData) WithStatus(code int) *ClassifyGroceryProductBulkResponseData {
	r.Status = code
	return r
}

// MapIngredientsToGroceryProductsResponseData wraps the success response with optional headers and status override.
type MapIngredientsToGroceryProductsResponseData struct {
	Body    *MapIngredientsToGroceryProductsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewMapIngredientsToGroceryProductsResponseData creates a new MapIngredientsToGroceryProductsResponseData with the given body.
func NewMapIngredientsToGroceryProductsResponseData(body *MapIngredientsToGroceryProductsResponse) *MapIngredientsToGroceryProductsResponseData {
	return &MapIngredientsToGroceryProductsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *MapIngredientsToGroceryProductsResponseData) WithHeaders(h http.Header) *MapIngredientsToGroceryProductsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *MapIngredientsToGroceryProductsResponseData) WithStatus(code int) *MapIngredientsToGroceryProductsResponseData {
	r.Status = code
	return r
}

// AutocompleteMenuItemSearchResponseData wraps the success response with optional headers and status override.
type AutocompleteMenuItemSearchResponseData struct {
	Body    *AutocompleteMenuItemSearchResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAutocompleteMenuItemSearchResponseData creates a new AutocompleteMenuItemSearchResponseData with the given body.
func NewAutocompleteMenuItemSearchResponseData(body *AutocompleteMenuItemSearchResponse) *AutocompleteMenuItemSearchResponseData {
	return &AutocompleteMenuItemSearchResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AutocompleteMenuItemSearchResponseData) WithHeaders(h http.Header) *AutocompleteMenuItemSearchResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AutocompleteMenuItemSearchResponseData) WithStatus(code int) *AutocompleteMenuItemSearchResponseData {
	r.Status = code
	return r
}

// SearchMenuItemsResponseData wraps the success response with optional headers and status override.
type SearchMenuItemsResponseData struct {
	Body    *SearchMenuItemsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchMenuItemsResponseData creates a new SearchMenuItemsResponseData with the given body.
func NewSearchMenuItemsResponseData(body *SearchMenuItemsResponse) *SearchMenuItemsResponseData {
	return &SearchMenuItemsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchMenuItemsResponseData) WithHeaders(h http.Header) *SearchMenuItemsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchMenuItemsResponseData) WithStatus(code int) *SearchMenuItemsResponseData {
	r.Status = code
	return r
}

// GetMenuItemInformationResponseData wraps the success response with optional headers and status override.
type GetMenuItemInformationResponseData struct {
	Body    *GetMenuItemInformationResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetMenuItemInformationResponseData creates a new GetMenuItemInformationResponseData with the given body.
func NewGetMenuItemInformationResponseData(body *GetMenuItemInformationResponse) *GetMenuItemInformationResponseData {
	return &GetMenuItemInformationResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetMenuItemInformationResponseData) WithHeaders(h http.Header) *GetMenuItemInformationResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetMenuItemInformationResponseData) WithStatus(code int) *GetMenuItemInformationResponseData {
	r.Status = code
	return r
}

// VisualizeMenuItemNutritionByIDResponseData wraps the success response with optional headers and status override.
type VisualizeMenuItemNutritionByIDResponseData struct {
	Body    *VisualizeMenuItemNutritionByIDResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewVisualizeMenuItemNutritionByIDResponseData creates a new VisualizeMenuItemNutritionByIDResponseData with the given body.
func NewVisualizeMenuItemNutritionByIDResponseData(body *VisualizeMenuItemNutritionByIDResponse) *VisualizeMenuItemNutritionByIDResponseData {
	return &VisualizeMenuItemNutritionByIDResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *VisualizeMenuItemNutritionByIDResponseData) WithHeaders(h http.Header) *VisualizeMenuItemNutritionByIDResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *VisualizeMenuItemNutritionByIDResponseData) WithStatus(code int) *VisualizeMenuItemNutritionByIDResponseData {
	r.Status = code
	return r
}

// MenuItemNutritionByIDImageResponseData wraps the success response with optional headers and status override.
type MenuItemNutritionByIDImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewMenuItemNutritionByIDImageResponseData creates a new MenuItemNutritionByIDImageResponseData with the given body.
func NewMenuItemNutritionByIDImageResponseData(body []byte) *MenuItemNutritionByIDImageResponseData {
	return &MenuItemNutritionByIDImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *MenuItemNutritionByIDImageResponseData) WithHeaders(h http.Header) *MenuItemNutritionByIDImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *MenuItemNutritionByIDImageResponseData) WithStatus(code int) *MenuItemNutritionByIDImageResponseData {
	r.Status = code
	return r
}

// MenuItemNutritionLabelWidgetResponseData wraps the success response with optional headers and status override.
type MenuItemNutritionLabelWidgetResponseData struct {
	Body    *MenuItemNutritionLabelWidgetResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewMenuItemNutritionLabelWidgetResponseData creates a new MenuItemNutritionLabelWidgetResponseData with the given body.
func NewMenuItemNutritionLabelWidgetResponseData(body *MenuItemNutritionLabelWidgetResponse) *MenuItemNutritionLabelWidgetResponseData {
	return &MenuItemNutritionLabelWidgetResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *MenuItemNutritionLabelWidgetResponseData) WithHeaders(h http.Header) *MenuItemNutritionLabelWidgetResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *MenuItemNutritionLabelWidgetResponseData) WithStatus(code int) *MenuItemNutritionLabelWidgetResponseData {
	r.Status = code
	return r
}

// MenuItemNutritionLabelImageResponseData wraps the success response with optional headers and status override.
type MenuItemNutritionLabelImageResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewMenuItemNutritionLabelImageResponseData creates a new MenuItemNutritionLabelImageResponseData with the given body.
func NewMenuItemNutritionLabelImageResponseData(body []byte) *MenuItemNutritionLabelImageResponseData {
	return &MenuItemNutritionLabelImageResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *MenuItemNutritionLabelImageResponseData) WithHeaders(h http.Header) *MenuItemNutritionLabelImageResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *MenuItemNutritionLabelImageResponseData) WithStatus(code int) *MenuItemNutritionLabelImageResponseData {
	r.Status = code
	return r
}

// GenerateMealPlanResponseData wraps the success response with optional headers and status override.
type GenerateMealPlanResponseData struct {
	Body    *GenerateMealPlanResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGenerateMealPlanResponseData creates a new GenerateMealPlanResponseData with the given body.
func NewGenerateMealPlanResponseData(body *GenerateMealPlanResponse) *GenerateMealPlanResponseData {
	return &GenerateMealPlanResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GenerateMealPlanResponseData) WithHeaders(h http.Header) *GenerateMealPlanResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GenerateMealPlanResponseData) WithStatus(code int) *GenerateMealPlanResponseData {
	r.Status = code
	return r
}

// GetMealPlanWeekResponseData wraps the success response with optional headers and status override.
type GetMealPlanWeekResponseData struct {
	Body    *GetMealPlanWeekResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetMealPlanWeekResponseData creates a new GetMealPlanWeekResponseData with the given body.
func NewGetMealPlanWeekResponseData(body *GetMealPlanWeekResponse) *GetMealPlanWeekResponseData {
	return &GetMealPlanWeekResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetMealPlanWeekResponseData) WithHeaders(h http.Header) *GetMealPlanWeekResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetMealPlanWeekResponseData) WithStatus(code int) *GetMealPlanWeekResponseData {
	r.Status = code
	return r
}

// ClearMealPlanDayResponseData wraps the success response with optional headers and status override.
type ClearMealPlanDayResponseData struct {
	Body    *ClearMealPlanDayResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewClearMealPlanDayResponseData creates a new ClearMealPlanDayResponseData with the given body.
func NewClearMealPlanDayResponseData(body *ClearMealPlanDayResponse) *ClearMealPlanDayResponseData {
	return &ClearMealPlanDayResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ClearMealPlanDayResponseData) WithHeaders(h http.Header) *ClearMealPlanDayResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ClearMealPlanDayResponseData) WithStatus(code int) *ClearMealPlanDayResponseData {
	r.Status = code
	return r
}

// AddToMealPlanResponseData wraps the success response with optional headers and status override.
type AddToMealPlanResponseData struct {
	Body    *AddToMealPlanResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAddToMealPlanResponseData creates a new AddToMealPlanResponseData with the given body.
func NewAddToMealPlanResponseData(body *AddToMealPlanResponse) *AddToMealPlanResponseData {
	return &AddToMealPlanResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AddToMealPlanResponseData) WithHeaders(h http.Header) *AddToMealPlanResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AddToMealPlanResponseData) WithStatus(code int) *AddToMealPlanResponseData {
	r.Status = code
	return r
}

// DeleteFromMealPlanResponseData wraps the success response with optional headers and status override.
type DeleteFromMealPlanResponseData struct {
	Body    *DeleteFromMealPlanResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewDeleteFromMealPlanResponseData creates a new DeleteFromMealPlanResponseData with the given body.
func NewDeleteFromMealPlanResponseData(body *DeleteFromMealPlanResponse) *DeleteFromMealPlanResponseData {
	return &DeleteFromMealPlanResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *DeleteFromMealPlanResponseData) WithHeaders(h http.Header) *DeleteFromMealPlanResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *DeleteFromMealPlanResponseData) WithStatus(code int) *DeleteFromMealPlanResponseData {
	r.Status = code
	return r
}

// GetMealPlanTemplatesResponseData wraps the success response with optional headers and status override.
type GetMealPlanTemplatesResponseData struct {
	Body    *GetMealPlanTemplatesResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetMealPlanTemplatesResponseData creates a new GetMealPlanTemplatesResponseData with the given body.
func NewGetMealPlanTemplatesResponseData(body *GetMealPlanTemplatesResponse) *GetMealPlanTemplatesResponseData {
	return &GetMealPlanTemplatesResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetMealPlanTemplatesResponseData) WithHeaders(h http.Header) *GetMealPlanTemplatesResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetMealPlanTemplatesResponseData) WithStatus(code int) *GetMealPlanTemplatesResponseData {
	r.Status = code
	return r
}

// AddMealPlanTemplateResponseData wraps the success response with optional headers and status override.
type AddMealPlanTemplateResponseData struct {
	Body    *AddMealPlanTemplateResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAddMealPlanTemplateResponseData creates a new AddMealPlanTemplateResponseData with the given body.
func NewAddMealPlanTemplateResponseData(body *AddMealPlanTemplateResponse) *AddMealPlanTemplateResponseData {
	return &AddMealPlanTemplateResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AddMealPlanTemplateResponseData) WithHeaders(h http.Header) *AddMealPlanTemplateResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AddMealPlanTemplateResponseData) WithStatus(code int) *AddMealPlanTemplateResponseData {
	r.Status = code
	return r
}

// GetMealPlanTemplateResponseData wraps the success response with optional headers and status override.
type GetMealPlanTemplateResponseData struct {
	Body    *GetMealPlanTemplateResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetMealPlanTemplateResponseData creates a new GetMealPlanTemplateResponseData with the given body.
func NewGetMealPlanTemplateResponseData(body *GetMealPlanTemplateResponse) *GetMealPlanTemplateResponseData {
	return &GetMealPlanTemplateResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetMealPlanTemplateResponseData) WithHeaders(h http.Header) *GetMealPlanTemplateResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetMealPlanTemplateResponseData) WithStatus(code int) *GetMealPlanTemplateResponseData {
	r.Status = code
	return r
}

// DeleteMealPlanTemplateResponseData wraps the success response with optional headers and status override.
type DeleteMealPlanTemplateResponseData struct {
	Body    *DeleteMealPlanTemplateResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewDeleteMealPlanTemplateResponseData creates a new DeleteMealPlanTemplateResponseData with the given body.
func NewDeleteMealPlanTemplateResponseData(body *DeleteMealPlanTemplateResponse) *DeleteMealPlanTemplateResponseData {
	return &DeleteMealPlanTemplateResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *DeleteMealPlanTemplateResponseData) WithHeaders(h http.Header) *DeleteMealPlanTemplateResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *DeleteMealPlanTemplateResponseData) WithStatus(code int) *DeleteMealPlanTemplateResponseData {
	r.Status = code
	return r
}

// GetShoppingListResponseData wraps the success response with optional headers and status override.
type GetShoppingListResponseData struct {
	Body    *GetShoppingListResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetShoppingListResponseData creates a new GetShoppingListResponseData with the given body.
func NewGetShoppingListResponseData(body *GetShoppingListResponse) *GetShoppingListResponseData {
	return &GetShoppingListResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetShoppingListResponseData) WithHeaders(h http.Header) *GetShoppingListResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetShoppingListResponseData) WithStatus(code int) *GetShoppingListResponseData {
	r.Status = code
	return r
}

// GenerateShoppingListResponseData wraps the success response with optional headers and status override.
type GenerateShoppingListResponseData struct {
	Body    *GenerateShoppingListResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGenerateShoppingListResponseData creates a new GenerateShoppingListResponseData with the given body.
func NewGenerateShoppingListResponseData(body *GenerateShoppingListResponse) *GenerateShoppingListResponseData {
	return &GenerateShoppingListResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GenerateShoppingListResponseData) WithHeaders(h http.Header) *GenerateShoppingListResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GenerateShoppingListResponseData) WithStatus(code int) *GenerateShoppingListResponseData {
	r.Status = code
	return r
}

// ConnectUserResponseData wraps the success response with optional headers and status override.
type ConnectUserResponseData struct {
	Body    *ConnectUserResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewConnectUserResponseData creates a new ConnectUserResponseData with the given body.
func NewConnectUserResponseData(body *ConnectUserResponse) *ConnectUserResponseData {
	return &ConnectUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ConnectUserResponseData) WithHeaders(h http.Header) *ConnectUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ConnectUserResponseData) WithStatus(code int) *ConnectUserResponseData {
	r.Status = code
	return r
}

// AddToShoppingListResponseData wraps the success response with optional headers and status override.
type AddToShoppingListResponseData struct {
	Body    *AddToShoppingListResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewAddToShoppingListResponseData creates a new AddToShoppingListResponseData with the given body.
func NewAddToShoppingListResponseData(body *AddToShoppingListResponse) *AddToShoppingListResponseData {
	return &AddToShoppingListResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *AddToShoppingListResponseData) WithHeaders(h http.Header) *AddToShoppingListResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *AddToShoppingListResponseData) WithStatus(code int) *AddToShoppingListResponseData {
	r.Status = code
	return r
}

// DeleteFromShoppingListResponseData wraps the success response with optional headers and status override.
type DeleteFromShoppingListResponseData struct {
	Body    *DeleteFromShoppingListResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewDeleteFromShoppingListResponseData creates a new DeleteFromShoppingListResponseData with the given body.
func NewDeleteFromShoppingListResponseData(body *DeleteFromShoppingListResponse) *DeleteFromShoppingListResponseData {
	return &DeleteFromShoppingListResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *DeleteFromShoppingListResponseData) WithHeaders(h http.Header) *DeleteFromShoppingListResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *DeleteFromShoppingListResponseData) WithStatus(code int) *DeleteFromShoppingListResponseData {
	r.Status = code
	return r
}

// SearchRestaurantsResponseData wraps the success response with optional headers and status override.
type SearchRestaurantsResponseData struct {
	Body    *SearchRestaurantsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchRestaurantsResponseData creates a new SearchRestaurantsResponseData with the given body.
func NewSearchRestaurantsResponseData(body *SearchRestaurantsResponse) *SearchRestaurantsResponseData {
	return &SearchRestaurantsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchRestaurantsResponseData) WithHeaders(h http.Header) *SearchRestaurantsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchRestaurantsResponseData) WithStatus(code int) *SearchRestaurantsResponseData {
	r.Status = code
	return r
}

// GetDishPairingForWineResponseData wraps the success response with optional headers and status override.
type GetDishPairingForWineResponseData struct {
	Body    *GetDishPairingForWineResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetDishPairingForWineResponseData creates a new GetDishPairingForWineResponseData with the given body.
func NewGetDishPairingForWineResponseData(body *GetDishPairingForWineResponse) *GetDishPairingForWineResponseData {
	return &GetDishPairingForWineResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetDishPairingForWineResponseData) WithHeaders(h http.Header) *GetDishPairingForWineResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetDishPairingForWineResponseData) WithStatus(code int) *GetDishPairingForWineResponseData {
	r.Status = code
	return r
}

// GetWinePairingResponseData wraps the success response with optional headers and status override.
type GetWinePairingResponseData struct {
	Body    *GetWinePairingResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetWinePairingResponseData creates a new GetWinePairingResponseData with the given body.
func NewGetWinePairingResponseData(body *GetWinePairingResponse) *GetWinePairingResponseData {
	return &GetWinePairingResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetWinePairingResponseData) WithHeaders(h http.Header) *GetWinePairingResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetWinePairingResponseData) WithStatus(code int) *GetWinePairingResponseData {
	r.Status = code
	return r
}

// GetWineDescriptionResponseData wraps the success response with optional headers and status override.
type GetWineDescriptionResponseData struct {
	Body    *GetWineDescriptionResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetWineDescriptionResponseData creates a new GetWineDescriptionResponseData with the given body.
func NewGetWineDescriptionResponseData(body *GetWineDescriptionResponse) *GetWineDescriptionResponseData {
	return &GetWineDescriptionResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetWineDescriptionResponseData) WithHeaders(h http.Header) *GetWineDescriptionResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetWineDescriptionResponseData) WithStatus(code int) *GetWineDescriptionResponseData {
	r.Status = code
	return r
}

// GetWineRecommendationResponseData wraps the success response with optional headers and status override.
type GetWineRecommendationResponseData struct {
	Body    *GetWineRecommendationResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetWineRecommendationResponseData creates a new GetWineRecommendationResponseData with the given body.
func NewGetWineRecommendationResponseData(body *GetWineRecommendationResponse) *GetWineRecommendationResponseData {
	return &GetWineRecommendationResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetWineRecommendationResponseData) WithHeaders(h http.Header) *GetWineRecommendationResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetWineRecommendationResponseData) WithStatus(code int) *GetWineRecommendationResponseData {
	r.Status = code
	return r
}

// ImageClassificationByURLResponseData wraps the success response with optional headers and status override.
type ImageClassificationByURLResponseData struct {
	Body    *ImageClassificationByURLResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewImageClassificationByURLResponseData creates a new ImageClassificationByURLResponseData with the given body.
func NewImageClassificationByURLResponseData(body *ImageClassificationByURLResponse) *ImageClassificationByURLResponseData {
	return &ImageClassificationByURLResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ImageClassificationByURLResponseData) WithHeaders(h http.Header) *ImageClassificationByURLResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ImageClassificationByURLResponseData) WithStatus(code int) *ImageClassificationByURLResponseData {
	r.Status = code
	return r
}

// ImageAnalysisByURLResponseData wraps the success response with optional headers and status override.
type ImageAnalysisByURLResponseData struct {
	Body    *ImageAnalysisByURLResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewImageAnalysisByURLResponseData creates a new ImageAnalysisByURLResponseData with the given body.
func NewImageAnalysisByURLResponseData(body *ImageAnalysisByURLResponse) *ImageAnalysisByURLResponseData {
	return &ImageAnalysisByURLResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ImageAnalysisByURLResponseData) WithHeaders(h http.Header) *ImageAnalysisByURLResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ImageAnalysisByURLResponseData) WithStatus(code int) *ImageAnalysisByURLResponseData {
	r.Status = code
	return r
}

// QuickAnswerResponseData wraps the success response with optional headers and status override.
type QuickAnswerResponseData struct {
	Body    *QuickAnswerResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewQuickAnswerResponseData creates a new QuickAnswerResponseData with the given body.
func NewQuickAnswerResponseData(body *QuickAnswerResponse) *QuickAnswerResponseData {
	return &QuickAnswerResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *QuickAnswerResponseData) WithHeaders(h http.Header) *QuickAnswerResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *QuickAnswerResponseData) WithStatus(code int) *QuickAnswerResponseData {
	r.Status = code
	return r
}

// DetectFoodInTextResponseData wraps the success response with optional headers and status override.
type DetectFoodInTextResponseData struct {
	Body    *DetectFoodInTextResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewDetectFoodInTextResponseData creates a new DetectFoodInTextResponseData with the given body.
func NewDetectFoodInTextResponseData(body *DetectFoodInTextResponse) *DetectFoodInTextResponseData {
	return &DetectFoodInTextResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *DetectFoodInTextResponseData) WithHeaders(h http.Header) *DetectFoodInTextResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *DetectFoodInTextResponseData) WithStatus(code int) *DetectFoodInTextResponseData {
	r.Status = code
	return r
}

// SearchSiteContentResponseData wraps the success response with optional headers and status override.
type SearchSiteContentResponseData struct {
	Body    *SearchSiteContentResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchSiteContentResponseData creates a new SearchSiteContentResponseData with the given body.
func NewSearchSiteContentResponseData(body *SearchSiteContentResponse) *SearchSiteContentResponseData {
	return &SearchSiteContentResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchSiteContentResponseData) WithHeaders(h http.Header) *SearchSiteContentResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchSiteContentResponseData) WithStatus(code int) *SearchSiteContentResponseData {
	r.Status = code
	return r
}

// SearchAllFoodResponseData wraps the success response with optional headers and status override.
type SearchAllFoodResponseData struct {
	Body    *SearchAllFoodResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchAllFoodResponseData creates a new SearchAllFoodResponseData with the given body.
func NewSearchAllFoodResponseData(body *SearchAllFoodResponse) *SearchAllFoodResponseData {
	return &SearchAllFoodResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchAllFoodResponseData) WithHeaders(h http.Header) *SearchAllFoodResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchAllFoodResponseData) WithStatus(code int) *SearchAllFoodResponseData {
	r.Status = code
	return r
}

// SearchFoodVideosResponseData wraps the success response with optional headers and status override.
type SearchFoodVideosResponseData struct {
	Body    *SearchFoodVideosResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewSearchFoodVideosResponseData creates a new SearchFoodVideosResponseData with the given body.
func NewSearchFoodVideosResponseData(body *SearchFoodVideosResponse) *SearchFoodVideosResponseData {
	return &SearchFoodVideosResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *SearchFoodVideosResponseData) WithHeaders(h http.Header) *SearchFoodVideosResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *SearchFoodVideosResponseData) WithStatus(code int) *SearchFoodVideosResponseData {
	r.Status = code
	return r
}

// GetARandomFoodJokeResponseData wraps the success response with optional headers and status override.
type GetARandomFoodJokeResponseData struct {
	Body    *GetARandomFoodJokeResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetARandomFoodJokeResponseData creates a new GetARandomFoodJokeResponseData with the given body.
func NewGetARandomFoodJokeResponseData(body *GetARandomFoodJokeResponse) *GetARandomFoodJokeResponseData {
	return &GetARandomFoodJokeResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetARandomFoodJokeResponseData) WithHeaders(h http.Header) *GetARandomFoodJokeResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetARandomFoodJokeResponseData) WithStatus(code int) *GetARandomFoodJokeResponseData {
	r.Status = code
	return r
}

// GetRandomFoodTriviaResponseData wraps the success response with optional headers and status override.
type GetRandomFoodTriviaResponseData struct {
	Body    *GetRandomFoodTriviaResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetRandomFoodTriviaResponseData creates a new GetRandomFoodTriviaResponseData with the given body.
func NewGetRandomFoodTriviaResponseData(body *GetRandomFoodTriviaResponse) *GetRandomFoodTriviaResponseData {
	return &GetRandomFoodTriviaResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetRandomFoodTriviaResponseData) WithHeaders(h http.Header) *GetRandomFoodTriviaResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetRandomFoodTriviaResponseData) WithStatus(code int) *GetRandomFoodTriviaResponseData {
	r.Status = code
	return r
}

// TalkToChatbotResponseData wraps the success response with optional headers and status override.
type TalkToChatbotResponseData struct {
	Body    *TalkToChatbotResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewTalkToChatbotResponseData creates a new TalkToChatbotResponseData with the given body.
func NewTalkToChatbotResponseData(body *TalkToChatbotResponse) *TalkToChatbotResponseData {
	return &TalkToChatbotResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *TalkToChatbotResponseData) WithHeaders(h http.Header) *TalkToChatbotResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *TalkToChatbotResponseData) WithStatus(code int) *TalkToChatbotResponseData {
	r.Status = code
	return r
}

// GetConversationSuggestsResponseData wraps the success response with optional headers and status override.
type GetConversationSuggestsResponseData struct {
	Body    *GetConversationSuggestsResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetConversationSuggestsResponseData creates a new GetConversationSuggestsResponseData with the given body.
func NewGetConversationSuggestsResponseData(body *GetConversationSuggestsResponse) *GetConversationSuggestsResponseData {
	return &GetConversationSuggestsResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetConversationSuggestsResponseData) WithHeaders(h http.Header) *GetConversationSuggestsResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetConversationSuggestsResponseData) WithStatus(code int) *GetConversationSuggestsResponseData {
	r.Status = code
	return r
}

type SearchRecipesResponse struct {
	Offset       int64                          `json:"offset" validate:"required"`
	Number       int64                          `json:"number" validate:"required"`
	Results      SearchRecipes_Response_Results `json:"results" validate:"required"`
	TotalResults int64                          `json:"totalResults" validate:"required"`
}

func (s SearchRecipesResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(s.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if v, ok := any(s.Results).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Results", err)
		}
	}
	if err := typesValidator.Var(s.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByIngredientsResponse SearchRecipesByIngredients_Response

func (s SearchRecipesByIngredientsResponse) Validate() error {
	if val, ok := any(SearchRecipesByIngredients_Response(s)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type SearchRecipesByNutrientsResponse SearchRecipesByNutrients_Response

func (s SearchRecipesByNutrientsResponse) Validate() error {
	if val, ok := any(SearchRecipesByNutrients_Response(s)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type GetRecipeInformationResponse struct {
	ID                       int64                                             `json:"id" validate:"required"`
	Title                    string                                            `json:"title" validate:"required,min=1"`
	Image                    string                                            `json:"image" validate:"required,min=1"`
	ImageType                string                                            `json:"imageType" validate:"required,min=1"`
	Servings                 float32                                           `json:"servings" validate:"required"`
	ReadyInMinutes           int64                                             `json:"readyInMinutes" validate:"required"`
	License                  string                                            `json:"license" validate:"required,min=1"`
	SourceName               string                                            `json:"sourceName" validate:"required,min=1"`
	SourceURL                string                                            `json:"sourceUrl" validate:"required,min=1"`
	SpoonacularSourceURL     string                                            `json:"spoonacularSourceUrl" validate:"required,min=1"`
	AggregateLikes           int64                                             `json:"aggregateLikes" validate:"required"`
	HealthScore              float32                                           `json:"healthScore" validate:"required"`
	SpoonacularScore         float32                                           `json:"spoonacularScore" validate:"required"`
	PricePerServing          float32                                           `json:"pricePerServing" validate:"required"`
	AnalyzedInstructions     []map[string]any                                  `json:"analyzedInstructions" validate:"required"`
	Cheap                    bool                                              `json:"cheap"`
	CreditsText              string                                            `json:"creditsText" validate:"required,min=1"`
	Cuisines                 []string                                          `json:"cuisines" validate:"required"`
	DairyFree                bool                                              `json:"dairyFree"`
	Diets                    []string                                          `json:"diets" validate:"required"`
	Gaps                     string                                            `json:"gaps" validate:"required,min=1"`
	GlutenFree               bool                                              `json:"glutenFree"`
	Instructions             string                                            `json:"instructions" validate:"required"`
	Ketogenic                bool                                              `json:"ketogenic"`
	LowFodmap                bool                                              `json:"lowFodmap"`
	Occasions                []string                                          `json:"occasions" validate:"required"`
	Sustainable              bool                                              `json:"sustainable"`
	Vegan                    bool                                              `json:"vegan"`
	Vegetarian               bool                                              `json:"vegetarian"`
	VeryHealthy              bool                                              `json:"veryHealthy"`
	VeryPopular              bool                                              `json:"veryPopular"`
	Whole30                  bool                                              `json:"whole30"`
	WeightWatcherSmartPoints float32                                           `json:"weightWatcherSmartPoints" validate:"required"`
	DishTypes                []string                                          `json:"dishTypes" validate:"required"`
	ExtendedIngredients      GetRecipeInformation_Response_ExtendedIngredients `json:"extendedIngredients" validate:"required"`
	Summary                  string                                            `json:"summary" validate:"required,min=1"`
	WinePairing              GetRecipeInformation_Response_WinePairing         `json:"winePairing"`
}

func (g GetRecipeInformationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Servings, "required"); err != nil {
		errors = errors.Append("Servings", err)
	}
	if err := typesValidator.Var(g.ReadyInMinutes, "required"); err != nil {
		errors = errors.Append("ReadyInMinutes", err)
	}
	if err := typesValidator.Var(g.License, "required,min=1"); err != nil {
		errors = errors.Append("License", err)
	}
	if err := typesValidator.Var(g.SourceName, "required,min=1"); err != nil {
		errors = errors.Append("SourceName", err)
	}
	if err := typesValidator.Var(g.SourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SourceURL", err)
	}
	if err := typesValidator.Var(g.SpoonacularSourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SpoonacularSourceURL", err)
	}
	if err := typesValidator.Var(g.AggregateLikes, "required"); err != nil {
		errors = errors.Append("AggregateLikes", err)
	}
	if err := typesValidator.Var(g.HealthScore, "required"); err != nil {
		errors = errors.Append("HealthScore", err)
	}
	if err := typesValidator.Var(g.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if err := typesValidator.Var(g.PricePerServing, "required"); err != nil {
		errors = errors.Append("PricePerServing", err)
	}
	if err := typesValidator.Var(g.AnalyzedInstructions, "required"); err != nil {
		errors = errors.Append("AnalyzedInstructions", err)
	}
	if err := typesValidator.Var(g.CreditsText, "required,min=1"); err != nil {
		errors = errors.Append("CreditsText", err)
	}
	if err := typesValidator.Var(g.Cuisines, "required"); err != nil {
		errors = errors.Append("Cuisines", err)
	}
	if err := typesValidator.Var(g.Diets, "required"); err != nil {
		errors = errors.Append("Diets", err)
	}
	if err := typesValidator.Var(g.Gaps, "required,min=1"); err != nil {
		errors = errors.Append("Gaps", err)
	}
	if err := typesValidator.Var(g.Instructions, "required"); err != nil {
		errors = errors.Append("Instructions", err)
	}
	if err := typesValidator.Var(g.Occasions, "required"); err != nil {
		errors = errors.Append("Occasions", err)
	}
	if err := typesValidator.Var(g.WeightWatcherSmartPoints, "required"); err != nil {
		errors = errors.Append("WeightWatcherSmartPoints", err)
	}
	if err := typesValidator.Var(g.DishTypes, "required"); err != nil {
		errors = errors.Append("DishTypes", err)
	}
	if v, ok := any(g.ExtendedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ExtendedIngredients", err)
		}
	}
	if err := typesValidator.Var(g.Summary, "required,min=1"); err != nil {
		errors = errors.Append("Summary", err)
	}
	if v, ok := any(g.WinePairing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WinePairing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulkResponse GetRecipeInformationBulk_Response

func (g GetRecipeInformationBulkResponse) Validate() error {
	if val, ok := any(GetRecipeInformationBulk_Response(g)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type GetSimilarRecipesResponse GetSimilarRecipes_Response

func (g GetSimilarRecipesResponse) Validate() error {
	if val, ok := any(GetSimilarRecipes_Response(g)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type GetRandomRecipesResponse struct {
	Recipes GetRandomRecipes_Response_Recipes `json:"recipes" validate:"required"`
}

func (g GetRandomRecipesResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Recipes).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Recipes", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteRecipeSearchResponse AutocompleteRecipeSearch_Response

func (a AutocompleteRecipeSearchResponse) Validate() error {
	if val, ok := any(AutocompleteRecipeSearch_Response(a)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type GetRecipeTasteByIDResponse struct {
	Sweetness  float32 `json:"sweetness" validate:"required"`
	Saltiness  float32 `json:"saltiness" validate:"required"`
	Sourness   float32 `json:"sourness" validate:"required"`
	Bitterness float32 `json:"bitterness" validate:"required"`
	Savoriness float32 `json:"savoriness" validate:"required"`
	Fattiness  float32 `json:"fattiness" validate:"required"`
	Spiciness  float32 `json:"spiciness" validate:"required"`
}

func (g GetRecipeTasteByIDResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type RecipeTasteByIDImageResponse = []byte

type GetRecipeEquipmentByIDResponse struct {
	Equipment GetRecipeEquipmentByID_Response_Equipment `json:"equipment" validate:"required"`
}

func (g GetRecipeEquipmentByIDResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Equipment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Equipment", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EquipmentByIDImageResponse = []byte

type GetRecipePriceBreakdownByIDResponse struct {
	Ingredients         GetRecipePriceBreakdownByID_Response_Ingredients `json:"ingredients" validate:"required"`
	TotalCost           float32                                          `json:"totalCost" validate:"required"`
	TotalCostPerServing float32                                          `json:"totalCostPerServing" validate:"required"`
}

func (g GetRecipePriceBreakdownByIDResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if err := typesValidator.Var(g.TotalCost, "required"); err != nil {
		errors = errors.Append("TotalCost", err)
	}
	if err := typesValidator.Var(g.TotalCostPerServing, "required"); err != nil {
		errors = errors.Append("TotalCostPerServing", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PriceBreakdownByIDImageResponse = []byte

type GetRecipeIngredientsByIDResponse struct {
	Ingredients GetRecipeIngredientsByID_Response_Ingredients `json:"ingredients" validate:"required"`
}

func (g GetRecipeIngredientsByIDResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type IngredientsByIDImageResponse = []byte

type GetRecipeNutritionWidgetByIDResponse struct {
	Calories string                                     `json:"calories" validate:"required,min=1"`
	Carbs    string                                     `json:"carbs" validate:"required,min=1"`
	Fat      string                                     `json:"fat" validate:"required,min=1"`
	Protein  string                                     `json:"protein" validate:"required,min=1"`
	Bad      GetRecipeNutritionWidgetByID_Response_Bad  `json:"bad" validate:"required"`
	Good     GetRecipeNutritionWidgetByID_Response_Good `json:"good" validate:"required"`
}

func (g GetRecipeNutritionWidgetByIDResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Calories, "required,min=1"); err != nil {
		errors = errors.Append("Calories", err)
	}
	if err := typesValidator.Var(g.Carbs, "required,min=1"); err != nil {
		errors = errors.Append("Carbs", err)
	}
	if err := typesValidator.Var(g.Fat, "required,min=1"); err != nil {
		errors = errors.Append("Fat", err)
	}
	if err := typesValidator.Var(g.Protein, "required,min=1"); err != nil {
		errors = errors.Append("Protein", err)
	}
	if v, ok := any(g.Bad).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Bad", err)
		}
	}
	if v, ok := any(g.Good).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Good", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RecipeNutritionByIDImageResponse = []byte

type RecipeNutritionLabelWidgetResponse = string

type RecipeNutritionLabelImageResponse = []byte

type GetAnalyzedRecipeInstructionsResponse struct {
	ParsedInstructions GetAnalyzedRecipeInstructions_Response_ParsedInstructions `json:"parsedInstructions" validate:"required"`
	Ingredients        GetAnalyzedRecipeInstructions_Response_Ingredients        `json:"ingredients" validate:"required"`
	Equipment          GetAnalyzedRecipeInstructions_Response_Equipment          `json:"equipment" validate:"required"`
}

func (g GetAnalyzedRecipeInstructionsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ParsedInstructions).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ParsedInstructions", err)
		}
	}
	if v, ok := any(g.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if v, ok := any(g.Equipment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Equipment", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsiteResponse struct {
	ID                       int64                                                 `json:"id" validate:"required"`
	Title                    string                                                `json:"title" validate:"required,min=1"`
	Image                    string                                                `json:"image" validate:"required,min=1"`
	ImageType                string                                                `json:"imageType" validate:"required,min=1"`
	Servings                 float32                                               `json:"servings" validate:"required"`
	ReadyInMinutes           int64                                                 `json:"readyInMinutes" validate:"required"`
	License                  string                                                `json:"license" validate:"required,min=1"`
	SourceName               string                                                `json:"sourceName" validate:"required,min=1"`
	SourceURL                string                                                `json:"sourceUrl" validate:"required,min=1"`
	SpoonacularSourceURL     string                                                `json:"spoonacularSourceUrl" validate:"required,min=1"`
	AggregateLikes           int64                                                 `json:"aggregateLikes" validate:"required"`
	HealthScore              float32                                               `json:"healthScore" validate:"required"`
	SpoonacularScore         float32                                               `json:"spoonacularScore" validate:"required"`
	PricePerServing          float32                                               `json:"pricePerServing" validate:"required"`
	AnalyzedInstructions     []map[string]any                                      `json:"analyzedInstructions" validate:"required"`
	Cheap                    bool                                                  `json:"cheap"`
	CreditsText              string                                                `json:"creditsText" validate:"required,min=1"`
	Cuisines                 []string                                              `json:"cuisines" validate:"required"`
	DairyFree                bool                                                  `json:"dairyFree"`
	Diets                    []string                                              `json:"diets" validate:"required"`
	Gaps                     string                                                `json:"gaps" validate:"required,min=1"`
	GlutenFree               bool                                                  `json:"glutenFree"`
	Instructions             string                                                `json:"instructions" validate:"required"`
	Ketogenic                bool                                                  `json:"ketogenic"`
	LowFodmap                bool                                                  `json:"lowFodmap"`
	Occasions                []string                                              `json:"occasions" validate:"required"`
	Sustainable              bool                                                  `json:"sustainable"`
	Vegan                    bool                                                  `json:"vegan"`
	Vegetarian               bool                                                  `json:"vegetarian"`
	VeryHealthy              bool                                                  `json:"veryHealthy"`
	VeryPopular              bool                                                  `json:"veryPopular"`
	Whole30                  bool                                                  `json:"whole30"`
	WeightWatcherSmartPoints float32                                               `json:"weightWatcherSmartPoints" validate:"required"`
	DishTypes                []string                                              `json:"dishTypes" validate:"required"`
	ExtendedIngredients      ExtractRecipeFromWebsite_Response_ExtendedIngredients `json:"extendedIngredients" validate:"required"`
	Summary                  string                                                `json:"summary" validate:"required,min=1"`
	WinePairing              ExtractRecipeFromWebsite_Response_WinePairing         `json:"winePairing"`
}

func (e ExtractRecipeFromWebsiteResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(e.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(e.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(e.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(e.Servings, "required"); err != nil {
		errors = errors.Append("Servings", err)
	}
	if err := typesValidator.Var(e.ReadyInMinutes, "required"); err != nil {
		errors = errors.Append("ReadyInMinutes", err)
	}
	if err := typesValidator.Var(e.License, "required,min=1"); err != nil {
		errors = errors.Append("License", err)
	}
	if err := typesValidator.Var(e.SourceName, "required,min=1"); err != nil {
		errors = errors.Append("SourceName", err)
	}
	if err := typesValidator.Var(e.SourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SourceURL", err)
	}
	if err := typesValidator.Var(e.SpoonacularSourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SpoonacularSourceURL", err)
	}
	if err := typesValidator.Var(e.AggregateLikes, "required"); err != nil {
		errors = errors.Append("AggregateLikes", err)
	}
	if err := typesValidator.Var(e.HealthScore, "required"); err != nil {
		errors = errors.Append("HealthScore", err)
	}
	if err := typesValidator.Var(e.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if err := typesValidator.Var(e.PricePerServing, "required"); err != nil {
		errors = errors.Append("PricePerServing", err)
	}
	if err := typesValidator.Var(e.AnalyzedInstructions, "required"); err != nil {
		errors = errors.Append("AnalyzedInstructions", err)
	}
	if err := typesValidator.Var(e.CreditsText, "required,min=1"); err != nil {
		errors = errors.Append("CreditsText", err)
	}
	if err := typesValidator.Var(e.Cuisines, "required"); err != nil {
		errors = errors.Append("Cuisines", err)
	}
	if err := typesValidator.Var(e.Diets, "required"); err != nil {
		errors = errors.Append("Diets", err)
	}
	if err := typesValidator.Var(e.Gaps, "required,min=1"); err != nil {
		errors = errors.Append("Gaps", err)
	}
	if err := typesValidator.Var(e.Instructions, "required"); err != nil {
		errors = errors.Append("Instructions", err)
	}
	if err := typesValidator.Var(e.Occasions, "required"); err != nil {
		errors = errors.Append("Occasions", err)
	}
	if err := typesValidator.Var(e.WeightWatcherSmartPoints, "required"); err != nil {
		errors = errors.Append("WeightWatcherSmartPoints", err)
	}
	if err := typesValidator.Var(e.DishTypes, "required"); err != nil {
		errors = errors.Append("DishTypes", err)
	}
	if v, ok := any(e.ExtendedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ExtendedIngredients", err)
		}
	}
	if err := typesValidator.Var(e.Summary, "required,min=1"); err != nil {
		errors = errors.Append("Summary", err)
	}
	if v, ok := any(e.WinePairing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WinePairing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeRecipeIngredientsByIDResponse = string

type VisualizeRecipeTasteByIDResponse = string

type VisualizeRecipeEquipmentByIDResponse = string

type VisualizeRecipePriceBreakdownByIDResponse = string

type VisualizeRecipeTasteResponse = string

type VisualizeRecipeNutritionResponse = string

type VisualizePriceBreakdownResponse = string

type VisualizeEquipmentResponse = string

type AnalyzeRecipeResponse = map[string]any

type SummarizeRecipeResponse struct {
	ID      int64  `json:"id" validate:"required"`
	Summary string `json:"summary" validate:"required,min=1"`
	Title   string `json:"title" validate:"required,min=1"`
}

func (s SummarizeRecipeResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type CreateRecipeCardGetResponse = map[string]any

type CreateRecipeCardResponse struct {
	URL string `json:"url" validate:"required,min=1"`
}

func (c CreateRecipeCardResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AnalyzeRecipeInstructionsResponse struct {
	ParsedInstructions AnalyzeRecipeInstructions_Response_ParsedInstructions `json:"parsedInstructions" validate:"required"`
	Ingredients        AnalyzeRecipeInstructions_Response_Ingredients        `json:"ingredients" validate:"required"`
	Equipment          AnalyzeRecipeInstructions_Response_Equipment          `json:"equipment" validate:"required"`
}

func (a AnalyzeRecipeInstructionsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ParsedInstructions).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ParsedInstructions", err)
		}
	}
	if v, ok := any(a.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if v, ok := any(a.Equipment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Equipment", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ClassifyCuisineResponse struct {
	Cuisine    string   `json:"cuisine" validate:"required,min=1"`
	Cuisines   []string `json:"cuisines" validate:"required"`
	Confidence float32  `json:"confidence" validate:"required"`
}

func (c ClassifyCuisineResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AnalyzeARecipeSearchQueryResponse struct {
	Dishes      AnalyzeARecipeSearchQuery_Response_Dishes      `json:"dishes" validate:"required"`
	Ingredients AnalyzeARecipeSearchQuery_Response_Ingredients `json:"ingredients" validate:"required"`
	Cuisines    []string                                       `json:"cuisines" validate:"required"`
	Modifiers   []string                                       `json:"modifiers" validate:"required"`
}

func (a AnalyzeARecipeSearchQueryResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Dishes).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Dishes", err)
		}
	}
	if v, ok := any(a.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if err := typesValidator.Var(a.Cuisines, "required"); err != nil {
		errors = errors.Append("Cuisines", err)
	}
	if err := typesValidator.Var(a.Modifiers, "required"); err != nil {
		errors = errors.Append("Modifiers", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ConvertAmountsResponse struct {
	SourceAmount float32 `json:"sourceAmount" validate:"required"`
	SourceUnit   string  `json:"sourceUnit" validate:"required,min=1"`
	TargetAmount float32 `json:"targetAmount" validate:"required"`
	TargetUnit   string  `json:"targetUnit" validate:"required,min=1"`
	Answer       string  `json:"answer" validate:"required,min=1"`
}

func (c ConvertAmountsResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ParseIngredientsResponse ParseIngredients_Response

func (p ParseIngredientsResponse) Validate() error {
	if val, ok := any(ParseIngredients_Response(p)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type VisualizeRecipeNutritionByIDResponse = string

type VisualizeIngredientsResponse = string

type GuessNutritionByDishNameResponse struct {
	Calories    GuessNutritionByDishName_Response_Calories `json:"calories"`
	Carbs       GuessNutritionByDishName_Response_Carbs    `json:"carbs"`
	Fat         GuessNutritionByDishName_Response_Fat      `json:"fat"`
	Protein     GuessNutritionByDishName_Response_Protein  `json:"protein"`
	RecipesUsed int64                                      `json:"recipesUsed" validate:"required"`
}

func (g GuessNutritionByDishNameResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Calories).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Calories", err)
		}
	}
	if v, ok := any(g.Carbs).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Carbs", err)
		}
	}
	if v, ok := any(g.Fat).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Fat", err)
		}
	}
	if v, ok := any(g.Protein).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Protein", err)
		}
	}
	if err := typesValidator.Var(g.RecipesUsed, "required"); err != nil {
		errors = errors.Append("RecipesUsed", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientInformationResponse struct {
	ID                int64                                           `json:"id" validate:"required"`
	Original          string                                          `json:"original" validate:"required,min=1"`
	OriginalName      string                                          `json:"originalName" validate:"required,min=1"`
	Name              string                                          `json:"name" validate:"required,min=1"`
	NameClean         string                                          `json:"nameClean" validate:"required,min=1"`
	Amount            float32                                         `json:"amount" validate:"required"`
	Unit              string                                          `json:"unit" validate:"required"`
	UnitShort         string                                          `json:"unitShort" validate:"required"`
	UnitLong          string                                          `json:"unitLong" validate:"required"`
	PossibleUnits     []string                                        `json:"possibleUnits" validate:"required"`
	EstimatedCost     GetIngredientInformation_Response_EstimatedCost `json:"estimatedCost"`
	Consistency       string                                          `json:"consistency" validate:"required,min=1"`
	ShoppingListUnits []string                                        `json:"shoppingListUnits" validate:"required"`
	Aisle             string                                          `json:"aisle" validate:"required,min=1"`
	Image             string                                          `json:"image" validate:"required,min=1"`
	Meta              []map[string]any                                `json:"meta" validate:"required"`
	Nutrition         GetIngredientInformation_Response_Nutrition     `json:"nutrition"`
	CategoryPath      []string                                        `json:"categoryPath" validate:"required"`
}

func (g GetIngredientInformationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(g.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.NameClean, "required,min=1"); err != nil {
		errors = errors.Append("NameClean", err)
	}
	if err := typesValidator.Var(g.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(g.Unit, "required"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.UnitShort, "required"); err != nil {
		errors = errors.Append("UnitShort", err)
	}
	if err := typesValidator.Var(g.UnitLong, "required"); err != nil {
		errors = errors.Append("UnitLong", err)
	}
	if err := typesValidator.Var(g.PossibleUnits, "required"); err != nil {
		errors = errors.Append("PossibleUnits", err)
	}
	if v, ok := any(g.EstimatedCost).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EstimatedCost", err)
		}
	}
	if err := typesValidator.Var(g.Consistency, "required,min=1"); err != nil {
		errors = errors.Append("Consistency", err)
	}
	if err := typesValidator.Var(g.ShoppingListUnits, "required"); err != nil {
		errors = errors.Append("ShoppingListUnits", err)
	}
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.Meta, "required"); err != nil {
		errors = errors.Append("Meta", err)
	}
	if v, ok := any(g.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if err := typesValidator.Var(g.CategoryPath, "required"); err != nil {
		errors = errors.Append("CategoryPath", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ComputeIngredientAmountResponse struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (c ComputeIngredientAmountResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ComputeGlycemicLoadResponse struct {
	TotalGlycemicLoad float32                                  `json:"totalGlycemicLoad" validate:"required"`
	Ingredients       ComputeGlycemicLoad_Response_Ingredients `json:"ingredients" validate:"required"`
}

func (c ComputeGlycemicLoadResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.TotalGlycemicLoad, "required"); err != nil {
		errors = errors.Append("TotalGlycemicLoad", err)
	}
	if v, ok := any(c.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteIngredientSearchResponse AutocompleteIngredientSearch_Response

func (a AutocompleteIngredientSearchResponse) Validate() error {
	if val, ok := any(AutocompleteIngredientSearch_Response(a)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type IngredientSearchResponse struct {
	Results      IngredientSearch_Response_Results `json:"results" validate:"required"`
	Offset       int64                             `json:"offset" validate:"required"`
	Number       int64                             `json:"number" validate:"required"`
	TotalResults int64                             `json:"totalResults" validate:"required"`
}

func (i IngredientSearchResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(i.Results).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Results", err)
		}
	}
	if err := typesValidator.Var(i.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(i.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if err := typesValidator.Var(i.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientSubstitutesResponse struct {
	Ingredient  string   `json:"ingredient" validate:"required,min=1"`
	Substitutes []string `json:"substitutes" validate:"required"`
	Message     string   `json:"message" validate:"required,min=1"`
}

func (g GetIngredientSubstitutesResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientSubstitutesByIDResponse struct {
	Ingredient  string   `json:"ingredient" validate:"required,min=1"`
	Substitutes []string `json:"substitutes" validate:"required"`
	Message     string   `json:"message" validate:"required,min=1"`
}

func (g GetIngredientSubstitutesByIDResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type SearchGroceryProductsResponse struct {
	Products      SearchGroceryProducts_Response_Products `json:"products" validate:"required"`
	TotalProducts int64                                   `json:"totalProducts" validate:"required"`
	Type          string                                  `json:"type" validate:"required,min=1"`
	Offset        int64                                   `json:"offset" validate:"required"`
	Number        int64                                   `json:"number" validate:"required"`
}

func (s SearchGroceryProductsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.Products).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Products", err)
		}
	}
	if err := typesValidator.Var(s.TotalProducts, "required"); err != nil {
		errors = errors.Append("TotalProducts", err)
	}
	if err := typesValidator.Var(s.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(s.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProductsByUPCResponse struct {
	ID               int64                                           `json:"id" validate:"required"`
	Title            string                                          `json:"title" validate:"required,min=1"`
	Badges           []string                                        `json:"badges" validate:"required"`
	ImportantBadges  []string                                        `json:"importantBadges" validate:"required"`
	Breadcrumbs      []string                                        `json:"breadcrumbs" validate:"required"`
	GeneratedText    string                                          `json:"generatedText" validate:"required,min=1"`
	ImageType        string                                          `json:"imageType" validate:"required,min=1"`
	IngredientCount  *int64                                          `json:"ingredientCount,omitempty"`
	IngredientList   string                                          `json:"ingredientList" validate:"required,min=1"`
	Ingredients      SearchGroceryProductsByUPC_Response_Ingredients `json:"ingredients" validate:"required"`
	Likes            float32                                         `json:"likes" validate:"required"`
	Nutrition        SearchGroceryProductsByUPC_Response_Nutrition   `json:"nutrition"`
	Price            float32                                         `json:"price" validate:"required"`
	Servings         SearchGroceryProductsByUPC_Response_Servings    `json:"servings"`
	SpoonacularScore float32                                         `json:"spoonacularScore" validate:"required"`
}

func (s SearchGroceryProductsByUPCResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(s.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(s.Badges, "required"); err != nil {
		errors = errors.Append("Badges", err)
	}
	if err := typesValidator.Var(s.ImportantBadges, "required"); err != nil {
		errors = errors.Append("ImportantBadges", err)
	}
	if err := typesValidator.Var(s.Breadcrumbs, "required"); err != nil {
		errors = errors.Append("Breadcrumbs", err)
	}
	if err := typesValidator.Var(s.GeneratedText, "required,min=1"); err != nil {
		errors = errors.Append("GeneratedText", err)
	}
	if err := typesValidator.Var(s.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(s.IngredientList, "required,min=1"); err != nil {
		errors = errors.Append("IngredientList", err)
	}
	if v, ok := any(s.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if err := typesValidator.Var(s.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if v, ok := any(s.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if err := typesValidator.Var(s.Price, "required"); err != nil {
		errors = errors.Append("Price", err)
	}
	if v, ok := any(s.Servings).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Servings", err)
		}
	}
	if err := typesValidator.Var(s.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchCustomFoodsResponse struct {
	CustomFoods SearchCustomFoods_Response_CustomFoods `json:"customFoods" validate:"required"`
	Type        string                                 `json:"type" validate:"required,min=1"`
	Offset      int64                                  `json:"offset" validate:"required"`
	Number      int64                                  `json:"number" validate:"required"`
}

func (s SearchCustomFoodsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.CustomFoods).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CustomFoods", err)
		}
	}
	if err := typesValidator.Var(s.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(s.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetProductInformationResponse struct {
	ID               int64                                      `json:"id" validate:"required"`
	Title            string                                     `json:"title" validate:"required,min=1"`
	Breadcrumbs      []string                                   `json:"breadcrumbs" validate:"required"`
	ImageType        string                                     `json:"imageType" validate:"required,min=1"`
	Badges           []string                                   `json:"badges" validate:"required"`
	ImportantBadges  []string                                   `json:"importantBadges" validate:"required"`
	IngredientCount  int64                                      `json:"ingredientCount" validate:"required"`
	GeneratedText    *struct{}                                  `json:"generatedText,omitempty"`
	IngredientList   string                                     `json:"ingredientList" validate:"required,min=1"`
	Ingredients      GetProductInformation_Response_Ingredients `json:"ingredients" validate:"required"`
	Likes            float32                                    `json:"likes" validate:"required"`
	Aisle            string                                     `json:"aisle" validate:"required,min=1"`
	Nutrition        GetProductInformation_Response_Nutrition   `json:"nutrition"`
	Price            float32                                    `json:"price" validate:"required"`
	Servings         GetProductInformation_Response_Servings    `json:"servings"`
	SpoonacularScore float32                                    `json:"spoonacularScore" validate:"required"`
}

func (g GetProductInformationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Breadcrumbs, "required"); err != nil {
		errors = errors.Append("Breadcrumbs", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Badges, "required"); err != nil {
		errors = errors.Append("Badges", err)
	}
	if err := typesValidator.Var(g.ImportantBadges, "required"); err != nil {
		errors = errors.Append("ImportantBadges", err)
	}
	if err := typesValidator.Var(g.IngredientCount, "required"); err != nil {
		errors = errors.Append("IngredientCount", err)
	}
	if err := typesValidator.Var(g.IngredientList, "required,min=1"); err != nil {
		errors = errors.Append("IngredientList", err)
	}
	if v, ok := any(g.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if err := typesValidator.Var(g.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if v, ok := any(g.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if err := typesValidator.Var(g.Price, "required"); err != nil {
		errors = errors.Append("Price", err)
	}
	if v, ok := any(g.Servings).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Servings", err)
		}
	}
	if err := typesValidator.Var(g.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetComparableProductsResponse struct {
	ComparableProducts GetComparableProducts_Response_ComparableProducts `json:"comparableProducts"`
}

func (g GetComparableProductsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ComparableProducts).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ComparableProducts", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteProductSearchResponse struct {
	Results AutocompleteProductSearch_Response_Results `json:"results" validate:"required"`
}

func (a AutocompleteProductSearchResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Results).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Results", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeProductNutritionByIDResponse = string

type ProductNutritionByIDImageResponse = []byte

type ProductNutritionLabelWidgetResponse = string

type ProductNutritionLabelImageResponse = []byte

type ClassifyGroceryProductResponse struct {
	CleanTitle  string   `json:"cleanTitle" validate:"required,min=1"`
	Image       string   `json:"image" validate:"required,min=1"`
	Category    string   `json:"category" validate:"required,min=1"`
	Breadcrumbs []string `json:"breadcrumbs" validate:"required"`
	UsdaCode    int64    `json:"usdaCode" validate:"required"`
}

func (c ClassifyGroceryProductResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ClassifyGroceryProductBulkResponse ClassifyGroceryProductBulk_Response

func (c ClassifyGroceryProductBulkResponse) Validate() error {
	if val, ok := any(ClassifyGroceryProductBulk_Response(c)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type MapIngredientsToGroceryProductsResponse MapIngredientsToGroceryProducts_Response

func (m MapIngredientsToGroceryProductsResponse) Validate() error {
	if val, ok := any(MapIngredientsToGroceryProducts_Response(m)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type AutocompleteMenuItemSearchResponse struct {
	Results AutocompleteMenuItemSearch_Response_Results `json:"results" validate:"required"`
}

func (a AutocompleteMenuItemSearchResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Results).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Results", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchMenuItemsResponse struct {
	MenuItems      SearchMenuItems_Response_MenuItems `json:"menuItems" validate:"required"`
	TotalMenuItems int64                              `json:"totalMenuItems" validate:"required"`
	Type           string                             `json:"type" validate:"required,min=1"`
	Offset         int64                              `json:"offset" validate:"required"`
	Number         int64                              `json:"number" validate:"required"`
}

func (s SearchMenuItemsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.MenuItems).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("MenuItems", err)
		}
	}
	if err := typesValidator.Var(s.TotalMenuItems, "required"); err != nil {
		errors = errors.Append("TotalMenuItems", err)
	}
	if err := typesValidator.Var(s.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(s.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMenuItemInformationResponse struct {
	ID               int64                                     `json:"id" validate:"required"`
	Title            string                                    `json:"title" validate:"required,min=1"`
	RestaurantChain  string                                    `json:"restaurantChain" validate:"required,min=1"`
	Nutrition        GetMenuItemInformation_Response_Nutrition `json:"nutrition"`
	Badges           []string                                  `json:"badges" validate:"required"`
	Breadcrumbs      []string                                  `json:"breadcrumbs" validate:"required"`
	GeneratedText    *string                                   `json:"generatedText,omitempty"`
	ImageType        string                                    `json:"imageType" validate:"required,min=1"`
	Likes            float32                                   `json:"likes" validate:"required"`
	Servings         GetMenuItemInformation_Response_Servings  `json:"servings"`
	Price            *float32                                  `json:"price,omitempty"`
	SpoonacularScore *float32                                  `json:"spoonacularScore,omitempty"`
}

func (g GetMenuItemInformationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.RestaurantChain, "required,min=1"); err != nil {
		errors = errors.Append("RestaurantChain", err)
	}
	if v, ok := any(g.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if err := typesValidator.Var(g.Badges, "required"); err != nil {
		errors = errors.Append("Badges", err)
	}
	if err := typesValidator.Var(g.Breadcrumbs, "required"); err != nil {
		errors = errors.Append("Breadcrumbs", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if v, ok := any(g.Servings).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Servings", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeMenuItemNutritionByIDResponse = string

type MenuItemNutritionByIDImageResponse = []byte

type MenuItemNutritionLabelWidgetResponse = string

type MenuItemNutritionLabelImageResponse = []byte

type GenerateMealPlanResponse struct {
	Meals     GenerateMealPlan_Response_Meals     `json:"meals" validate:"required"`
	Nutrients GenerateMealPlan_Response_Nutrients `json:"nutrients"`
}

func (g GenerateMealPlanResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Meals).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Meals", err)
		}
	}
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeekResponse struct {
	Days GetMealPlanWeek_Response_Days `json:"days" validate:"required"`
}

func (g GetMealPlanWeekResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Days).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Days", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ClearMealPlanDayResponse = map[string]any

type AddToMealPlanResponse = map[string]any

type DeleteFromMealPlanResponse = map[string]any

type GetMealPlanTemplatesResponse struct {
	Templates GetMealPlanTemplates_Response_Templates `json:"templates" validate:"required"`
}

func (g GetMealPlanTemplatesResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Templates).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Templates", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddMealPlanTemplateResponse struct {
	Name            string                             `json:"name" validate:"required,min=1"`
	Items           AddMealPlanTemplate_Response_Items `json:"items" validate:"required"`
	PublishAsPublic bool                               `json:"publishAsPublic"`
}

func (a AddMealPlanTemplateResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(a.Items).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Items", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplateResponse struct {
	ID   int64                             `json:"id" validate:"required"`
	Name string                            `json:"name" validate:"required,min=1"`
	Days GetMealPlanTemplate_Response_Days `json:"days" validate:"required"`
}

func (g GetMealPlanTemplateResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(g.Days).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Days", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteMealPlanTemplateResponse = map[string]any

type GetShoppingListResponse struct {
	Aisles    GetShoppingList_Response_Aisles `json:"aisles" validate:"required"`
	Cost      float32                         `json:"cost" validate:"required"`
	StartDate float32                         `json:"startDate" validate:"required"`
	EndDate   float32                         `json:"endDate" validate:"required"`
}

func (g GetShoppingListResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Aisles).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Aisles", err)
		}
	}
	if err := typesValidator.Var(g.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(g.StartDate, "required"); err != nil {
		errors = errors.Append("StartDate", err)
	}
	if err := typesValidator.Var(g.EndDate, "required"); err != nil {
		errors = errors.Append("EndDate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingListResponse struct {
	Aisles    GenerateShoppingList_Response_Aisles `json:"aisles" validate:"required"`
	Cost      float32                              `json:"cost" validate:"required"`
	StartDate float32                              `json:"startDate" validate:"required"`
	EndDate   float32                              `json:"endDate" validate:"required"`
}

func (g GenerateShoppingListResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Aisles).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Aisles", err)
		}
	}
	if err := typesValidator.Var(g.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(g.StartDate, "required"); err != nil {
		errors = errors.Append("StartDate", err)
	}
	if err := typesValidator.Var(g.EndDate, "required"); err != nil {
		errors = errors.Append("EndDate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ConnectUserResponse struct {
	Username string `json:"username" validate:"required,min=1"`
	Hash     string `json:"hash" validate:"required,min=1"`
}

func (c ConnectUserResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AddToShoppingListResponse struct {
	Aisles    AddToShoppingList_Response_Aisles `json:"aisles" validate:"required"`
	Cost      float32                           `json:"cost" validate:"required"`
	StartDate float32                           `json:"startDate" validate:"required"`
	EndDate   float32                           `json:"endDate" validate:"required"`
}

func (a AddToShoppingListResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Aisles).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Aisles", err)
		}
	}
	if err := typesValidator.Var(a.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(a.StartDate, "required"); err != nil {
		errors = errors.Append("StartDate", err)
	}
	if err := typesValidator.Var(a.EndDate, "required"); err != nil {
		errors = errors.Append("EndDate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteFromShoppingListResponse = map[string]any

type SearchRestaurantsResponse struct {
	Restaurants *SearchRestaurants_Response_Restaurants `json:"restaurants,omitempty"`
}

func (s SearchRestaurantsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if s.Restaurants != nil {
		if v, ok := any(s.Restaurants).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Restaurants", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDishPairingForWineResponse struct {
	Pairings []string `json:"pairings" validate:"required"`
	Text     string   `json:"text" validate:"required,min=1"`
}

func (g GetDishPairingForWineResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWinePairingResponse struct {
	PairedWines    []string                               `json:"pairedWines" validate:"required"`
	PairingText    string                                 `json:"pairingText" validate:"required,min=1"`
	ProductMatches GetWinePairing_Response_ProductMatches `json:"productMatches" validate:"required"`
}

func (g GetWinePairingResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(g.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(g.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetWineDescriptionResponse struct {
	WineDescription string `json:"wineDescription" validate:"required,min=1"`
}

func (g GetWineDescriptionResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWineRecommendationResponse struct {
	RecommendedWines GetWineRecommendation_Response_RecommendedWines `json:"recommendedWines" validate:"required"`
	TotalFound       int64                                           `json:"totalFound" validate:"required"`
}

func (g GetWineRecommendationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.RecommendedWines).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RecommendedWines", err)
		}
	}
	if err := typesValidator.Var(g.TotalFound, "required"); err != nil {
		errors = errors.Append("TotalFound", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageClassificationByURLResponse struct {
	Category    string  `json:"category" validate:"required,min=1"`
	Probability float32 `json:"probability" validate:"required"`
}

func (i ImageClassificationByURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURLResponse struct {
	Nutrition ImageAnalysisByURL_Response_Nutrition `json:"nutrition"`
	Category  ImageAnalysisByURL_Response_Category  `json:"category"`
	Recipes   ImageAnalysisByURL_Response_Recipes   `json:"recipes" validate:"required"`
}

func (i ImageAnalysisByURLResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(i.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if v, ok := any(i.Category).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Category", err)
		}
	}
	if v, ok := any(i.Recipes).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Recipes", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type QuickAnswerResponse struct {
	Answer string `json:"answer" validate:"required,min=1"`
	Image  string `json:"image" validate:"required,min=1"`
}

func (q QuickAnswerResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(q))
}

type DetectFoodInTextResponse struct {
	Annotations DetectFoodInText_Response_Annotations `json:"annotations" validate:"required"`
}

func (d DetectFoodInTextResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Annotations).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Annotations", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContentResponse struct {
	Articles        SearchSiteContent_Response_Articles        `json:"Articles" validate:"required"`
	GroceryProducts SearchSiteContent_Response_GroceryProducts `json:"Grocery Products" validate:"required"`
	MenuItems       SearchSiteContent_Response_MenuItems       `json:"Menu Items" validate:"required"`
	Recipes         SearchSiteContent_Response_Recipes         `json:"Recipes" validate:"required"`
}

func (s SearchSiteContentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.Articles).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Articles", err)
		}
	}
	if v, ok := any(s.GroceryProducts).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GroceryProducts", err)
		}
	}
	if v, ok := any(s.MenuItems).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("MenuItems", err)
		}
	}
	if v, ok := any(s.Recipes).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Recipes", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchAllFoodResponse struct {
	Query         string                               `json:"query" validate:"required,min=1"`
	TotalResults  int64                                `json:"totalResults" validate:"required"`
	Limit         int64                                `json:"limit" validate:"required"`
	Offset        int64                                `json:"offset" validate:"required"`
	SearchResults SearchAllFood_Response_SearchResults `json:"searchResults" validate:"required"`
}

func (s SearchAllFoodResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.Query, "required,min=1"); err != nil {
		errors = errors.Append("Query", err)
	}
	if err := typesValidator.Var(s.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if err := typesValidator.Var(s.Limit, "required"); err != nil {
		errors = errors.Append("Limit", err)
	}
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if v, ok := any(s.SearchResults).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SearchResults", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchFoodVideosResponse struct {
	Videos       SearchFoodVideos_Response_Videos `json:"videos" validate:"required"`
	TotalResults int64                            `json:"totalResults" validate:"required"`
}

func (s SearchFoodVideosResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.Videos).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Videos", err)
		}
	}
	if err := typesValidator.Var(s.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetARandomFoodJokeResponse struct {
	Text string `json:"text" validate:"required,min=1"`
}

func (g GetARandomFoodJokeResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomFoodTriviaResponse struct {
	Text string `json:"text" validate:"required,min=1"`
}

func (g GetRandomFoodTriviaResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type TalkToChatbotResponse struct {
	AnswerText string     `json:"answerText" validate:"required,min=1"`
	Media      []struct{} `json:"media" validate:"required"`
}

func (t TalkToChatbotResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type GetConversationSuggestsResponse struct {
	Suggests GetConversationSuggests_Response_Suggests `json:"suggests"`
	Words    []struct{}                                `json:"words" validate:"required"`
}

func (g GetConversationSuggestsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Suggests).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Suggests", err)
		}
	}
	if err := typesValidator.Var(g.Words, "required"); err != nil {
		errors = errors.Append("Words", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// SearchRecipesServiceRequestOptions holds all parameters for the SearchRecipes operation.
type SearchRecipesServiceRequestOptions struct {
	Query *SearchRecipesQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchRecipesServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchRecipesByIngredientsServiceRequestOptions holds all parameters for the SearchRecipesByIngredients operation.
type SearchRecipesByIngredientsServiceRequestOptions struct {
	Query *SearchRecipesByIngredientsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchRecipesByIngredientsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchRecipesByNutrientsServiceRequestOptions holds all parameters for the SearchRecipesByNutrients operation.
type SearchRecipesByNutrientsServiceRequestOptions struct {
	Query *SearchRecipesByNutrientsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchRecipesByNutrientsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetRecipeInformationServiceRequestOptions holds all parameters for the GetRecipeInformation operation.
type GetRecipeInformationServiceRequestOptions struct {
	PathParams *GetRecipeInformationPath
	Query      *GetRecipeInformationQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetRecipeInformationServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetRecipeInformationBulkServiceRequestOptions holds all parameters for the GetRecipeInformationBulk operation.
type GetRecipeInformationBulkServiceRequestOptions struct {
	Query *GetRecipeInformationBulkQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetRecipeInformationBulkServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetSimilarRecipesServiceRequestOptions holds all parameters for the GetSimilarRecipes operation.
type GetSimilarRecipesServiceRequestOptions struct {
	PathParams *GetSimilarRecipesPath
	Query      *GetSimilarRecipesQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetSimilarRecipesServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetRandomRecipesServiceRequestOptions holds all parameters for the GetRandomRecipes operation.
type GetRandomRecipesServiceRequestOptions struct {
	Query *GetRandomRecipesQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetRandomRecipesServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AutocompleteRecipeSearchServiceRequestOptions holds all parameters for the AutocompleteRecipeSearch operation.
type AutocompleteRecipeSearchServiceRequestOptions struct {
	Query *AutocompleteRecipeSearchQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AutocompleteRecipeSearchServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetRecipeTasteByIDServiceRequestOptions holds all parameters for the GetRecipeTasteByID operation.
type GetRecipeTasteByIDServiceRequestOptions struct {
	PathParams *GetRecipeTasteByIDPath
	Query      *GetRecipeTasteByIDQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetRecipeTasteByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// RecipeTasteByIDImageServiceRequestOptions holds all parameters for the RecipeTasteByIDImage operation.
type RecipeTasteByIDImageServiceRequestOptions struct {
	PathParams *RecipeTasteByIDImagePath
	Query      *RecipeTasteByIDImageQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *RecipeTasteByIDImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetRecipeEquipmentByIDServiceRequestOptions holds all parameters for the GetRecipeEquipmentByID operation.
type GetRecipeEquipmentByIDServiceRequestOptions struct {
	PathParams *GetRecipeEquipmentByIDPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetRecipeEquipmentByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// EquipmentByIDImageServiceRequestOptions holds all parameters for the EquipmentByIDImage operation.
type EquipmentByIDImageServiceRequestOptions struct {
	PathParams *EquipmentByIDImagePath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *EquipmentByIDImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetRecipePriceBreakdownByIDServiceRequestOptions holds all parameters for the GetRecipePriceBreakdownByID operation.
type GetRecipePriceBreakdownByIDServiceRequestOptions struct {
	PathParams *GetRecipePriceBreakdownByIDPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetRecipePriceBreakdownByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// PriceBreakdownByIDImageServiceRequestOptions holds all parameters for the PriceBreakdownByIDImage operation.
type PriceBreakdownByIDImageServiceRequestOptions struct {
	PathParams *PriceBreakdownByIDImagePath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *PriceBreakdownByIDImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetRecipeIngredientsByIDServiceRequestOptions holds all parameters for the GetRecipeIngredientsByID operation.
type GetRecipeIngredientsByIDServiceRequestOptions struct {
	PathParams *GetRecipeIngredientsByIDPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetRecipeIngredientsByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// IngredientsByIDImageServiceRequestOptions holds all parameters for the IngredientsByIDImage operation.
type IngredientsByIDImageServiceRequestOptions struct {
	PathParams *IngredientsByIDImagePath
	Query      *IngredientsByIDImageQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *IngredientsByIDImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetRecipeNutritionWidgetByIDServiceRequestOptions holds all parameters for the GetRecipeNutritionWidgetByID operation.
type GetRecipeNutritionWidgetByIDServiceRequestOptions struct {
	PathParams *GetRecipeNutritionWidgetByIDPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetRecipeNutritionWidgetByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// RecipeNutritionByIDImageServiceRequestOptions holds all parameters for the RecipeNutritionByIDImage operation.
type RecipeNutritionByIDImageServiceRequestOptions struct {
	PathParams *RecipeNutritionByIDImagePath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *RecipeNutritionByIDImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// RecipeNutritionLabelWidgetServiceRequestOptions holds all parameters for the RecipeNutritionLabelWidget operation.
type RecipeNutritionLabelWidgetServiceRequestOptions struct {
	PathParams *RecipeNutritionLabelWidgetPath
	Query      *RecipeNutritionLabelWidgetQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *RecipeNutritionLabelWidgetServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// RecipeNutritionLabelImageServiceRequestOptions holds all parameters for the RecipeNutritionLabelImage operation.
type RecipeNutritionLabelImageServiceRequestOptions struct {
	PathParams *RecipeNutritionLabelImagePath
	Query      *RecipeNutritionLabelImageQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *RecipeNutritionLabelImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetAnalyzedRecipeInstructionsServiceRequestOptions holds all parameters for the GetAnalyzedRecipeInstructions operation.
type GetAnalyzedRecipeInstructionsServiceRequestOptions struct {
	PathParams *GetAnalyzedRecipeInstructionsPath
	Query      *GetAnalyzedRecipeInstructionsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetAnalyzedRecipeInstructionsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ExtractRecipeFromWebsiteServiceRequestOptions holds all parameters for the ExtractRecipeFromWebsite operation.
type ExtractRecipeFromWebsiteServiceRequestOptions struct {
	Query *ExtractRecipeFromWebsiteQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ExtractRecipeFromWebsiteServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeRecipeIngredientsByIDServiceRequestOptions holds all parameters for the VisualizeRecipeIngredientsByID operation.
type VisualizeRecipeIngredientsByIDServiceRequestOptions struct {
	PathParams *VisualizeRecipeIngredientsByIDPath
	Query      *VisualizeRecipeIngredientsByIDQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeRecipeIngredientsByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeRecipeTasteByIDServiceRequestOptions holds all parameters for the VisualizeRecipeTasteByID operation.
type VisualizeRecipeTasteByIDServiceRequestOptions struct {
	PathParams *VisualizeRecipeTasteByIDPath
	Query      *VisualizeRecipeTasteByIDQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeRecipeTasteByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeRecipeEquipmentByIDServiceRequestOptions holds all parameters for the VisualizeRecipeEquipmentByID operation.
type VisualizeRecipeEquipmentByIDServiceRequestOptions struct {
	PathParams *VisualizeRecipeEquipmentByIDPath
	Query      *VisualizeRecipeEquipmentByIDQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeRecipeEquipmentByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeRecipePriceBreakdownByIDServiceRequestOptions holds all parameters for the VisualizeRecipePriceBreakdownByID operation.
type VisualizeRecipePriceBreakdownByIDServiceRequestOptions struct {
	PathParams *VisualizeRecipePriceBreakdownByIDPath
	Query      *VisualizeRecipePriceBreakdownByIDQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeRecipePriceBreakdownByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeRecipeTasteServiceRequestOptions holds all parameters for the VisualizeRecipeTaste operation.
type VisualizeRecipeTasteServiceRequestOptions struct {
	Query  *VisualizeRecipeTasteQuery
	Body   *VisualizeRecipeTasteBody
	Header *VisualizeRecipeTasteHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeRecipeTasteServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeRecipeNutritionServiceRequestOptions holds all parameters for the VisualizeRecipeNutrition operation.
type VisualizeRecipeNutritionServiceRequestOptions struct {
	Query  *VisualizeRecipeNutritionQuery
	Body   *VisualizeRecipeNutritionBody
	Header *VisualizeRecipeNutritionHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeRecipeNutritionServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizePriceBreakdownServiceRequestOptions holds all parameters for the VisualizePriceBreakdown operation.
type VisualizePriceBreakdownServiceRequestOptions struct {
	Query  *VisualizePriceBreakdownQuery
	Body   *VisualizePriceBreakdownBody
	Header *VisualizePriceBreakdownHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizePriceBreakdownServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeEquipmentServiceRequestOptions holds all parameters for the VisualizeEquipment operation.
type VisualizeEquipmentServiceRequestOptions struct {
	Body   *VisualizeEquipmentBody
	Header *VisualizeEquipmentHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeEquipmentServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AnalyzeRecipeServiceRequestOptions holds all parameters for the AnalyzeRecipe operation.
type AnalyzeRecipeServiceRequestOptions struct {
	Query *AnalyzeRecipeQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AnalyzeRecipeServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SummarizeRecipeServiceRequestOptions holds all parameters for the SummarizeRecipe operation.
type SummarizeRecipeServiceRequestOptions struct {
	PathParams *SummarizeRecipePath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SummarizeRecipeServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// CreateRecipeCardGetServiceRequestOptions holds all parameters for the CreateRecipeCardGet operation.
type CreateRecipeCardGetServiceRequestOptions struct {
	PathParams *CreateRecipeCardGetPath
	Query      *CreateRecipeCardGetQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *CreateRecipeCardGetServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// CreateRecipeCardServiceRequestOptions holds all parameters for the CreateRecipeCard operation.
type CreateRecipeCardServiceRequestOptions struct {
	Body   *CreateRecipeCardBody
	Header *CreateRecipeCardHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *CreateRecipeCardServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AnalyzeRecipeInstructionsServiceRequestOptions holds all parameters for the AnalyzeRecipeInstructions operation.
type AnalyzeRecipeInstructionsServiceRequestOptions struct {
	Body   *AnalyzeRecipeInstructionsBody
	Header *AnalyzeRecipeInstructionsHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AnalyzeRecipeInstructionsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ClassifyCuisineServiceRequestOptions holds all parameters for the ClassifyCuisine operation.
type ClassifyCuisineServiceRequestOptions struct {
	Body   *ClassifyCuisineBody
	Header *ClassifyCuisineHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ClassifyCuisineServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AnalyzeARecipeSearchQueryServiceRequestOptions holds all parameters for the AnalyzeARecipeSearchQuery operation.
type AnalyzeARecipeSearchQueryServiceRequestOptions struct {
	Query *AnalyzeARecipeSearchQueryQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AnalyzeARecipeSearchQueryServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ConvertAmountsServiceRequestOptions holds all parameters for the ConvertAmounts operation.
type ConvertAmountsServiceRequestOptions struct {
	Query *ConvertAmountsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ConvertAmountsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ParseIngredientsServiceRequestOptions holds all parameters for the ParseIngredients operation.
type ParseIngredientsServiceRequestOptions struct {
	Query  *ParseIngredientsQuery
	Body   *ParseIngredientsBody
	Header *ParseIngredientsHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ParseIngredientsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeRecipeNutritionByIDServiceRequestOptions holds all parameters for the VisualizeRecipeNutritionByID operation.
type VisualizeRecipeNutritionByIDServiceRequestOptions struct {
	PathParams *VisualizeRecipeNutritionByIDPath
	Query      *VisualizeRecipeNutritionByIDQuery
	Header     *VisualizeRecipeNutritionByIDHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeRecipeNutritionByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeIngredientsServiceRequestOptions holds all parameters for the VisualizeIngredients operation.
type VisualizeIngredientsServiceRequestOptions struct {
	Query  *VisualizeIngredientsQuery
	Body   *VisualizeIngredientsBody
	Header *VisualizeIngredientsHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeIngredientsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GuessNutritionByDishNameServiceRequestOptions holds all parameters for the GuessNutritionByDishName operation.
type GuessNutritionByDishNameServiceRequestOptions struct {
	Query *GuessNutritionByDishNameQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GuessNutritionByDishNameServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetIngredientInformationServiceRequestOptions holds all parameters for the GetIngredientInformation operation.
type GetIngredientInformationServiceRequestOptions struct {
	PathParams *GetIngredientInformationPath
	Query      *GetIngredientInformationQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetIngredientInformationServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ComputeIngredientAmountServiceRequestOptions holds all parameters for the ComputeIngredientAmount operation.
type ComputeIngredientAmountServiceRequestOptions struct {
	PathParams *ComputeIngredientAmountPath
	Query      *ComputeIngredientAmountQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ComputeIngredientAmountServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ComputeGlycemicLoadServiceRequestOptions holds all parameters for the ComputeGlycemicLoad operation.
type ComputeGlycemicLoadServiceRequestOptions struct {
	Query *ComputeGlycemicLoadQuery
	Body  *ComputeGlycemicLoadBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ComputeGlycemicLoadServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AutocompleteIngredientSearchServiceRequestOptions holds all parameters for the AutocompleteIngredientSearch operation.
type AutocompleteIngredientSearchServiceRequestOptions struct {
	Query *AutocompleteIngredientSearchQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AutocompleteIngredientSearchServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// IngredientSearchServiceRequestOptions holds all parameters for the IngredientSearch operation.
type IngredientSearchServiceRequestOptions struct {
	Query *IngredientSearchQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *IngredientSearchServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetIngredientSubstitutesServiceRequestOptions holds all parameters for the GetIngredientSubstitutes operation.
type GetIngredientSubstitutesServiceRequestOptions struct {
	Query *GetIngredientSubstitutesQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetIngredientSubstitutesServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetIngredientSubstitutesByIDServiceRequestOptions holds all parameters for the GetIngredientSubstitutesByID operation.
type GetIngredientSubstitutesByIDServiceRequestOptions struct {
	PathParams *GetIngredientSubstitutesByIDPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetIngredientSubstitutesByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchGroceryProductsServiceRequestOptions holds all parameters for the SearchGroceryProducts operation.
type SearchGroceryProductsServiceRequestOptions struct {
	Query *SearchGroceryProductsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchGroceryProductsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchGroceryProductsByUPCServiceRequestOptions holds all parameters for the SearchGroceryProductsByUPC operation.
type SearchGroceryProductsByUPCServiceRequestOptions struct {
	PathParams *SearchGroceryProductsByUPCPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchGroceryProductsByUPCServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchCustomFoodsServiceRequestOptions holds all parameters for the SearchCustomFoods operation.
type SearchCustomFoodsServiceRequestOptions struct {
	Query *SearchCustomFoodsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchCustomFoodsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetProductInformationServiceRequestOptions holds all parameters for the GetProductInformation operation.
type GetProductInformationServiceRequestOptions struct {
	PathParams *GetProductInformationPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetProductInformationServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetComparableProductsServiceRequestOptions holds all parameters for the GetComparableProducts operation.
type GetComparableProductsServiceRequestOptions struct {
	PathParams *GetComparableProductsPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetComparableProductsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AutocompleteProductSearchServiceRequestOptions holds all parameters for the AutocompleteProductSearch operation.
type AutocompleteProductSearchServiceRequestOptions struct {
	Query *AutocompleteProductSearchQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AutocompleteProductSearchServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeProductNutritionByIDServiceRequestOptions holds all parameters for the VisualizeProductNutritionByID operation.
type VisualizeProductNutritionByIDServiceRequestOptions struct {
	PathParams *VisualizeProductNutritionByIDPath
	Query      *VisualizeProductNutritionByIDQuery
	Header     *VisualizeProductNutritionByIDHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeProductNutritionByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ProductNutritionByIDImageServiceRequestOptions holds all parameters for the ProductNutritionByIDImage operation.
type ProductNutritionByIDImageServiceRequestOptions struct {
	PathParams *ProductNutritionByIDImagePath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ProductNutritionByIDImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ProductNutritionLabelWidgetServiceRequestOptions holds all parameters for the ProductNutritionLabelWidget operation.
type ProductNutritionLabelWidgetServiceRequestOptions struct {
	PathParams *ProductNutritionLabelWidgetPath
	Query      *ProductNutritionLabelWidgetQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ProductNutritionLabelWidgetServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ProductNutritionLabelImageServiceRequestOptions holds all parameters for the ProductNutritionLabelImage operation.
type ProductNutritionLabelImageServiceRequestOptions struct {
	PathParams *ProductNutritionLabelImagePath
	Query      *ProductNutritionLabelImageQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ProductNutritionLabelImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ClassifyGroceryProductServiceRequestOptions holds all parameters for the ClassifyGroceryProduct operation.
type ClassifyGroceryProductServiceRequestOptions struct {
	Query *ClassifyGroceryProductQuery
	Body  *ClassifyGroceryProductBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ClassifyGroceryProductServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ClassifyGroceryProductBulkServiceRequestOptions holds all parameters for the ClassifyGroceryProductBulk operation.
type ClassifyGroceryProductBulkServiceRequestOptions struct {
	Query *ClassifyGroceryProductBulkQuery
	Body  *ClassifyGroceryProductBulkBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ClassifyGroceryProductBulkServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// MapIngredientsToGroceryProductsServiceRequestOptions holds all parameters for the MapIngredientsToGroceryProducts operation.
type MapIngredientsToGroceryProductsServiceRequestOptions struct {
	Body *MapIngredientsToGroceryProductsBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *MapIngredientsToGroceryProductsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AutocompleteMenuItemSearchServiceRequestOptions holds all parameters for the AutocompleteMenuItemSearch operation.
type AutocompleteMenuItemSearchServiceRequestOptions struct {
	Query *AutocompleteMenuItemSearchQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AutocompleteMenuItemSearchServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchMenuItemsServiceRequestOptions holds all parameters for the SearchMenuItems operation.
type SearchMenuItemsServiceRequestOptions struct {
	Query *SearchMenuItemsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchMenuItemsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetMenuItemInformationServiceRequestOptions holds all parameters for the GetMenuItemInformation operation.
type GetMenuItemInformationServiceRequestOptions struct {
	PathParams *GetMenuItemInformationPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetMenuItemInformationServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// VisualizeMenuItemNutritionByIDServiceRequestOptions holds all parameters for the VisualizeMenuItemNutritionByID operation.
type VisualizeMenuItemNutritionByIDServiceRequestOptions struct {
	PathParams *VisualizeMenuItemNutritionByIDPath
	Query      *VisualizeMenuItemNutritionByIDQuery
	Header     *VisualizeMenuItemNutritionByIDHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *VisualizeMenuItemNutritionByIDServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// MenuItemNutritionByIDImageServiceRequestOptions holds all parameters for the MenuItemNutritionByIDImage operation.
type MenuItemNutritionByIDImageServiceRequestOptions struct {
	PathParams *MenuItemNutritionByIDImagePath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *MenuItemNutritionByIDImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// MenuItemNutritionLabelWidgetServiceRequestOptions holds all parameters for the MenuItemNutritionLabelWidget operation.
type MenuItemNutritionLabelWidgetServiceRequestOptions struct {
	PathParams *MenuItemNutritionLabelWidgetPath
	Query      *MenuItemNutritionLabelWidgetQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *MenuItemNutritionLabelWidgetServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// MenuItemNutritionLabelImageServiceRequestOptions holds all parameters for the MenuItemNutritionLabelImage operation.
type MenuItemNutritionLabelImageServiceRequestOptions struct {
	PathParams *MenuItemNutritionLabelImagePath
	Query      *MenuItemNutritionLabelImageQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *MenuItemNutritionLabelImageServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GenerateMealPlanServiceRequestOptions holds all parameters for the GenerateMealPlan operation.
type GenerateMealPlanServiceRequestOptions struct {
	Query *GenerateMealPlanQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GenerateMealPlanServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetMealPlanWeekServiceRequestOptions holds all parameters for the GetMealPlanWeek operation.
type GetMealPlanWeekServiceRequestOptions struct {
	PathParams *GetMealPlanWeekPath
	Query      *GetMealPlanWeekQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetMealPlanWeekServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ClearMealPlanDayServiceRequestOptions holds all parameters for the ClearMealPlanDay operation.
type ClearMealPlanDayServiceRequestOptions struct {
	PathParams *ClearMealPlanDayPath
	Query      *ClearMealPlanDayQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ClearMealPlanDayServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AddToMealPlanServiceRequestOptions holds all parameters for the AddToMealPlan operation.
type AddToMealPlanServiceRequestOptions struct {
	PathParams *AddToMealPlanPath
	Query      *AddToMealPlanQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AddToMealPlanServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// DeleteFromMealPlanServiceRequestOptions holds all parameters for the DeleteFromMealPlan operation.
type DeleteFromMealPlanServiceRequestOptions struct {
	PathParams *DeleteFromMealPlanPath
	Query      *DeleteFromMealPlanQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *DeleteFromMealPlanServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetMealPlanTemplatesServiceRequestOptions holds all parameters for the GetMealPlanTemplates operation.
type GetMealPlanTemplatesServiceRequestOptions struct {
	PathParams *GetMealPlanTemplatesPath
	Query      *GetMealPlanTemplatesQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetMealPlanTemplatesServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AddMealPlanTemplateServiceRequestOptions holds all parameters for the AddMealPlanTemplate operation.
type AddMealPlanTemplateServiceRequestOptions struct {
	PathParams *AddMealPlanTemplatePath
	Query      *AddMealPlanTemplateQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AddMealPlanTemplateServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetMealPlanTemplateServiceRequestOptions holds all parameters for the GetMealPlanTemplate operation.
type GetMealPlanTemplateServiceRequestOptions struct {
	PathParams *GetMealPlanTemplatePath
	Query      *GetMealPlanTemplateQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetMealPlanTemplateServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// DeleteMealPlanTemplateServiceRequestOptions holds all parameters for the DeleteMealPlanTemplate operation.
type DeleteMealPlanTemplateServiceRequestOptions struct {
	PathParams *DeleteMealPlanTemplatePath
	Query      *DeleteMealPlanTemplateQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *DeleteMealPlanTemplateServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetShoppingListServiceRequestOptions holds all parameters for the GetShoppingList operation.
type GetShoppingListServiceRequestOptions struct {
	PathParams *GetShoppingListPath
	Query      *GetShoppingListQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetShoppingListServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GenerateShoppingListServiceRequestOptions holds all parameters for the GenerateShoppingList operation.
type GenerateShoppingListServiceRequestOptions struct {
	PathParams *GenerateShoppingListPath
	Query      *GenerateShoppingListQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GenerateShoppingListServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ConnectUserServiceRequestOptions holds all parameters for the ConnectUser operation.
type ConnectUserServiceRequestOptions struct {
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ConnectUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if len(errors) == 0 {
		return nil
	}

	return errors
}

// AddToShoppingListServiceRequestOptions holds all parameters for the AddToShoppingList operation.
type AddToShoppingListServiceRequestOptions struct {
	PathParams *AddToShoppingListPath
	Query      *AddToShoppingListQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *AddToShoppingListServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// DeleteFromShoppingListServiceRequestOptions holds all parameters for the DeleteFromShoppingList operation.
type DeleteFromShoppingListServiceRequestOptions struct {
	PathParams *DeleteFromShoppingListPath
	Query      *DeleteFromShoppingListQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *DeleteFromShoppingListServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchRestaurantsServiceRequestOptions holds all parameters for the SearchRestaurants operation.
type SearchRestaurantsServiceRequestOptions struct {
	Query *SearchRestaurantsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchRestaurantsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetDishPairingForWineServiceRequestOptions holds all parameters for the GetDishPairingForWine operation.
type GetDishPairingForWineServiceRequestOptions struct {
	Query *GetDishPairingForWineQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetDishPairingForWineServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetWinePairingServiceRequestOptions holds all parameters for the GetWinePairing operation.
type GetWinePairingServiceRequestOptions struct {
	Query *GetWinePairingQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetWinePairingServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetWineDescriptionServiceRequestOptions holds all parameters for the GetWineDescription operation.
type GetWineDescriptionServiceRequestOptions struct {
	Query *GetWineDescriptionQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetWineDescriptionServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetWineRecommendationServiceRequestOptions holds all parameters for the GetWineRecommendation operation.
type GetWineRecommendationServiceRequestOptions struct {
	Query *GetWineRecommendationQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetWineRecommendationServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ImageClassificationByURLServiceRequestOptions holds all parameters for the ImageClassificationByURL operation.
type ImageClassificationByURLServiceRequestOptions struct {
	Query *ImageClassificationByURLQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ImageClassificationByURLServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// ImageAnalysisByURLServiceRequestOptions holds all parameters for the ImageAnalysisByURL operation.
type ImageAnalysisByURLServiceRequestOptions struct {
	Query *ImageAnalysisByURLQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ImageAnalysisByURLServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// QuickAnswerServiceRequestOptions holds all parameters for the QuickAnswer operation.
type QuickAnswerServiceRequestOptions struct {
	Query *QuickAnswerQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *QuickAnswerServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// DetectFoodInTextServiceRequestOptions holds all parameters for the DetectFoodInText operation.
type DetectFoodInTextServiceRequestOptions struct {
	Body   *DetectFoodInTextBody
	Header *DetectFoodInTextHeaders
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *DetectFoodInTextServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}

	if o.Header != nil {
		if v, ok := any(o.Header).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Header", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchSiteContentServiceRequestOptions holds all parameters for the SearchSiteContent operation.
type SearchSiteContentServiceRequestOptions struct {
	Query *SearchSiteContentQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchSiteContentServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchAllFoodServiceRequestOptions holds all parameters for the SearchAllFood operation.
type SearchAllFoodServiceRequestOptions struct {
	Query *SearchAllFoodQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchAllFoodServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// SearchFoodVideosServiceRequestOptions holds all parameters for the SearchFoodVideos operation.
type SearchFoodVideosServiceRequestOptions struct {
	Query *SearchFoodVideosQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *SearchFoodVideosServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// TalkToChatbotServiceRequestOptions holds all parameters for the TalkToChatbot operation.
type TalkToChatbotServiceRequestOptions struct {
	Query *TalkToChatbotQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *TalkToChatbotServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetConversationSuggestsServiceRequestOptions holds all parameters for the GetConversationSuggests operation.
type GetConversationSuggestsServiceRequestOptions struct {
	Query *GetConversationSuggestsQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetConversationSuggestsServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

type SearchRecipes_Response_Results []SearchRecipes_Response_Results_Item

func (s SearchRecipes_Response_Results) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipes_Response_Results_Item struct {
	ID        int64   `json:"id" validate:"required"`
	Title     string  `json:"title" validate:"required,min=1"`
	Calories  float32 `json:"calories" validate:"required"`
	Carbs     string  `json:"carbs" validate:"required,min=1"`
	Fat       string  `json:"fat" validate:"required,min=1"`
	Image     string  `json:"image" validate:"required,min=1"`
	ImageType string  `json:"imageType" validate:"required,min=1"`
	Protein   string  `json:"protein" validate:"required,min=1"`
}

func (s SearchRecipes_Response_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByIngredients_Response []SearchRecipesByIngredients_Response_Item

func (s SearchRecipesByIngredients_Response) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByIngredients_Response_MissedIngredients []SearchRecipesByIngredients_Response_MissedIngredients_Item

func (s SearchRecipesByIngredients_Response_MissedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByIngredients_Response_MissedIngredients_Item struct {
	Aisle        string   `json:"aisle" validate:"required,min=1"`
	Amount       float32  `json:"amount" validate:"required"`
	ID           int64    `json:"id" validate:"required"`
	Image        string   `json:"image" validate:"required,min=1"`
	Meta         []string `json:"meta,omitempty"`
	Name         string   `json:"name" validate:"required,min=1"`
	Original     string   `json:"original" validate:"required,min=1"`
	OriginalName string   `json:"originalName" validate:"required,min=1"`
	Unit         string   `json:"unit" validate:"required,min=0"`
	UnitLong     string   `json:"unitLong" validate:"required,min=0"`
	UnitShort    string   `json:"unitShort" validate:"required,min=0"`
}

func (s SearchRecipesByIngredients_Response_MissedIngredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByIngredients_Response_UsedIngredients []SearchRecipesByIngredients_Response_UsedIngredients_Item

func (s SearchRecipesByIngredients_Response_UsedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByIngredients_Response_UsedIngredients_Item struct {
	Aisle        string   `json:"aisle" validate:"required,min=1"`
	Amount       float32  `json:"amount" validate:"required"`
	ID           int64    `json:"id" validate:"required"`
	Image        string   `json:"image" validate:"required,min=1"`
	Meta         []string `json:"meta,omitempty"`
	Name         string   `json:"name" validate:"required,min=1"`
	Original     string   `json:"original" validate:"required,min=1"`
	OriginalName string   `json:"originalName" validate:"required,min=1"`
	Unit         string   `json:"unit" validate:"required,min=0"`
	UnitLong     string   `json:"unitLong" validate:"required,min=0"`
	UnitShort    string   `json:"unitShort" validate:"required,min=0"`
}

func (s SearchRecipesByIngredients_Response_UsedIngredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByIngredients_Response_Item struct {
	ID                    int64                                                 `json:"id" validate:"required"`
	Image                 string                                                `json:"image" validate:"required,min=1"`
	ImageType             string                                                `json:"imageType" validate:"required,min=1"`
	Likes                 int64                                                 `json:"likes" validate:"required"`
	MissedIngredientCount int64                                                 `json:"missedIngredientCount" validate:"required"`
	MissedIngredients     SearchRecipesByIngredients_Response_MissedIngredients `json:"missedIngredients" validate:"required"`
	Title                 string                                                `json:"title" validate:"required,min=1"`
	UnusedIngredients     []map[string]any                                      `json:"unusedIngredients" validate:"required"`
	UsedIngredientCount   float32                                               `json:"usedIngredientCount" validate:"required"`
	UsedIngredients       SearchRecipesByIngredients_Response_UsedIngredients   `json:"usedIngredients" validate:"required"`
}

func (s SearchRecipesByIngredients_Response_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(s.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if err := typesValidator.Var(s.MissedIngredientCount, "required"); err != nil {
		errors = errors.Append("MissedIngredientCount", err)
	}
	if v, ok := any(s.MissedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("MissedIngredients", err)
		}
	}
	if err := typesValidator.Var(s.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(s.UnusedIngredients, "required"); err != nil {
		errors = errors.Append("UnusedIngredients", err)
	}
	if err := typesValidator.Var(s.UsedIngredientCount, "required"); err != nil {
		errors = errors.Append("UsedIngredientCount", err)
	}
	if v, ok := any(s.UsedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UsedIngredients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByNutrients_Response []SearchRecipesByNutrients_Response_Item

func (s SearchRecipesByNutrients_Response) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByNutrients_Response_Item struct {
	Calories  float32 `json:"calories" validate:"required"`
	Carbs     string  `json:"carbs" validate:"required,min=1"`
	Fat       string  `json:"fat" validate:"required,min=1"`
	ID        int64   `json:"id" validate:"required"`
	Image     string  `json:"image" validate:"required,min=1"`
	ImageType string  `json:"imageType" validate:"required,min=1"`
	Protein   string  `json:"protein" validate:"required,min=1"`
	Title     string  `json:"title" validate:"required,min=1"`
}

func (s SearchRecipesByNutrients_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetRecipeInformation_Response_ExtendedIngredients []GetRecipeInformation_Response_ExtendedIngredients_Item

func (g GetRecipeInformation_Response_ExtendedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_ExtendedIngredients_Measures struct {
	Metric GetRecipeInformation_Response_ExtendedIngredients_Measures_Metric `json:"metric"`
	Us     GetRecipeInformation_Response_ExtendedIngredients_Measures_Us     `json:"us"`
}

func (g GetRecipeInformation_Response_ExtendedIngredients_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_ExtendedIngredients_Measures_Metric struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRecipeInformation_Response_ExtendedIngredients_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformation_Response_ExtendedIngredients_Measures_Us struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRecipeInformation_Response_ExtendedIngredients_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformation_Response_ExtendedIngredients_Item struct {
	Aisle        string                                                      `json:"aisle" validate:"required,min=1"`
	Amount       float32                                                     `json:"amount" validate:"required"`
	Consitency   string                                                      `json:"consitency" validate:"required,min=1"`
	ID           int64                                                       `json:"id" validate:"required"`
	Image        string                                                      `json:"image" validate:"required,min=1"`
	Measures     *GetRecipeInformation_Response_ExtendedIngredients_Measures `json:"measures,omitempty"`
	Meta         []string                                                    `json:"meta,omitempty"`
	Name         string                                                      `json:"name" validate:"required,min=1"`
	Original     string                                                      `json:"original" validate:"required,min=1"`
	OriginalName string                                                      `json:"originalName" validate:"required,min=1"`
	Unit         string                                                      `json:"unit" validate:"required,min=0"`
}

func (g GetRecipeInformation_Response_ExtendedIngredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(g.Consitency, "required,min=1"); err != nil {
		errors = errors.Append("Consitency", err)
	}
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(g.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=0"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_WinePairing struct {
	PairedWines    []string                                                 `json:"pairedWines" validate:"required"`
	PairingText    string                                                   `json:"pairingText" validate:"required,min=1"`
	ProductMatches GetRecipeInformation_Response_WinePairing_ProductMatches `json:"productMatches" validate:"required"`
}

func (g GetRecipeInformation_Response_WinePairing) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(g.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(g.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_WinePairing_ProductMatches []GetRecipeInformation_Response_WinePairing_ProductMatches_Item

func (g GetRecipeInformation_Response_WinePairing_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformation_Response_WinePairing_ProductMatches_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	Description   string  `json:"description" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
	Link          string  `json:"link" validate:"required,min=1"`
}

func (g GetRecipeInformation_Response_WinePairing_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformationBulk_Response []GetRecipeInformationBulk_Response_Item

func (g GetRecipeInformationBulk_Response) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_ExtendedIngredients []GetRecipeInformationBulk_Response_ExtendedIngredients_Item

func (g GetRecipeInformationBulk_Response_ExtendedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_ExtendedIngredients_Measures struct {
	Metric GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Metric `json:"metric"`
	Us     GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Us     `json:"us"`
}

func (g GetRecipeInformationBulk_Response_ExtendedIngredients_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Metric struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Us struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRecipeInformationBulk_Response_ExtendedIngredients_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformationBulk_Response_ExtendedIngredients_Item struct {
	Aisle        string                                                          `json:"aisle" validate:"required,min=1"`
	Amount       float32                                                         `json:"amount" validate:"required"`
	Consitency   string                                                          `json:"consitency" validate:"required,min=1"`
	ID           int64                                                           `json:"id" validate:"required"`
	Image        string                                                          `json:"image" validate:"required,min=1"`
	Measures     *GetRecipeInformationBulk_Response_ExtendedIngredients_Measures `json:"measures,omitempty"`
	Meta         []string                                                        `json:"meta,omitempty"`
	Name         string                                                          `json:"name" validate:"required,min=1"`
	Original     string                                                          `json:"original" validate:"required,min=1"`
	OriginalName string                                                          `json:"originalName" validate:"required,min=1"`
	Unit         string                                                          `json:"unit" validate:"required,min=0"`
}

func (g GetRecipeInformationBulk_Response_ExtendedIngredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(g.Consitency, "required,min=1"); err != nil {
		errors = errors.Append("Consitency", err)
	}
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(g.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=0"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_WinePairing struct {
	PairedWines    []string                                                     `json:"pairedWines" validate:"required"`
	PairingText    string                                                       `json:"pairingText" validate:"required,min=1"`
	ProductMatches GetRecipeInformationBulk_Response_WinePairing_ProductMatches `json:"productMatches" validate:"required"`
}

func (g GetRecipeInformationBulk_Response_WinePairing) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(g.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(g.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_WinePairing_ProductMatches []GetRecipeInformationBulk_Response_WinePairing_ProductMatches_Item

func (g GetRecipeInformationBulk_Response_WinePairing_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulk_Response_WinePairing_ProductMatches_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	Description   string  `json:"description" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
	Link          string  `json:"link" validate:"required,min=1"`
}

func (g GetRecipeInformationBulk_Response_WinePairing_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeInformationBulk_Response_Item struct {
	ID                       int64                                                 `json:"id" validate:"required"`
	Title                    string                                                `json:"title" validate:"required,min=1"`
	Image                    string                                                `json:"image" validate:"required,min=1"`
	ImageType                string                                                `json:"imageType" validate:"required,min=1"`
	Servings                 float32                                               `json:"servings" validate:"required"`
	ReadyInMinutes           int64                                                 `json:"readyInMinutes" validate:"required"`
	License                  string                                                `json:"license" validate:"required,min=1"`
	SourceName               string                                                `json:"sourceName" validate:"required,min=1"`
	SourceURL                string                                                `json:"sourceUrl" validate:"required,min=1"`
	SpoonacularSourceURL     string                                                `json:"spoonacularSourceUrl" validate:"required,min=1"`
	AggregateLikes           int64                                                 `json:"aggregateLikes" validate:"required"`
	HealthScore              float32                                               `json:"healthScore" validate:"required"`
	SpoonacularScore         float32                                               `json:"spoonacularScore" validate:"required"`
	PricePerServing          float32                                               `json:"pricePerServing" validate:"required"`
	AnalyzedInstructions     []string                                              `json:"analyzedInstructions" validate:"required"`
	Cheap                    bool                                                  `json:"cheap"`
	CreditsText              string                                                `json:"creditsText" validate:"required,min=1"`
	Cuisines                 []string                                              `json:"cuisines" validate:"required"`
	DairyFree                bool                                                  `json:"dairyFree"`
	Diets                    []string                                              `json:"diets" validate:"required"`
	Gaps                     string                                                `json:"gaps" validate:"required,min=1"`
	GlutenFree               bool                                                  `json:"glutenFree"`
	Instructions             string                                                `json:"instructions" validate:"required"`
	Ketogenic                bool                                                  `json:"ketogenic"`
	LowFodmap                bool                                                  `json:"lowFodmap"`
	Occasions                []string                                              `json:"occasions" validate:"required"`
	Sustainable              bool                                                  `json:"sustainable"`
	Vegan                    bool                                                  `json:"vegan"`
	Vegetarian               bool                                                  `json:"vegetarian"`
	VeryHealthy              bool                                                  `json:"veryHealthy"`
	VeryPopular              bool                                                  `json:"veryPopular"`
	Whole30                  bool                                                  `json:"whole30"`
	WeightWatcherSmartPoints float32                                               `json:"weightWatcherSmartPoints" validate:"required"`
	DishTypes                []string                                              `json:"dishTypes" validate:"required"`
	ExtendedIngredients      GetRecipeInformationBulk_Response_ExtendedIngredients `json:"extendedIngredients" validate:"required"`
	Summary                  string                                                `json:"summary" validate:"required,min=1"`
	WinePairing              GetRecipeInformationBulk_Response_WinePairing         `json:"winePairing"`
}

func (g GetRecipeInformationBulk_Response_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Servings, "required"); err != nil {
		errors = errors.Append("Servings", err)
	}
	if err := typesValidator.Var(g.ReadyInMinutes, "required"); err != nil {
		errors = errors.Append("ReadyInMinutes", err)
	}
	if err := typesValidator.Var(g.License, "required,min=1"); err != nil {
		errors = errors.Append("License", err)
	}
	if err := typesValidator.Var(g.SourceName, "required,min=1"); err != nil {
		errors = errors.Append("SourceName", err)
	}
	if err := typesValidator.Var(g.SourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SourceURL", err)
	}
	if err := typesValidator.Var(g.SpoonacularSourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SpoonacularSourceURL", err)
	}
	if err := typesValidator.Var(g.AggregateLikes, "required"); err != nil {
		errors = errors.Append("AggregateLikes", err)
	}
	if err := typesValidator.Var(g.HealthScore, "required"); err != nil {
		errors = errors.Append("HealthScore", err)
	}
	if err := typesValidator.Var(g.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if err := typesValidator.Var(g.PricePerServing, "required"); err != nil {
		errors = errors.Append("PricePerServing", err)
	}
	if err := typesValidator.Var(g.AnalyzedInstructions, "required"); err != nil {
		errors = errors.Append("AnalyzedInstructions", err)
	}
	if err := typesValidator.Var(g.CreditsText, "required,min=1"); err != nil {
		errors = errors.Append("CreditsText", err)
	}
	if err := typesValidator.Var(g.Cuisines, "required"); err != nil {
		errors = errors.Append("Cuisines", err)
	}
	if err := typesValidator.Var(g.Diets, "required"); err != nil {
		errors = errors.Append("Diets", err)
	}
	if err := typesValidator.Var(g.Gaps, "required,min=1"); err != nil {
		errors = errors.Append("Gaps", err)
	}
	if err := typesValidator.Var(g.Instructions, "required"); err != nil {
		errors = errors.Append("Instructions", err)
	}
	if err := typesValidator.Var(g.Occasions, "required"); err != nil {
		errors = errors.Append("Occasions", err)
	}
	if err := typesValidator.Var(g.WeightWatcherSmartPoints, "required"); err != nil {
		errors = errors.Append("WeightWatcherSmartPoints", err)
	}
	if err := typesValidator.Var(g.DishTypes, "required"); err != nil {
		errors = errors.Append("DishTypes", err)
	}
	if v, ok := any(g.ExtendedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ExtendedIngredients", err)
		}
	}
	if err := typesValidator.Var(g.Summary, "required,min=1"); err != nil {
		errors = errors.Append("Summary", err)
	}
	if v, ok := any(g.WinePairing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WinePairing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSimilarRecipes_Response []GetSimilarRecipes_Response_Item

func (g GetSimilarRecipes_Response) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSimilarRecipes_Response_Item struct {
	ID             int64   `json:"id" validate:"required"`
	Title          string  `json:"title" validate:"required,min=1"`
	ImageType      string  `json:"imageType" validate:"required,min=1"`
	ReadyInMinutes int64   `json:"readyInMinutes" validate:"required"`
	Servings       float32 `json:"servings" validate:"required"`
	SourceURL      string  `json:"sourceUrl" validate:"required,min=1"`
}

func (g GetSimilarRecipes_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipes_Response_Recipes []GetRandomRecipes_Response_Recipes_Item

func (g GetRandomRecipes_Response_Recipes) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients []GetRandomRecipes_Response_Recipes_ExtendedIngredients_Item

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures struct {
	Metric GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Metric `json:"metric"`
	Us     GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Us     `json:"us"`
}

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Metric struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Us struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipes_Response_Recipes_ExtendedIngredients_Item struct {
	Aisle        string                                                          `json:"aisle" validate:"required,min=1"`
	Amount       float32                                                         `json:"amount" validate:"required"`
	Consitency   string                                                          `json:"consitency" validate:"required,min=1"`
	ID           int64                                                           `json:"id" validate:"required"`
	Image        string                                                          `json:"image" validate:"required,min=1"`
	Measures     *GetRandomRecipes_Response_Recipes_ExtendedIngredients_Measures `json:"measures,omitempty"`
	Meta         []string                                                        `json:"meta,omitempty"`
	Name         string                                                          `json:"name" validate:"required,min=1"`
	Original     string                                                          `json:"original" validate:"required,min=1"`
	OriginalName string                                                          `json:"originalName" validate:"required,min=1"`
	Unit         string                                                          `json:"unit" validate:"required,min=0"`
}

func (g GetRandomRecipes_Response_Recipes_ExtendedIngredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(g.Consitency, "required,min=1"); err != nil {
		errors = errors.Append("Consitency", err)
	}
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(g.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=0"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_WinePairing struct {
	PairedWines    []string                                                     `json:"pairedWines" validate:"required"`
	PairingText    string                                                       `json:"pairingText" validate:"required,min=1"`
	ProductMatches GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches `json:"productMatches" validate:"required"`
}

func (g GetRandomRecipes_Response_Recipes_WinePairing) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(g.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(g.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches []GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches_Item

func (g GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	Description   string  `json:"description" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
	Link          string  `json:"link" validate:"required,min=1"`
}

func (g GetRandomRecipes_Response_Recipes_WinePairing_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipes_Response_Recipes_Item struct {
	ID                       int64                                                  `json:"id" validate:"required"`
	Title                    string                                                 `json:"title" validate:"required,min=1"`
	Image                    string                                                 `json:"image" validate:"required,min=1"`
	ImageType                string                                                 `json:"imageType" validate:"required,min=1"`
	Servings                 float32                                                `json:"servings" validate:"required"`
	ReadyInMinutes           int64                                                  `json:"readyInMinutes" validate:"required"`
	License                  string                                                 `json:"license" validate:"required,min=1"`
	SourceName               string                                                 `json:"sourceName" validate:"required,min=1"`
	SourceURL                string                                                 `json:"sourceUrl" validate:"required,min=1"`
	SpoonacularSourceURL     string                                                 `json:"spoonacularSourceUrl" validate:"required,min=1"`
	AggregateLikes           float32                                                `json:"aggregateLikes" validate:"required"`
	HealthScore              float32                                                `json:"healthScore" validate:"required"`
	SpoonacularScore         float32                                                `json:"spoonacularScore" validate:"required"`
	PricePerServing          float32                                                `json:"pricePerServing" validate:"required"`
	AnalyzedInstructions     []map[string]any                                       `json:"analyzedInstructions,omitempty"`
	Cheap                    bool                                                   `json:"cheap"`
	CreditsText              string                                                 `json:"creditsText" validate:"required,min=1"`
	Cuisines                 []string                                               `json:"cuisines,omitempty"`
	DairyFree                bool                                                   `json:"dairyFree"`
	Diets                    []string                                               `json:"diets,omitempty"`
	Gaps                     string                                                 `json:"gaps" validate:"required,min=1"`
	GlutenFree               bool                                                   `json:"glutenFree"`
	Instructions             string                                                 `json:"instructions" validate:"required"`
	Ketogenic                bool                                                   `json:"ketogenic"`
	LowFodmap                bool                                                   `json:"lowFodmap"`
	Occasions                []string                                               `json:"occasions,omitempty"`
	Sustainable              bool                                                   `json:"sustainable"`
	Vegan                    bool                                                   `json:"vegan"`
	Vegetarian               bool                                                   `json:"vegetarian"`
	VeryHealthy              bool                                                   `json:"veryHealthy"`
	VeryPopular              bool                                                   `json:"veryPopular"`
	Whole30                  bool                                                   `json:"whole30"`
	WeightWatcherSmartPoints float32                                                `json:"weightWatcherSmartPoints" validate:"required"`
	DishTypes                []string                                               `json:"dishTypes,omitempty"`
	ExtendedIngredients      *GetRandomRecipes_Response_Recipes_ExtendedIngredients `json:"extendedIngredients,omitempty"`
	Summary                  string                                                 `json:"summary" validate:"required,min=1"`
	WinePairing              *GetRandomRecipes_Response_Recipes_WinePairing         `json:"winePairing,omitempty"`
}

func (g GetRandomRecipes_Response_Recipes_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Servings, "required"); err != nil {
		errors = errors.Append("Servings", err)
	}
	if err := typesValidator.Var(g.ReadyInMinutes, "required"); err != nil {
		errors = errors.Append("ReadyInMinutes", err)
	}
	if err := typesValidator.Var(g.License, "required,min=1"); err != nil {
		errors = errors.Append("License", err)
	}
	if err := typesValidator.Var(g.SourceName, "required,min=1"); err != nil {
		errors = errors.Append("SourceName", err)
	}
	if err := typesValidator.Var(g.SourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SourceURL", err)
	}
	if err := typesValidator.Var(g.SpoonacularSourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SpoonacularSourceURL", err)
	}
	if err := typesValidator.Var(g.AggregateLikes, "required"); err != nil {
		errors = errors.Append("AggregateLikes", err)
	}
	if err := typesValidator.Var(g.HealthScore, "required"); err != nil {
		errors = errors.Append("HealthScore", err)
	}
	if err := typesValidator.Var(g.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if err := typesValidator.Var(g.PricePerServing, "required"); err != nil {
		errors = errors.Append("PricePerServing", err)
	}
	if err := typesValidator.Var(g.CreditsText, "required,min=1"); err != nil {
		errors = errors.Append("CreditsText", err)
	}
	if err := typesValidator.Var(g.Gaps, "required,min=1"); err != nil {
		errors = errors.Append("Gaps", err)
	}
	if err := typesValidator.Var(g.Instructions, "required"); err != nil {
		errors = errors.Append("Instructions", err)
	}
	if err := typesValidator.Var(g.WeightWatcherSmartPoints, "required"); err != nil {
		errors = errors.Append("WeightWatcherSmartPoints", err)
	}
	if g.ExtendedIngredients != nil {
		if v, ok := any(g.ExtendedIngredients).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("ExtendedIngredients", err)
			}
		}
	}
	if err := typesValidator.Var(g.Summary, "required,min=1"); err != nil {
		errors = errors.Append("Summary", err)
	}
	if g.WinePairing != nil {
		if v, ok := any(g.WinePairing).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("WinePairing", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteRecipeSearch_Response []AutocompleteRecipeSearch_Response_Item

func (a AutocompleteRecipeSearch_Response) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteRecipeSearch_Response_Item struct {
	ID        int64  `json:"id" validate:"required"`
	Title     string `json:"title" validate:"required,min=1"`
	ImageType string `json:"imageType" validate:"required,min=1"`
}

func (a AutocompleteRecipeSearch_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type GetRecipeEquipmentByID_Response_Equipment []GetRecipeEquipmentByID_Response_Equipment_Item

func (g GetRecipeEquipmentByID_Response_Equipment) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeEquipmentByID_Response_Equipment_Item struct {
	Image string `json:"image" validate:"required,min=1"`
	Name  string `json:"name" validate:"required,min=1"`
}

func (g GetRecipeEquipmentByID_Response_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipePriceBreakdownByID_Response_Ingredients []GetRecipePriceBreakdownByID_Response_Ingredients_Item

func (g GetRecipePriceBreakdownByID_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipePriceBreakdownByID_Response_Ingredients_Amount struct {
	Metric GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Metric `json:"metric"`
	Us     GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Us     `json:"us"`
}

func (g GetRecipePriceBreakdownByID_Response_Ingredients_Amount) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Metric struct {
	Unit  string  `json:"unit" validate:"required,min=0"`
	Value float32 `json:"value" validate:"required"`
}

func (g GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Us struct {
	Unit  string  `json:"unit" validate:"required,min=0"`
	Value float32 `json:"value" validate:"required"`
}

func (g GetRecipePriceBreakdownByID_Response_Ingredients_Amount_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipePriceBreakdownByID_Response_Ingredients_Item struct {
	Amount *GetRecipePriceBreakdownByID_Response_Ingredients_Amount `json:"amount,omitempty"`
	Image  string                                                   `json:"image" validate:"required,min=1"`
	Name   string                                                   `json:"name" validate:"required,min=1"`
	Price  float32                                                  `json:"price" validate:"required"`
}

func (g GetRecipePriceBreakdownByID_Response_Ingredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if g.Amount != nil {
		if v, ok := any(g.Amount).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Amount", err)
			}
		}
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Price, "required"); err != nil {
		errors = errors.Append("Price", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeIngredientsByID_Response_Ingredients []GetRecipeIngredientsByID_Response_Ingredients_Item

func (g GetRecipeIngredientsByID_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeIngredientsByID_Response_Ingredients_Amount struct {
	Metric GetRecipeIngredientsByID_Response_Ingredients_Amount_Metric `json:"metric"`
	Us     GetRecipeIngredientsByID_Response_Ingredients_Amount_Us     `json:"us"`
}

func (g GetRecipeIngredientsByID_Response_Ingredients_Amount) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeIngredientsByID_Response_Ingredients_Amount_Metric struct {
	Unit  string  `json:"unit" validate:"required,min=0"`
	Value float32 `json:"value" validate:"required"`
}

func (g GetRecipeIngredientsByID_Response_Ingredients_Amount_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeIngredientsByID_Response_Ingredients_Amount_Us struct {
	Unit  string  `json:"unit" validate:"required,min=0"`
	Value float32 `json:"value" validate:"required"`
}

func (g GetRecipeIngredientsByID_Response_Ingredients_Amount_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeIngredientsByID_Response_Ingredients_Item struct {
	Amount *GetRecipeIngredientsByID_Response_Ingredients_Amount `json:"amount,omitempty"`
	Image  string                                                `json:"image" validate:"required,min=1"`
	Name   string                                                `json:"name" validate:"required,min=1"`
}

func (g GetRecipeIngredientsByID_Response_Ingredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if g.Amount != nil {
		if v, ok := any(g.Amount).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Amount", err)
			}
		}
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeNutritionWidgetByID_Response_Bad []GetRecipeNutritionWidgetByID_Response_Bad_Item

func (g GetRecipeNutritionWidgetByID_Response_Bad) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeNutritionWidgetByID_Response_Bad_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              string  `json:"amount" validate:"required,min=1"`
	Indented            bool    `json:"indented"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (g GetRecipeNutritionWidgetByID_Response_Bad_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRecipeNutritionWidgetByID_Response_Good []GetRecipeNutritionWidgetByID_Response_Good_Item

func (g GetRecipeNutritionWidgetByID_Response_Good) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeNutritionWidgetByID_Response_Good_Item struct {
	Amount              string  `json:"amount" validate:"required,min=1"`
	Indented            bool    `json:"indented"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
	Name                string  `json:"name" validate:"required,min=1"`
}

func (g GetRecipeNutritionWidgetByID_Response_Good_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions []GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Item

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps []GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Item

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients []GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item struct {
	ID            int64  `json:"id" validate:"required"`
	Name          string `json:"name" validate:"required,min=1"`
	LocalizedName string `json:"localizedName" validate:"required,min=1"`
	Image         string `json:"image" validate:"required,min=1"`
}

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment []GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item struct {
	ID            int64  `json:"id" validate:"required"`
	Name          string `json:"name" validate:"required,min=1"`
	LocalizedName string `json:"localizedName" validate:"required,min=1"`
	Image         string `json:"image" validate:"required,min=1"`
}

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Item struct {
	Number      float32                                                                      `json:"number" validate:"required"`
	Step        string                                                                       `json:"step" validate:"required,min=1"`
	Ingredients *GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients `json:"ingredients,omitempty"`
	Equipment   *GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Equipment   `json:"equipment,omitempty"`
}

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if err := typesValidator.Var(g.Step, "required,min=1"); err != nil {
		errors = errors.Append("Step", err)
	}
	if g.Ingredients != nil {
		if v, ok := any(g.Ingredients).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Ingredients", err)
			}
		}
	}
	if g.Equipment != nil {
		if v, ok := any(g.Equipment).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Equipment", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Item struct {
	Name  string                                                           `json:"name" validate:"required"`
	Steps *GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Steps `json:"steps,omitempty"`
}

func (g GetAnalyzedRecipeInstructions_Response_ParsedInstructions_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if g.Steps != nil {
		if v, ok := any(g.Steps).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Steps", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_Ingredients []GetAnalyzedRecipeInstructions_Response_Ingredients_Item

func (g GetAnalyzedRecipeInstructions_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_Ingredients_Item struct {
	ID   int64  `json:"id" validate:"required"`
	Name string `json:"name" validate:"required,min=1"`
}

func (g GetAnalyzedRecipeInstructions_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAnalyzedRecipeInstructions_Response_Equipment []GetAnalyzedRecipeInstructions_Response_Equipment_Item

func (g GetAnalyzedRecipeInstructions_Response_Equipment) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAnalyzedRecipeInstructions_Response_Equipment_Item struct {
	ID   int64  `json:"id" validate:"required"`
	Name string `json:"name" validate:"required,min=1"`
}

func (g GetAnalyzedRecipeInstructions_Response_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients []ExtractRecipeFromWebsite_Response_ExtendedIngredients_Item

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(e) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(e)))
	}
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures struct {
	Metric ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Metric `json:"metric"`
	Us     ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Us     `json:"us"`
}

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(e.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Metric struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Us struct {
	Amount    float32 `json:"amount" validate:"required"`
	UnitLong  string  `json:"unitLong" validate:"required,min=0"`
	UnitShort string  `json:"unitShort" validate:"required,min=0"`
}

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type ExtractRecipeFromWebsite_Response_ExtendedIngredients_Item struct {
	Aisle        string                                                          `json:"aisle" validate:"required,min=1"`
	Amount       float32                                                         `json:"amount" validate:"required"`
	Consitency   string                                                          `json:"consitency" validate:"required,min=1"`
	ID           int64                                                           `json:"id" validate:"required"`
	Image        string                                                          `json:"image" validate:"required,min=1"`
	Measures     *ExtractRecipeFromWebsite_Response_ExtendedIngredients_Measures `json:"measures,omitempty"`
	Meta         []string                                                        `json:"meta,omitempty"`
	Name         string                                                          `json:"name" validate:"required,min=1"`
	Original     string                                                          `json:"original" validate:"required,min=1"`
	OriginalName string                                                          `json:"originalName" validate:"required,min=1"`
	Unit         string                                                          `json:"unit" validate:"required,min=0"`
}

func (e ExtractRecipeFromWebsite_Response_ExtendedIngredients_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(e.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(e.Consitency, "required,min=1"); err != nil {
		errors = errors.Append("Consitency", err)
	}
	if err := typesValidator.Var(e.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(e.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if e.Measures != nil {
		if v, ok := any(e.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(e.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(e.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(e.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(e.Unit, "required,min=0"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_WinePairing struct {
	PairedWines    []string                                                     `json:"pairedWines" validate:"required"`
	PairingText    string                                                       `json:"pairingText" validate:"required,min=1"`
	ProductMatches ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches `json:"productMatches" validate:"required"`
}

func (e ExtractRecipeFromWebsite_Response_WinePairing) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(e.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(e.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches []ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches_Item

func (e ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(e) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(e)))
	}
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	Description   string  `json:"description" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
	Link          string  `json:"link" validate:"required,min=1"`
}

func (e ExtractRecipeFromWebsite_Response_WinePairing_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions []AnalyzeRecipeInstructions_Response_ParsedInstructions_Item

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps []AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Item

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients []AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item struct {
	ID            float32 `json:"id" validate:"required"`
	Name          string  `json:"name" validate:"required,min=1"`
	LocalizedName string  `json:"localizedName" validate:"required,min=1"`
	Image         string  `json:"image" validate:"required,min=1"`
}

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment []AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item struct {
	ID            float32 `json:"id" validate:"required"`
	Name          string  `json:"name" validate:"required,min=1"`
	LocalizedName string  `json:"localizedName" validate:"required,min=1"`
	Image         string  `json:"image" validate:"required,min=1"`
}

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Item struct {
	Number      float32                                                                  `json:"number" validate:"required"`
	Step        string                                                                   `json:"step" validate:"required,min=1"`
	Ingredients *AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Ingredients `json:"ingredients,omitempty"`
	Equipment   *AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Equipment   `json:"equipment,omitempty"`
}

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if err := typesValidator.Var(a.Step, "required,min=1"); err != nil {
		errors = errors.Append("Step", err)
	}
	if a.Ingredients != nil {
		if v, ok := any(a.Ingredients).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Ingredients", err)
			}
		}
	}
	if a.Equipment != nil {
		if v, ok := any(a.Equipment).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Equipment", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_ParsedInstructions_Item struct {
	Name  string                                                       `json:"name" validate:"required"`
	Steps *AnalyzeRecipeInstructions_Response_ParsedInstructions_Steps `json:"steps,omitempty"`
}

func (a AnalyzeRecipeInstructions_Response_ParsedInstructions_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if a.Steps != nil {
		if v, ok := any(a.Steps).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Steps", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_Ingredients []AnalyzeRecipeInstructions_Response_Ingredients_Item

func (a AnalyzeRecipeInstructions_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_Ingredients_Item struct {
	ID   float32 `json:"id" validate:"required"`
	Name string  `json:"name" validate:"required,min=1"`
}

func (a AnalyzeRecipeInstructions_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeRecipeInstructions_Response_Equipment []AnalyzeRecipeInstructions_Response_Equipment_Item

func (a AnalyzeRecipeInstructions_Response_Equipment) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeRecipeInstructions_Response_Equipment_Item struct {
	ID   float32 `json:"id" validate:"required"`
	Name string  `json:"name" validate:"required,min=1"`
}

func (a AnalyzeRecipeInstructions_Response_Equipment_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeARecipeSearchQuery_Response_Dishes []AnalyzeARecipeSearchQuery_Response_Dishes_Item

func (a AnalyzeARecipeSearchQuery_Response_Dishes) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeARecipeSearchQuery_Response_Dishes_Item struct {
	Image string `json:"image" validate:"required,min=1"`
	Name  string `json:"name" validate:"required,min=1"`
}

func (a AnalyzeARecipeSearchQuery_Response_Dishes_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AnalyzeARecipeSearchQuery_Response_Ingredients []AnalyzeARecipeSearchQuery_Response_Ingredients_Item

func (a AnalyzeARecipeSearchQuery_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AnalyzeARecipeSearchQuery_Response_Ingredients_Item struct {
	Image   string `json:"image" validate:"required,min=1"`
	Include bool   `json:"include"`
	Name    string `json:"name" validate:"required,min=1"`
}

func (a AnalyzeARecipeSearchQuery_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type ParseIngredients_Response []ParseIngredients_Response_Item

func (p ParseIngredients_Response) Validate() error {
	if p == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(p) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(p)))
	}
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_EstimatedCost struct {
	Value float32 `json:"value" validate:"required"`
	Unit  string  `json:"unit" validate:"required,min=1"`
}

func (p ParseIngredients_Response_EstimatedCost) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition struct {
	Nutrients        ParseIngredients_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	Properties       ParseIngredients_Response_Nutrition_Properties       `json:"properties" validate:"required"`
	Flavonoids       ParseIngredients_Response_Nutrition_Flavonoids       `json:"flavonoids" validate:"required"`
	CaloricBreakdown ParseIngredients_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
	WeightPerServing ParseIngredients_Response_Nutrition_WeightPerServing `json:"weightPerServing"`
}

func (p ParseIngredients_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(p.Properties).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Properties", err)
		}
	}
	if v, ok := any(p.Flavonoids).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Flavonoids", err)
		}
	}
	if v, ok := any(p.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if v, ok := any(p.WeightPerServing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WeightPerServing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_Nutrition_Nutrients []ParseIngredients_Response_Nutrition_Nutrients_Item

func (p ParseIngredients_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(p) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(p)))
	}
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (p ParseIngredients_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition_Properties []ParseIngredients_Response_Nutrition_Properties_Item

func (p ParseIngredients_Response_Nutrition_Properties) Validate() error {
	var errors runtime.ValidationErrors
	if len(p) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(p)))
	}
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_Nutrition_Properties_Item struct {
	Name   string  `json:"name" validate:"required,min=1"`
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required"`
}

func (p ParseIngredients_Response_Nutrition_Properties_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition_Flavonoids []ParseIngredients_Response_Nutrition_Flavonoids_Item

func (p ParseIngredients_Response_Nutrition_Flavonoids) Validate() error {
	var errors runtime.ValidationErrors
	if len(p) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(p)))
	}
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ParseIngredients_Response_Nutrition_Flavonoids_Item struct {
	Name   string  `json:"name" validate:"required,min=1"`
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required"`
}

func (p ParseIngredients_Response_Nutrition_Flavonoids_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (p ParseIngredients_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Nutrition_WeightPerServing struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (p ParseIngredients_Response_Nutrition_WeightPerServing) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type ParseIngredients_Response_Item struct {
	ID            int64                                   `json:"id" validate:"required"`
	Original      string                                  `json:"original" validate:"required,min=1"`
	OriginalName  string                                  `json:"originalName" validate:"required,min=1"`
	Name          string                                  `json:"name" validate:"required,min=1"`
	NameClean     string                                  `json:"nameClean" validate:"required,min=1"`
	Amount        float32                                 `json:"amount" validate:"required"`
	Unit          string                                  `json:"unit" validate:"required,min=1"`
	UnitShort     string                                  `json:"unitShort" validate:"required,min=1"`
	UnitLong      string                                  `json:"unitLong" validate:"required,min=1"`
	PossibleUnits []string                                `json:"possibleUnits" validate:"required"`
	EstimatedCost ParseIngredients_Response_EstimatedCost `json:"estimatedCost"`
	Consistency   string                                  `json:"consistency" validate:"required,min=1"`
	Aisle         string                                  `json:"aisle" validate:"required,min=1"`
	Image         string                                  `json:"image" validate:"required,min=1"`
	Meta          []string                                `json:"meta" validate:"required"`
	Nutrition     ParseIngredients_Response_Nutrition     `json:"nutrition"`
}

func (p ParseIngredients_Response_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(p.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(p.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(p.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(p.NameClean, "required,min=1"); err != nil {
		errors = errors.Append("NameClean", err)
	}
	if err := typesValidator.Var(p.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(p.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(p.UnitShort, "required,min=1"); err != nil {
		errors = errors.Append("UnitShort", err)
	}
	if err := typesValidator.Var(p.UnitLong, "required,min=1"); err != nil {
		errors = errors.Append("UnitLong", err)
	}
	if err := typesValidator.Var(p.PossibleUnits, "required"); err != nil {
		errors = errors.Append("PossibleUnits", err)
	}
	if v, ok := any(p.EstimatedCost).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EstimatedCost", err)
		}
	}
	if err := typesValidator.Var(p.Consistency, "required,min=1"); err != nil {
		errors = errors.Append("Consistency", err)
	}
	if err := typesValidator.Var(p.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(p.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(p.Meta, "required"); err != nil {
		errors = errors.Append("Meta", err)
	}
	if v, ok := any(p.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Calories struct {
	ConfidenceRange95Percent GuessNutritionByDishName_Response_Calories_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                             `json:"standardDeviation" validate:"required"`
	Unit                     string                                                              `json:"unit" validate:"required,min=1"`
	Value                    float32                                                             `json:"value" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Calories) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(g.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Calories_ConfidenceRange95Percent struct {
	Max float32 `json:"max" validate:"required"`
	Min float32 `json:"min" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Calories_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GuessNutritionByDishName_Response_Carbs struct {
	ConfidenceRange95Percent GuessNutritionByDishName_Response_Carbs_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                          `json:"standardDeviation" validate:"required"`
	Unit                     string                                                           `json:"unit" validate:"required,min=1"`
	Value                    float32                                                          `json:"value" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Carbs) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(g.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Carbs_ConfidenceRange95Percent struct {
	Max float32 `json:"max" validate:"required"`
	Min float32 `json:"min" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Carbs_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GuessNutritionByDishName_Response_Fat struct {
	ConfidenceRange95Percent GuessNutritionByDishName_Response_Fat_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                        `json:"standardDeviation" validate:"required"`
	Unit                     string                                                         `json:"unit" validate:"required,min=1"`
	Value                    float32                                                        `json:"value" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Fat) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(g.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Fat_ConfidenceRange95Percent struct {
	Max float32 `json:"max" validate:"required"`
	Min float32 `json:"min" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Fat_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GuessNutritionByDishName_Response_Protein struct {
	ConfidenceRange95Percent GuessNutritionByDishName_Response_Protein_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                            `json:"standardDeviation" validate:"required"`
	Unit                     string                                                             `json:"unit" validate:"required,min=1"`
	Value                    float32                                                            `json:"value" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Protein) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(g.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if err := typesValidator.Var(g.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GuessNutritionByDishName_Response_Protein_ConfidenceRange95Percent struct {
	Max float32 `json:"max" validate:"required"`
	Min float32 `json:"min" validate:"required"`
}

func (g GuessNutritionByDishName_Response_Protein_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_EstimatedCost struct {
	Value float32 `json:"value" validate:"required"`
	Unit  string  `json:"unit" validate:"required,min=1"`
}

func (g GetIngredientInformation_Response_EstimatedCost) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_Nutrition struct {
	Nutrients        GetIngredientInformation_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	Properties       GetIngredientInformation_Response_Nutrition_Properties       `json:"properties" validate:"required"`
	CaloricBreakdown GetIngredientInformation_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
	WeightPerServing GetIngredientInformation_Response_Nutrition_WeightPerServing `json:"weightPerServing"`
}

func (g GetIngredientInformation_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(g.Properties).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Properties", err)
		}
	}
	if v, ok := any(g.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if v, ok := any(g.WeightPerServing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WeightPerServing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientInformation_Response_Nutrition_Nutrients []GetIngredientInformation_Response_Nutrition_Nutrients_Item

func (g GetIngredientInformation_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientInformation_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (g GetIngredientInformation_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_Nutrition_Properties []GetIngredientInformation_Response_Nutrition_Properties_Item

func (g GetIngredientInformation_Response_Nutrition_Properties) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientInformation_Response_Nutrition_Properties_Item struct {
	Name   string  `json:"name" validate:"required,min=1"`
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required"`
}

func (g GetIngredientInformation_Response_Nutrition_Properties_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (g GetIngredientInformation_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformation_Response_Nutrition_WeightPerServing struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetIngredientInformation_Response_Nutrition_WeightPerServing) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ComputeGlycemicLoad_Response_Ingredients []ComputeGlycemicLoad_Response_Ingredients_Item

func (c ComputeGlycemicLoad_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(c) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(c)))
	}
	for i, item := range c {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ComputeGlycemicLoad_Response_Ingredients_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Original      string  `json:"original" validate:"required,min=1"`
	GlycemicIndex float32 `json:"glycemicIndex" validate:"required"`
	GlycemicLoad  float32 `json:"glycemicLoad" validate:"required"`
}

func (c ComputeGlycemicLoad_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AutocompleteIngredientSearch_Response []AutocompleteIngredientSearch_Response_Item

func (a AutocompleteIngredientSearch_Response) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteIngredientSearch_Response_Item struct {
	Name          string   `json:"name" validate:"required,min=1"`
	Image         string   `json:"image" validate:"required,min=1"`
	ID            *int64   `json:"id,omitempty"`
	Aisle         *string  `json:"aisle,omitempty" validate:"omitempty,min=1"`
	PossibleUnits []string `json:"possibleUnits,omitempty"`
}

func (a AutocompleteIngredientSearch_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type IngredientSearch_Response_Results []IngredientSearch_Response_Results_Item

func (i IngredientSearch_Response_Results) Validate() error {
	var errors runtime.ValidationErrors
	if len(i) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(i)))
	}
	for i, item := range i {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type IngredientSearch_Response_Results_Item struct {
	ID    int64  `json:"id" validate:"required"`
	Name  string `json:"name" validate:"required,min=1"`
	Image string `json:"image" validate:"required,min=1"`
}

func (i IngredientSearch_Response_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type SearchGroceryProducts_Response_Products []SearchGroceryProducts_Response_Products_Item

func (s SearchGroceryProducts_Response_Products) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProducts_Response_Products_Item struct {
	ID        int64  `json:"id" validate:"required"`
	Title     string `json:"title" validate:"required,min=1"`
	ImageType string `json:"imageType" validate:"required,min=1"`
}

func (s SearchGroceryProducts_Response_Products_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchGroceryProductsByUPC_Response_Ingredients []SearchGroceryProductsByUPC_Response_Ingredients_Item

func (s SearchGroceryProductsByUPC_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProductsByUPC_Response_Ingredients_Item struct {
	Description *struct{} `json:"description,omitempty"`
	Name        string    `json:"name" validate:"required"`
	SafetyLevel *struct{} `json:"safety_level,omitempty"`
}

func (s SearchGroceryProductsByUPC_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchGroceryProductsByUPC_Response_Nutrition struct {
	Nutrients        SearchGroceryProductsByUPC_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	CaloricBreakdown SearchGroceryProductsByUPC_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
}

func (s SearchGroceryProductsByUPC_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(s.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProductsByUPC_Response_Nutrition_Nutrients []SearchGroceryProductsByUPC_Response_Nutrition_Nutrients_Item

func (s SearchGroceryProductsByUPC_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProductsByUPC_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (s SearchGroceryProductsByUPC_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchGroceryProductsByUPC_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (s SearchGroceryProductsByUPC_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchGroceryProductsByUPC_Response_Servings struct {
	Number float32 `json:"number" validate:"required"`
	Size   float32 `json:"size" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (s SearchGroceryProductsByUPC_Response_Servings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchCustomFoods_Response_CustomFoods []SearchCustomFoods_Response_CustomFoods_Item

func (s SearchCustomFoods_Response_CustomFoods) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchCustomFoods_Response_CustomFoods_Item struct {
	ID       int64   `json:"id" validate:"required"`
	Title    string  `json:"title" validate:"required,min=1"`
	Servings float32 `json:"servings" validate:"required"`
	ImageURL string  `json:"imageUrl" validate:"required,min=1"`
	Price    float32 `json:"price" validate:"required"`
}

func (s SearchCustomFoods_Response_CustomFoods_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetProductInformation_Response_Ingredients []GetProductInformation_Response_Ingredients_Item

func (g GetProductInformation_Response_Ingredients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetProductInformation_Response_Ingredients_Item struct {
	Description *struct{} `json:"description,omitempty"`
	Name        string    `json:"name" validate:"required,min=1"`
	SafetyLevel *struct{} `json:"safety_level,omitempty"`
}

func (g GetProductInformation_Response_Ingredients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetProductInformation_Response_Nutrition struct {
	Nutrients        GetProductInformation_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	CaloricBreakdown GetProductInformation_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
}

func (g GetProductInformation_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(g.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetProductInformation_Response_Nutrition_Nutrients []GetProductInformation_Response_Nutrition_Nutrients_Item

func (g GetProductInformation_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetProductInformation_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (g GetProductInformation_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetProductInformation_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (g GetProductInformation_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetProductInformation_Response_Servings struct {
	Number float32 `json:"number" validate:"required"`
	Size   float32 `json:"size" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetProductInformation_Response_Servings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetComparableProducts_Response_ComparableProducts struct {
	Calories         []map[string]any                                                   `json:"calories" validate:"required"`
	Likes            []map[string]any                                                   `json:"likes" validate:"required"`
	Price            []map[string]any                                                   `json:"price" validate:"required"`
	Protein          GetComparableProducts_Response_ComparableProducts_Protein          `json:"protein" validate:"required"`
	SpoonacularScore GetComparableProducts_Response_ComparableProducts_SpoonacularScore `json:"spoonacularScore" validate:"required"`
	Sugar            []map[string]any                                                   `json:"sugar" validate:"required"`
}

func (g GetComparableProducts_Response_ComparableProducts) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Calories, "required"); err != nil {
		errors = errors.Append("Calories", err)
	}
	if err := typesValidator.Var(g.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if err := typesValidator.Var(g.Price, "required"); err != nil {
		errors = errors.Append("Price", err)
	}
	if v, ok := any(g.Protein).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Protein", err)
		}
	}
	if v, ok := any(g.SpoonacularScore).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SpoonacularScore", err)
		}
	}
	if err := typesValidator.Var(g.Sugar, "required"); err != nil {
		errors = errors.Append("Sugar", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetComparableProducts_Response_ComparableProducts_Protein []GetComparableProducts_Response_ComparableProducts_Protein_Item

func (g GetComparableProducts_Response_ComparableProducts_Protein) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetComparableProducts_Response_ComparableProducts_Protein_Item struct {
	Difference float32 `json:"difference" validate:"required"`
	ID         int64   `json:"id" validate:"required"`
	Image      string  `json:"image" validate:"required,min=1"`
	Title      string  `json:"title" validate:"required,min=1"`
}

func (g GetComparableProducts_Response_ComparableProducts_Protein_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetComparableProducts_Response_ComparableProducts_SpoonacularScore []GetComparableProducts_Response_ComparableProducts_SpoonacularScore_Item

func (g GetComparableProducts_Response_ComparableProducts_SpoonacularScore) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetComparableProducts_Response_ComparableProducts_SpoonacularScore_Item struct {
	Difference float32 `json:"difference" validate:"required"`
	ID         int64   `json:"id" validate:"required"`
	Image      string  `json:"image" validate:"required,min=1"`
	Title      string  `json:"title" validate:"required,min=1"`
}

func (g GetComparableProducts_Response_ComparableProducts_SpoonacularScore_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AutocompleteProductSearch_Response_Results []AutocompleteProductSearch_Response_Results_Item

func (a AutocompleteProductSearch_Response_Results) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteProductSearch_Response_Results_Item struct {
	ID    int64  `json:"id" validate:"required"`
	Title string `json:"title" validate:"required,min=1"`
}

func (a AutocompleteProductSearch_Response_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type ClassifyGroceryProductBulkBody_Item struct {
	Title   string `json:"title" validate:"required,min=1"`
	Upc     string `json:"upc" validate:"required"`
	PluCode string `json:"plu_code" validate:"required"`
}

func (c ClassifyGroceryProductBulkBody_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ClassifyGroceryProductBulk_Response []ClassifyGroceryProductBulk_Response_Item

func (c ClassifyGroceryProductBulk_Response) Validate() error {
	if c == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(c) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(c)))
	}
	for i, item := range c {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ClassifyGroceryProductBulk_Response_Item struct {
	CleanTitle  string   `json:"cleanTitle" validate:"required,min=1"`
	Image       string   `json:"image" validate:"required,min=1"`
	Category    string   `json:"category" validate:"required,min=1"`
	Breadcrumbs []string `json:"breadcrumbs" validate:"required"`
	UsdaCode    int64    `json:"usdaCode" validate:"required"`
}

func (c ClassifyGroceryProductBulk_Response_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type MapIngredientsToGroceryProducts_Response []MapIngredientsToGroceryProducts_Response_Item

func (m MapIngredientsToGroceryProducts_Response) Validate() error {
	if m == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(m) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(m)))
	}
	for i, item := range m {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MapIngredientsToGroceryProducts_Response_Products []MapIngredientsToGroceryProducts_Response_Products_Item

func (m MapIngredientsToGroceryProducts_Response_Products) Validate() error {
	var errors runtime.ValidationErrors
	if len(m) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(m)))
	}
	for i, item := range m {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MapIngredientsToGroceryProducts_Response_Products_Item struct {
	ID    int64  `json:"id" validate:"required"`
	Title string `json:"title" validate:"required,min=1"`
	Upc   string `json:"upc" validate:"required,min=1"`
}

func (m MapIngredientsToGroceryProducts_Response_Products_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(m))
}

type MapIngredientsToGroceryProducts_Response_Item struct {
	Original        string                                            `json:"original" validate:"required,min=1"`
	OriginalName    string                                            `json:"originalName" validate:"required,min=1"`
	IngredientImage string                                            `json:"ingredientImage" validate:"required,min=1"`
	Meta            []string                                          `json:"meta" validate:"required"`
	Products        MapIngredientsToGroceryProducts_Response_Products `json:"products" validate:"required"`
}

func (m MapIngredientsToGroceryProducts_Response_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(m.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(m.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(m.IngredientImage, "required,min=1"); err != nil {
		errors = errors.Append("IngredientImage", err)
	}
	if err := typesValidator.Var(m.Meta, "required"); err != nil {
		errors = errors.Append("Meta", err)
	}
	if v, ok := any(m.Products).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Products", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteMenuItemSearch_Response_Results []AutocompleteMenuItemSearch_Response_Results_Item

func (a AutocompleteMenuItemSearch_Response_Results) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteMenuItemSearch_Response_Results_Item struct {
	ID    int64  `json:"id" validate:"required"`
	Title string `json:"title" validate:"required,min=1"`
}

func (a AutocompleteMenuItemSearch_Response_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type SearchMenuItems_Response_MenuItems []SearchMenuItems_Response_MenuItems_Item

func (s SearchMenuItems_Response_MenuItems) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchMenuItems_Response_MenuItems_Servings struct {
	Number float32 `json:"number" validate:"required"`
	Size   float32 `json:"size" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (s SearchMenuItems_Response_MenuItems_Servings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchMenuItems_Response_MenuItems_Item struct {
	ID              int64                                        `json:"id" validate:"required"`
	Title           string                                       `json:"title" validate:"required,min=1"`
	RestaurantChain string                                       `json:"restaurantChain" validate:"required,min=1"`
	Image           string                                       `json:"image" validate:"required,min=1"`
	ImageType       string                                       `json:"imageType" validate:"required,min=1"`
	Servings        *SearchMenuItems_Response_MenuItems_Servings `json:"servings,omitempty"`
}

func (s SearchMenuItems_Response_MenuItems_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(s.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(s.RestaurantChain, "required,min=1"); err != nil {
		errors = errors.Append("RestaurantChain", err)
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if s.Servings != nil {
		if v, ok := any(s.Servings).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Servings", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMenuItemInformation_Response_Nutrition struct {
	Nutrients        GetMenuItemInformation_Response_Nutrition_Nutrients        `json:"nutrients" validate:"required"`
	CaloricBreakdown GetMenuItemInformation_Response_Nutrition_CaloricBreakdown `json:"caloricBreakdown"`
}

func (g GetMenuItemInformation_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if v, ok := any(g.CaloricBreakdown).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CaloricBreakdown", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMenuItemInformation_Response_Nutrition_Nutrients []GetMenuItemInformation_Response_Nutrition_Nutrients_Item

func (g GetMenuItemInformation_Response_Nutrition_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMenuItemInformation_Response_Nutrition_Nutrients_Item struct {
	Name                string  `json:"name" validate:"required,min=1"`
	Amount              float32 `json:"amount" validate:"required"`
	Unit                string  `json:"unit" validate:"required,min=1"`
	PercentOfDailyNeeds float32 `json:"percentOfDailyNeeds" validate:"required"`
}

func (g GetMenuItemInformation_Response_Nutrition_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMenuItemInformation_Response_Nutrition_CaloricBreakdown struct {
	PercentProtein float32 `json:"percentProtein" validate:"required"`
	PercentFat     float32 `json:"percentFat" validate:"required"`
	PercentCarbs   float32 `json:"percentCarbs" validate:"required"`
}

func (g GetMenuItemInformation_Response_Nutrition_CaloricBreakdown) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMenuItemInformation_Response_Servings struct {
	Number float32 `json:"number" validate:"required"`
	Size   float32 `json:"size" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetMenuItemInformation_Response_Servings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateMealPlan_Response_Meals []GenerateMealPlan_Response_Meals_Item

func (g GenerateMealPlan_Response_Meals) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateMealPlan_Response_Meals_Item struct {
	ID             int64   `json:"id" validate:"required"`
	Title          string  `json:"title" validate:"required,min=1"`
	ImageType      string  `json:"imageType" validate:"required,min=1"`
	ReadyInMinutes int64   `json:"readyInMinutes" validate:"required"`
	Servings       float32 `json:"servings" validate:"required"`
	SourceURL      string  `json:"sourceUrl" validate:"required,min=1"`
}

func (g GenerateMealPlan_Response_Meals_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateMealPlan_Response_Nutrients struct {
	Calories      float32 `json:"calories" validate:"required"`
	Carbohydrates float32 `json:"carbohydrates" validate:"required"`
	Fat           float32 `json:"fat" validate:"required"`
	Protein       float32 `json:"protein" validate:"required"`
}

func (g GenerateMealPlan_Response_Nutrients) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days []GetMealPlanWeek_Response_Days_Item

func (g GetMealPlanWeek_Response_Days) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummary struct {
	Nutrients GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummary) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients []GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients_Item

func (g GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummary_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast struct {
	Nutrients GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients []GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients_Item

func (g GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_NutritionSummaryLunch struct {
	Nutrients GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryLunch) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients []GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients_Item

func (g GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryLunch_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_NutritionSummaryDinner struct {
	Nutrients GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryDinner) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients []GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients_Item

func (g GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_NutritionSummaryDinner_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_Items []GetMealPlanWeek_Response_Days_Items_Item

func (g GetMealPlanWeek_Response_Days_Items) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_Items_Value struct {
	Servings  float32 `json:"servings" validate:"required"`
	ID        float32 `json:"id" validate:"required"`
	Title     string  `json:"title" validate:"required,min=1"`
	ImageType string  `json:"imageType" validate:"required"`
}

func (g GetMealPlanWeek_Response_Days_Items_Value) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanWeek_Response_Days_Items_Item struct {
	ID       int64                                      `json:"id" validate:"required"`
	Slot     int64                                      `json:"slot" validate:"required"`
	Position int64                                      `json:"position" validate:"required"`
	Type     string                                     `json:"type" validate:"required,min=1"`
	Value    *GetMealPlanWeek_Response_Days_Items_Value `json:"value,omitempty"`
}

func (g GetMealPlanWeek_Response_Days_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Slot, "required"); err != nil {
		errors = errors.Append("Slot", err)
	}
	if err := typesValidator.Var(g.Position, "required"); err != nil {
		errors = errors.Append("Position", err)
	}
	if err := typesValidator.Var(g.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if g.Value != nil {
		if v, ok := any(g.Value).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Value", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeek_Response_Days_Item struct {
	NutritionSummary          *GetMealPlanWeek_Response_Days_NutritionSummary          `json:"nutritionSummary,omitempty"`
	NutritionSummaryBreakfast *GetMealPlanWeek_Response_Days_NutritionSummaryBreakfast `json:"nutritionSummaryBreakfast,omitempty"`
	NutritionSummaryLunch     *GetMealPlanWeek_Response_Days_NutritionSummaryLunch     `json:"nutritionSummaryLunch,omitempty"`
	NutritionSummaryDinner    *GetMealPlanWeek_Response_Days_NutritionSummaryDinner    `json:"nutritionSummaryDinner,omitempty"`
	Date                      float32                                                  `json:"date" validate:"required"`
	Day                       string                                                   `json:"day" validate:"required,min=1"`
	Items                     *GetMealPlanWeek_Response_Days_Items                     `json:"items,omitempty"`
}

func (g GetMealPlanWeek_Response_Days_Item) Validate() error {
	var errors runtime.ValidationErrors
	if g.NutritionSummary != nil {
		if v, ok := any(g.NutritionSummary).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummary", err)
			}
		}
	}
	if g.NutritionSummaryBreakfast != nil {
		if v, ok := any(g.NutritionSummaryBreakfast).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryBreakfast", err)
			}
		}
	}
	if g.NutritionSummaryLunch != nil {
		if v, ok := any(g.NutritionSummaryLunch).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryLunch", err)
			}
		}
	}
	if g.NutritionSummaryDinner != nil {
		if v, ok := any(g.NutritionSummaryDinner).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryDinner", err)
			}
		}
	}
	if err := typesValidator.Var(g.Date, "required"); err != nil {
		errors = errors.Append("Date", err)
	}
	if err := typesValidator.Var(g.Day, "required,min=1"); err != nil {
		errors = errors.Append("Day", err)
	}
	if g.Items != nil {
		if v, ok := any(g.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplates_Response_Templates []GetMealPlanTemplates_Response_Templates_Item

func (g GetMealPlanTemplates_Response_Templates) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplates_Response_Templates_Item struct {
	ID   int64  `json:"id" validate:"required"`
	Name string `json:"name" validate:"required,min=1"`
}

func (g GetMealPlanTemplates_Response_Templates_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AddMealPlanTemplate_Response_Items []AddMealPlanTemplate_Response_Items_Item

func (a AddMealPlanTemplate_Response_Items) Validate() error {
	if a == nil {
		return runtime.NewValidationError("Array", "must have at least 1 items, got 0")
	}
	var errors runtime.ValidationErrors
	if len(a) < 1 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 1 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddMealPlanTemplate_Response_Items_Value struct {
	ID        *int64   `json:"id,omitempty"`
	Servings  *float32 `json:"servings,omitempty"`
	Title     *string  `json:"title,omitempty" validate:"omitempty,min=1"`
	ImageType *string  `json:"imageType,omitempty" validate:"omitempty,min=1"`
}

func (a AddMealPlanTemplate_Response_Items_Value) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AddMealPlanTemplate_Response_Items_Item struct {
	Day      int64                                     `json:"day" validate:"required"`
	Slot     int64                                     `json:"slot" validate:"required"`
	Position int64                                     `json:"position" validate:"required"`
	Type     string                                    `json:"type" validate:"required,min=1"`
	Value    *AddMealPlanTemplate_Response_Items_Value `json:"value,omitempty"`
}

func (a AddMealPlanTemplate_Response_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Day, "required"); err != nil {
		errors = errors.Append("Day", err)
	}
	if err := typesValidator.Var(a.Slot, "required"); err != nil {
		errors = errors.Append("Slot", err)
	}
	if err := typesValidator.Var(a.Position, "required"); err != nil {
		errors = errors.Append("Position", err)
	}
	if err := typesValidator.Var(a.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if a.Value != nil {
		if v, ok := any(a.Value).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Value", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days []GetMealPlanTemplate_Response_Days_Item

func (g GetMealPlanTemplate_Response_Days) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummary struct {
	Nutrients GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummary) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients []GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients_Item

func (g GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummary_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast struct {
	Nutrients GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients []GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients_Item

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryLunch struct {
	Nutrients GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryLunch) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients []GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients_Item

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryLunch_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryDinner struct {
	Nutrients GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients `json:"nutrients" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryDinner) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients []GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients_Item

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients_Item struct {
	Name              string  `json:"name" validate:"required,min=1"`
	Amount            float32 `json:"amount" validate:"required"`
	Unit              string  `json:"unit" validate:"required,min=1"`
	PercentDailyNeeds float32 `json:"percentDailyNeeds" validate:"required"`
}

func (g GetMealPlanTemplate_Response_Days_NutritionSummaryDinner_Nutrients_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_Items []GetMealPlanTemplate_Response_Days_Items_Item

func (g GetMealPlanTemplate_Response_Days_Items) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_Items_Value struct {
	ID        float32 `json:"id" validate:"required"`
	Title     string  `json:"title" validate:"required,min=1"`
	ImageType string  `json:"imageType" validate:"required,min=1"`
}

func (g GetMealPlanTemplate_Response_Days_Items_Value) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetMealPlanTemplate_Response_Days_Items_Item struct {
	ID       int64                                          `json:"id" validate:"required"`
	Slot     int64                                          `json:"slot" validate:"required"`
	Position int64                                          `json:"position" validate:"required"`
	Type     string                                         `json:"type" validate:"required,min=1"`
	Value    *GetMealPlanTemplate_Response_Days_Items_Value `json:"value,omitempty"`
}

func (g GetMealPlanTemplate_Response_Days_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Slot, "required"); err != nil {
		errors = errors.Append("Slot", err)
	}
	if err := typesValidator.Var(g.Position, "required"); err != nil {
		errors = errors.Append("Position", err)
	}
	if err := typesValidator.Var(g.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if g.Value != nil {
		if v, ok := any(g.Value).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Value", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplate_Response_Days_Item struct {
	NutritionSummary          *GetMealPlanTemplate_Response_Days_NutritionSummary          `json:"nutritionSummary,omitempty"`
	NutritionSummaryBreakfast *GetMealPlanTemplate_Response_Days_NutritionSummaryBreakfast `json:"nutritionSummaryBreakfast,omitempty"`
	NutritionSummaryLunch     *GetMealPlanTemplate_Response_Days_NutritionSummaryLunch     `json:"nutritionSummaryLunch,omitempty"`
	NutritionSummaryDinner    *GetMealPlanTemplate_Response_Days_NutritionSummaryDinner    `json:"nutritionSummaryDinner,omitempty"`
	Day                       string                                                       `json:"day" validate:"required,min=1"`
	Items                     *GetMealPlanTemplate_Response_Days_Items                     `json:"items,omitempty"`
}

func (g GetMealPlanTemplate_Response_Days_Item) Validate() error {
	var errors runtime.ValidationErrors
	if g.NutritionSummary != nil {
		if v, ok := any(g.NutritionSummary).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummary", err)
			}
		}
	}
	if g.NutritionSummaryBreakfast != nil {
		if v, ok := any(g.NutritionSummaryBreakfast).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryBreakfast", err)
			}
		}
	}
	if g.NutritionSummaryLunch != nil {
		if v, ok := any(g.NutritionSummaryLunch).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryLunch", err)
			}
		}
	}
	if g.NutritionSummaryDinner != nil {
		if v, ok := any(g.NutritionSummaryDinner).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NutritionSummaryDinner", err)
			}
		}
	}
	if err := typesValidator.Var(g.Day, "required,min=1"); err != nil {
		errors = errors.Append("Day", err)
	}
	if g.Items != nil {
		if v, ok := any(g.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles []GetShoppingList_Response_Aisles_Item

func (g GetShoppingList_Response_Aisles) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles_Items []GetShoppingList_Response_Aisles_Items_Item

func (g GetShoppingList_Response_Aisles_Items) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles_Items_Measures struct {
	Original GetShoppingList_Response_Aisles_Items_Measures_Original `json:"original"`
	Metric   GetShoppingList_Response_Aisles_Items_Measures_Metric   `json:"metric"`
	Us       GetShoppingList_Response_Aisles_Items_Measures_Us       `json:"us"`
}

func (g GetShoppingList_Response_Aisles_Items_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Original).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Original", err)
		}
	}
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles_Items_Measures_Original struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetShoppingList_Response_Aisles_Items_Measures_Original) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetShoppingList_Response_Aisles_Items_Measures_Metric struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetShoppingList_Response_Aisles_Items_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetShoppingList_Response_Aisles_Items_Measures_Us struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GetShoppingList_Response_Aisles_Items_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetShoppingList_Response_Aisles_Items_Item struct {
	ID           int64                                           `json:"id" validate:"required"`
	Name         string                                          `json:"name" validate:"required,min=1"`
	Measures     *GetShoppingList_Response_Aisles_Items_Measures `json:"measures,omitempty"`
	PantryItem   bool                                            `json:"pantryItem"`
	Aisle        string                                          `json:"aisle" validate:"required,min=1"`
	Cost         float32                                         `json:"cost" validate:"required"`
	IngredientID int64                                           `json:"ingredientId" validate:"required"`
}

func (g GetShoppingList_Response_Aisles_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(g.IngredientID, "required"); err != nil {
		errors = errors.Append("IngredientID", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetShoppingList_Response_Aisles_Item struct {
	Aisle string                                 `json:"aisle" validate:"required,min=1"`
	Items *GetShoppingList_Response_Aisles_Items `json:"items,omitempty"`
}

func (g GetShoppingList_Response_Aisles_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if g.Items != nil {
		if v, ok := any(g.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles []GenerateShoppingList_Response_Aisles_Item

func (g GenerateShoppingList_Response_Aisles) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles_Items []GenerateShoppingList_Response_Aisles_Items_Item

func (g GenerateShoppingList_Response_Aisles_Items) Validate() error {
	if g == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles_Items_Measures struct {
	Original GenerateShoppingList_Response_Aisles_Items_Measures_Original `json:"original"`
	Metric   GenerateShoppingList_Response_Aisles_Items_Measures_Metric   `json:"metric"`
	Us       GenerateShoppingList_Response_Aisles_Items_Measures_Us       `json:"us"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Original).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Original", err)
		}
	}
	if v, ok := any(g.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(g.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles_Items_Measures_Original struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Measures_Original) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingList_Response_Aisles_Items_Measures_Metric struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingList_Response_Aisles_Items_Measures_Us struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingList_Response_Aisles_Items_Item struct {
	ID           int64                                                `json:"id" validate:"required"`
	Name         string                                               `json:"name" validate:"required,min=1"`
	Measures     *GenerateShoppingList_Response_Aisles_Items_Measures `json:"measures,omitempty"`
	PantryItem   bool                                                 `json:"pantryItem"`
	Aisle        string                                               `json:"aisle" validate:"required,min=1"`
	Cost         float32                                              `json:"cost" validate:"required"`
	IngredientID int64                                                `json:"ingredientId" validate:"required"`
}

func (g GenerateShoppingList_Response_Aisles_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if g.Measures != nil {
		if v, ok := any(g.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(g.IngredientID, "required"); err != nil {
		errors = errors.Append("IngredientID", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingList_Response_Aisles_Item struct {
	Aisle string                                      `json:"aisle" validate:"required,min=1"`
	Items *GenerateShoppingList_Response_Aisles_Items `json:"items,omitempty"`
}

func (g GenerateShoppingList_Response_Aisles_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if g.Items != nil {
		if v, ok := any(g.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles []AddToShoppingList_Response_Aisles_Item

func (a AddToShoppingList_Response_Aisles) Validate() error {
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles_Items []AddToShoppingList_Response_Aisles_Items_Item

func (a AddToShoppingList_Response_Aisles_Items) Validate() error {
	if a == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(a) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(a)))
	}
	for i, item := range a {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles_Items_Measures struct {
	Original AddToShoppingList_Response_Aisles_Items_Measures_Original `json:"original"`
	Metric   AddToShoppingList_Response_Aisles_Items_Measures_Metric   `json:"metric"`
	Us       AddToShoppingList_Response_Aisles_Items_Measures_Us       `json:"us"`
}

func (a AddToShoppingList_Response_Aisles_Items_Measures) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Original).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Original", err)
		}
	}
	if v, ok := any(a.Metric).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Metric", err)
		}
	}
	if v, ok := any(a.Us).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Us", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles_Items_Measures_Original struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (a AddToShoppingList_Response_Aisles_Items_Measures_Original) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AddToShoppingList_Response_Aisles_Items_Measures_Metric struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (a AddToShoppingList_Response_Aisles_Items_Measures_Metric) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AddToShoppingList_Response_Aisles_Items_Measures_Us struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (a AddToShoppingList_Response_Aisles_Items_Measures_Us) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AddToShoppingList_Response_Aisles_Items_Item struct {
	ID           int64                                             `json:"id" validate:"required"`
	Name         string                                            `json:"name" validate:"required,min=1"`
	Measures     *AddToShoppingList_Response_Aisles_Items_Measures `json:"measures,omitempty"`
	PantryItem   bool                                              `json:"pantryItem"`
	Aisle        string                                            `json:"aisle" validate:"required,min=1"`
	Cost         float32                                           `json:"cost" validate:"required"`
	IngredientID int64                                             `json:"ingredientId" validate:"required"`
}

func (a AddToShoppingList_Response_Aisles_Items_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(a.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if a.Measures != nil {
		if v, ok := any(a.Measures).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measures", err)
			}
		}
	}
	if err := typesValidator.Var(a.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(a.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(a.IngredientID, "required"); err != nil {
		errors = errors.Append("IngredientID", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddToShoppingList_Response_Aisles_Item struct {
	Aisle string                                   `json:"aisle" validate:"required,min=1"`
	Items *AddToShoppingList_Response_Aisles_Items `json:"items,omitempty"`
}

func (a AddToShoppingList_Response_Aisles_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if a.Items != nil {
		if v, ok := any(a.Items).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Items", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRestaurants_Response_Restaurants []SearchRestaurants_Response_Restaurants_Item

func (s SearchRestaurants_Response_Restaurants) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRestaurants_Response_Restaurants_Address struct {
	StreetAddr  *string  `json:"street_addr,omitempty"`
	City        *string  `json:"city,omitempty"`
	State       *string  `json:"state,omitempty"`
	Zipcode     *string  `json:"zipcode,omitempty"`
	Country     *string  `json:"country,omitempty"`
	Lat         *float32 `json:"lat,omitempty"`
	Lon         *float32 `json:"lon,omitempty"`
	StreetAddr2 *string  `json:"street_addr_2,omitempty"`
	Latitude    *float32 `json:"latitude,omitempty"`
	Longitude   *float32 `json:"longitude,omitempty"`
}

type SearchRestaurants_Response_Restaurants_LocalHours struct {
	Operational *SearchRestaurants_Response_Restaurants_LocalHours_Operational `json:"operational,omitempty"`
	Delivery    *SearchRestaurants_Response_Restaurants_LocalHours_Delivery    `json:"delivery,omitempty"`
	Pickup      *SearchRestaurants_Response_Restaurants_LocalHours_Pickup      `json:"pickup,omitempty"`
	DineIn      *SearchRestaurants_Response_Restaurants_LocalHours_DineIn      `json:"dine_in,omitempty"`
}

func (s SearchRestaurants_Response_Restaurants_LocalHours) Validate() error {
	var errors runtime.ValidationErrors
	if s.Operational != nil {
		if v, ok := any(s.Operational).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Operational", err)
			}
		}
	}
	if s.Delivery != nil {
		if v, ok := any(s.Delivery).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Delivery", err)
			}
		}
	}
	if s.Pickup != nil {
		if v, ok := any(s.Pickup).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Pickup", err)
			}
		}
	}
	if s.DineIn != nil {
		if v, ok := any(s.DineIn).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DineIn", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRestaurants_Response_Restaurants_LocalHours_Operational struct {
	Monday    *string `json:"Monday,omitempty"`
	Tuesday   *string `json:"Tuesday,omitempty"`
	Wednesday *string `json:"Wednesday,omitempty"`
	Thursday  *string `json:"Thursday,omitempty"`
	Friday    *string `json:"Friday,omitempty"`
	Saturday  *string `json:"Saturday,omitempty"`
	Sunday    *string `json:"Sunday,omitempty"`
}

type SearchRestaurants_Response_Restaurants_LocalHours_Delivery struct {
	Monday    *string `json:"Monday,omitempty"`
	Tuesday   *string `json:"Tuesday,omitempty"`
	Wednesday *string `json:"Wednesday,omitempty"`
	Thursday  *string `json:"Thursday,omitempty"`
	Friday    *string `json:"Friday,omitempty"`
	Saturday  *string `json:"Saturday,omitempty"`
	Sunday    *string `json:"Sunday,omitempty"`
}

type SearchRestaurants_Response_Restaurants_LocalHours_Pickup struct {
	Monday    *string `json:"Monday,omitempty"`
	Tuesday   *string `json:"Tuesday,omitempty"`
	Wednesday *string `json:"Wednesday,omitempty"`
	Thursday  *string `json:"Thursday,omitempty"`
	Friday    *string `json:"Friday,omitempty"`
	Saturday  *string `json:"Saturday,omitempty"`
	Sunday    *string `json:"Sunday,omitempty"`
}

type SearchRestaurants_Response_Restaurants_LocalHours_DineIn struct {
	Monday    *string `json:"Monday,omitempty"`
	Tuesday   *string `json:"Tuesday,omitempty"`
	Wednesday *string `json:"Wednesday,omitempty"`
	Thursday  *string `json:"Thursday,omitempty"`
	Friday    *string `json:"Friday,omitempty"`
	Saturday  *string `json:"Saturday,omitempty"`
	Sunday    *string `json:"Sunday,omitempty"`
}

type SearchRestaurants_Response_Restaurants_Item struct {
	UnderscoreID             *string                                            `json:"_id,omitempty"`
	Name                     *string                                            `json:"name,omitempty"`
	PhoneNumber              *int64                                             `json:"phone_number,omitempty"`
	Address                  *SearchRestaurants_Response_Restaurants_Address    `json:"address,omitempty"`
	Type                     *string                                            `json:"type,omitempty"`
	Description              *string                                            `json:"description,omitempty"`
	LocalHours               *SearchRestaurants_Response_Restaurants_LocalHours `json:"local_hours,omitempty"`
	Cuisines                 []string                                           `json:"cuisines,omitempty"`
	FoodPhotos               []string                                           `json:"food_photos,omitempty"`
	LogoPhotos               []string                                           `json:"logo_photos,omitempty"`
	StorePhotos              []map[string]any                                   `json:"store_photos,omitempty"`
	DollarSigns              *int64                                             `json:"dollar_signs,omitempty"`
	PickupEnabled            *bool                                              `json:"pickup_enabled,omitempty"`
	DeliveryEnabled          *bool                                              `json:"delivery_enabled,omitempty"`
	IsOpen                   *bool                                              `json:"is_open,omitempty"`
	OffersFirstPartyDelivery *bool                                              `json:"offers_first_party_delivery,omitempty"`
	OffersThirdPartyDelivery *bool                                              `json:"offers_third_party_delivery,omitempty"`
	Miles                    *float32                                           `json:"miles,omitempty"`
	WeightedRatingValue      *float32                                           `json:"weighted_rating_value,omitempty"`
	AggregatedRatingCount    *int64                                             `json:"aggregated_rating_count,omitempty"`
}

func (s SearchRestaurants_Response_Restaurants_Item) Validate() error {
	var errors runtime.ValidationErrors
	if s.Address != nil {
		if v, ok := any(s.Address).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Address", err)
			}
		}
	}
	if s.LocalHours != nil {
		if v, ok := any(s.LocalHours).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LocalHours", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetWinePairing_Response_ProductMatches []GetWinePairing_Response_ProductMatches_Item

func (g GetWinePairing_Response_ProductMatches) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetWinePairing_Response_ProductMatches_Item struct {
	ID            int64     `json:"id" validate:"required"`
	Title         string    `json:"title" validate:"required,min=1"`
	AverageRating float32   `json:"averageRating" validate:"required"`
	Description   *struct{} `json:"description,omitempty"`
	ImageURL      string    `json:"imageUrl" validate:"required,min=1"`
	Link          string    `json:"link" validate:"required,min=1"`
	Price         string    `json:"price" validate:"required,min=1"`
	RatingCount   int64     `json:"ratingCount" validate:"required"`
	Score         float32   `json:"score" validate:"required"`
}

func (g GetWinePairing_Response_ProductMatches_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWineRecommendation_Response_RecommendedWines []GetWineRecommendation_Response_RecommendedWines_Item

func (g GetWineRecommendation_Response_RecommendedWines) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetWineRecommendation_Response_RecommendedWines_Item struct {
	ID            int64   `json:"id" validate:"required"`
	Title         string  `json:"title" validate:"required,min=1"`
	AverageRating float32 `json:"averageRating" validate:"required"`
	Description   string  `json:"description" validate:"required,min=1"`
	ImageURL      string  `json:"imageUrl" validate:"required,min=1"`
	Link          string  `json:"link" validate:"required,min=1"`
	Price         string  `json:"price" validate:"required,min=1"`
	RatingCount   int64   `json:"ratingCount" validate:"required"`
	Score         float32 `json:"score" validate:"required"`
}

func (g GetWineRecommendation_Response_RecommendedWines_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ImageAnalysisByURL_Response_Nutrition struct {
	RecipesUsed int64                                          `json:"recipesUsed" validate:"required"`
	Calories    ImageAnalysisByURL_Response_Nutrition_Calories `json:"calories"`
	Fat         ImageAnalysisByURL_Response_Nutrition_Fat      `json:"fat"`
	Protein     ImageAnalysisByURL_Response_Nutrition_Protein  `json:"protein"`
	Carbs       ImageAnalysisByURL_Response_Nutrition_Carbs    `json:"carbs"`
}

func (i ImageAnalysisByURL_Response_Nutrition) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.RecipesUsed, "required"); err != nil {
		errors = errors.Append("RecipesUsed", err)
	}
	if v, ok := any(i.Calories).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Calories", err)
		}
	}
	if v, ok := any(i.Fat).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Fat", err)
		}
	}
	if v, ok := any(i.Protein).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Protein", err)
		}
	}
	if v, ok := any(i.Carbs).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Carbs", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Calories struct {
	Value                    float32                                                                 `json:"value" validate:"required"`
	Unit                     string                                                                  `json:"unit" validate:"required,min=1"`
	ConfidenceRange95Percent ImageAnalysisByURL_Response_Nutrition_Calories_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                                 `json:"standardDeviation" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Calories) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(i.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if v, ok := any(i.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(i.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Calories_ConfidenceRange95Percent struct {
	Min float32 `json:"min" validate:"required"`
	Max float32 `json:"max" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Calories_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Nutrition_Fat struct {
	Value                    float32                                                            `json:"value" validate:"required"`
	Unit                     string                                                             `json:"unit" validate:"required,min=1"`
	ConfidenceRange95Percent ImageAnalysisByURL_Response_Nutrition_Fat_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                            `json:"standardDeviation" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Fat) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(i.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if v, ok := any(i.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(i.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Fat_ConfidenceRange95Percent struct {
	Min float32 `json:"min" validate:"required"`
	Max float32 `json:"max" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Fat_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Nutrition_Protein struct {
	Value                    float32                                                                `json:"value" validate:"required"`
	Unit                     string                                                                 `json:"unit" validate:"required,min=1"`
	ConfidenceRange95Percent ImageAnalysisByURL_Response_Nutrition_Protein_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                                `json:"standardDeviation" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Protein) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(i.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if v, ok := any(i.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(i.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Protein_ConfidenceRange95Percent struct {
	Min float32 `json:"min" validate:"required"`
	Max float32 `json:"max" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Protein_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Nutrition_Carbs struct {
	Value                    float32                                                              `json:"value" validate:"required"`
	Unit                     string                                                               `json:"unit" validate:"required,min=1"`
	ConfidenceRange95Percent ImageAnalysisByURL_Response_Nutrition_Carbs_ConfidenceRange95Percent `json:"confidenceRange95Percent"`
	StandardDeviation        float32                                                              `json:"standardDeviation" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Carbs) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(i.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(i.Unit, "required,min=1"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if v, ok := any(i.ConfidenceRange95Percent).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfidenceRange95Percent", err)
		}
	}
	if err := typesValidator.Var(i.StandardDeviation, "required"); err != nil {
		errors = errors.Append("StandardDeviation", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Nutrition_Carbs_ConfidenceRange95Percent struct {
	Min float32 `json:"min" validate:"required"`
	Max float32 `json:"max" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Nutrition_Carbs_ConfidenceRange95Percent) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Category struct {
	Name        string  `json:"name" validate:"required,min=1"`
	Probability float32 `json:"probability" validate:"required"`
}

func (i ImageAnalysisByURL_Response_Category) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURL_Response_Recipes []ImageAnalysisByURL_Response_Recipes_Item

func (i ImageAnalysisByURL_Response_Recipes) Validate() error {
	var errors runtime.ValidationErrors
	if len(i) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(i)))
	}
	for i, item := range i {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageAnalysisByURL_Response_Recipes_Item struct {
	ID        int64  `json:"id" validate:"required"`
	Title     string `json:"title" validate:"required,min=1"`
	ImageType string `json:"imageType" validate:"required,min=1"`
	URL       string `json:"url" validate:"required,min=1"`
}

func (i ImageAnalysisByURL_Response_Recipes_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type DetectFoodInText_Response_Annotations []DetectFoodInText_Response_Annotations_Item

func (d DetectFoodInText_Response_Annotations) Validate() error {
	var errors runtime.ValidationErrors
	if len(d) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(d)))
	}
	for i, item := range d {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DetectFoodInText_Response_Annotations_Item struct {
	Annotation string `json:"annotation" validate:"required,min=1"`
	Image      string `json:"image" validate:"required,min=1"`
	Tag        string `json:"tag" validate:"required,min=1"`
}

func (d DetectFoodInText_Response_Annotations_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type SearchSiteContent_Response_Articles []SearchSiteContent_Response_Articles_Item

func (s SearchSiteContent_Response_Articles) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_Articles_Item struct {
	DataPoints []struct{} `json:"dataPoints,omitempty"`
	Image      string     `json:"image" validate:"required,min=1"`
	Link       string     `json:"link" validate:"required,min=1"`
	Name       string     `json:"name" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_Articles_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchSiteContent_Response_GroceryProducts []SearchSiteContent_Response_GroceryProducts_Item

func (s SearchSiteContent_Response_GroceryProducts) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_GroceryProducts_DataPoints []SearchSiteContent_Response_GroceryProducts_DataPoints_Item

func (s SearchSiteContent_Response_GroceryProducts_DataPoints) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_GroceryProducts_DataPoints_Item struct {
	Key   string `json:"key" validate:"required,min=1"`
	Value string `json:"value" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_GroceryProducts_DataPoints_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchSiteContent_Response_GroceryProducts_Item struct {
	DataPoints *SearchSiteContent_Response_GroceryProducts_DataPoints `json:"dataPoints,omitempty"`
	Image      string                                                 `json:"image" validate:"required,min=1"`
	Link       string                                                 `json:"link" validate:"required,min=1"`
	Name       string                                                 `json:"name" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_GroceryProducts_Item) Validate() error {
	var errors runtime.ValidationErrors
	if s.DataPoints != nil {
		if v, ok := any(s.DataPoints).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataPoints", err)
			}
		}
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.Link, "required,min=1"); err != nil {
		errors = errors.Append("Link", err)
	}
	if err := typesValidator.Var(s.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_MenuItems []SearchSiteContent_Response_MenuItems_Item

func (s SearchSiteContent_Response_MenuItems) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_MenuItems_DataPoints []SearchSiteContent_Response_MenuItems_DataPoints_Item

func (s SearchSiteContent_Response_MenuItems_DataPoints) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_MenuItems_DataPoints_Item struct {
	Key   string `json:"key" validate:"required,min=1"`
	Value string `json:"value" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_MenuItems_DataPoints_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchSiteContent_Response_MenuItems_Item struct {
	DataPoints *SearchSiteContent_Response_MenuItems_DataPoints `json:"dataPoints,omitempty"`
	Image      string                                           `json:"image" validate:"required,min=1"`
	Link       string                                           `json:"link" validate:"required,min=1"`
	Name       string                                           `json:"name" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_MenuItems_Item) Validate() error {
	var errors runtime.ValidationErrors
	if s.DataPoints != nil {
		if v, ok := any(s.DataPoints).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataPoints", err)
			}
		}
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.Link, "required,min=1"); err != nil {
		errors = errors.Append("Link", err)
	}
	if err := typesValidator.Var(s.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_Recipes []SearchSiteContent_Response_Recipes_Item

func (s SearchSiteContent_Response_Recipes) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_Recipes_DataPoints []SearchSiteContent_Response_Recipes_DataPoints_Item

func (s SearchSiteContent_Response_Recipes_DataPoints) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContent_Response_Recipes_DataPoints_Item struct {
	Key   string `json:"key" validate:"required,min=1"`
	Value string `json:"value" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_Recipes_DataPoints_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchSiteContent_Response_Recipes_Item struct {
	DataPoints *SearchSiteContent_Response_Recipes_DataPoints `json:"dataPoints,omitempty"`
	Image      string                                         `json:"image" validate:"required,min=1"`
	Link       string                                         `json:"link" validate:"required,min=1"`
	Name       string                                         `json:"name" validate:"required,min=1"`
}

func (s SearchSiteContent_Response_Recipes_Item) Validate() error {
	var errors runtime.ValidationErrors
	if s.DataPoints != nil {
		if v, ok := any(s.DataPoints).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataPoints", err)
			}
		}
	}
	if err := typesValidator.Var(s.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(s.Link, "required,min=1"); err != nil {
		errors = errors.Append("Link", err)
	}
	if err := typesValidator.Var(s.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchAllFood_Response_SearchResults []SearchAllFood_Response_SearchResults_Item

func (s SearchAllFood_Response_SearchResults) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchAllFood_Response_SearchResults_Results []SearchAllFood_Response_SearchResults_Results_Item

func (s SearchAllFood_Response_SearchResults_Results) Validate() error {
	if s == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchAllFood_Response_SearchResults_Results_Item struct {
	ID        string  `json:"id" validate:"required"`
	Name      string  `json:"name" validate:"required,min=1"`
	Image     *string `json:"image,omitempty" validate:"required,min=1"`
	Link      *string `json:"link,omitempty" validate:"required,min=1"`
	Type      string  `json:"type" validate:"required,min=1"`
	Relevance float32 `json:"relevance" validate:"required"`
	Content   *string `json:"content,omitempty" validate:"required,min=0"`
}

func (s SearchAllFood_Response_SearchResults_Results_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchAllFood_Response_SearchResults_Item struct {
	Name         string                                        `json:"name" validate:"required,min=1"`
	TotalResults int64                                         `json:"totalResults" validate:"required"`
	Results      *SearchAllFood_Response_SearchResults_Results `json:"results,omitempty"`
}

func (s SearchAllFood_Response_SearchResults_Item) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(s.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if s.Results != nil {
		if v, ok := any(s.Results).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Results", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchFoodVideos_Response_Videos []SearchFoodVideos_Response_Videos_Item

func (s SearchFoodVideos_Response_Videos) Validate() error {
	var errors runtime.ValidationErrors
	if len(s) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(s)))
	}
	for i, item := range s {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchFoodVideos_Response_Videos_Item struct {
	Title      string  `json:"title" validate:"required,min=1"`
	Length     int64   `json:"length" validate:"required"`
	Rating     float32 `json:"rating" validate:"required"`
	ShortTitle string  `json:"shortTitle" validate:"required,min=1"`
	Thumbnail  string  `json:"thumbnail" validate:"required,min=1"`
	Views      int64   `json:"views" validate:"required"`
	YouTubeID  string  `json:"youTubeId" validate:"required,min=1"`
}

func (s SearchFoodVideos_Response_Videos_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetConversationSuggests_Response_Suggests struct {
	Underscore GetConversationSuggests_Response_Suggests_Underscore `json:"_" validate:"required"`
}

func (g GetConversationSuggests_Response_Suggests) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Underscore).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Underscore", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConversationSuggests_Response_Suggests_Underscore []GetConversationSuggests_Response_Suggests_Underscore_Item

func (g GetConversationSuggests_Response_Suggests_Underscore) Validate() error {
	var errors runtime.ValidationErrors
	if len(g) < 0 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 0 items, got %d", len(g)))
	}
	for i, item := range g {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConversationSuggests_Response_Suggests_Underscore_Item struct {
	Name string `json:"name" validate:"required,min=1"`
}

func (g GetConversationSuggests_Response_Suggests_Underscore_Item) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
