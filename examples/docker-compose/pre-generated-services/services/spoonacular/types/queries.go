// Code generated by oapi-codegen. DO NOT EDIT.

package types

import (
	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
)

type Ingredients = string

type Number = int64

type IgnorePantry = bool

type LimitLicense = bool

type Query = string

type Offset = int64

type IncludeNutrition = bool

type Tags = string

type IncludeTaste = bool

type DefaultCSS = bool

type Hash = string

type Rgb = string

type SearchRecipesQuery struct {
	Query                *Query        `json:"query,omitempty"`
	Cuisine              *string       `json:"cuisine,omitempty"`
	ExcludeCuisine       *string       `json:"excludeCuisine,omitempty"`
	Diet                 *string       `json:"diet,omitempty"`
	Intolerances         *string       `json:"intolerances,omitempty"`
	Equipment            *string       `json:"equipment,omitempty"`
	IncludeIngredients   *string       `json:"includeIngredients,omitempty"`
	ExcludeIngredients   *string       `json:"excludeIngredients,omitempty"`
	Type                 *string       `json:"type,omitempty"`
	InstructionsRequired *bool         `json:"instructionsRequired,omitempty"`
	FillIngredients      *bool         `json:"fillIngredients,omitempty"`
	AddRecipeInformation *bool         `json:"addRecipeInformation,omitempty"`
	AddRecipeNutrition   *bool         `json:"addRecipeNutrition,omitempty"`
	Author               *string       `json:"author,omitempty"`
	Tags                 *Tags         `json:"tags,omitempty"`
	RecipeBoxID          *float32      `json:"recipeBoxId,omitempty"`
	TitleMatch           *string       `json:"titleMatch,omitempty"`
	MaxReadyTime         *float32      `json:"maxReadyTime,omitempty"`
	IgnorePantry         *IgnorePantry `json:"ignorePantry,omitempty"`
	Sort                 *string       `json:"sort,omitempty"`
	SortDirection        *string       `json:"sortDirection,omitempty"`
	MinCarbs             *float32      `json:"minCarbs,omitempty"`
	MaxCarbs             *float32      `json:"maxCarbs,omitempty"`
	MinProtein           *float32      `json:"minProtein,omitempty"`
	MaxProtein           *float32      `json:"maxProtein,omitempty"`
	MinCalories          *float32      `json:"minCalories,omitempty"`
	MaxCalories          *float32      `json:"maxCalories,omitempty"`
	MinFat               *float32      `json:"minFat,omitempty"`
	MaxFat               *float32      `json:"maxFat,omitempty"`
	MinAlcohol           *float32      `json:"minAlcohol,omitempty"`
	MaxAlcohol           *float32      `json:"maxAlcohol,omitempty"`
	MinCaffeine          *float32      `json:"minCaffeine,omitempty"`
	MaxCaffeine          *float32      `json:"maxCaffeine,omitempty"`
	MinCopper            *float32      `json:"minCopper,omitempty"`
	MaxCopper            *float32      `json:"maxCopper,omitempty"`
	MinCalcium           *float32      `json:"minCalcium,omitempty"`
	MaxCalcium           *float32      `json:"maxCalcium,omitempty"`
	MinCholine           *float32      `json:"minCholine,omitempty"`
	MaxCholine           *float32      `json:"maxCholine,omitempty"`
	MinCholesterol       *float32      `json:"minCholesterol,omitempty"`
	MaxCholesterol       *float32      `json:"maxCholesterol,omitempty"`
	MinFluoride          *float32      `json:"minFluoride,omitempty"`
	MaxFluoride          *float32      `json:"maxFluoride,omitempty"`
	MinSaturatedFat      *float32      `json:"minSaturatedFat,omitempty"`
	MaxSaturatedFat      *float32      `json:"maxSaturatedFat,omitempty"`
	MinVitaminA          *float32      `json:"minVitaminA,omitempty"`
	MaxVitaminA          *float32      `json:"maxVitaminA,omitempty"`
	MinVitaminC          *float32      `json:"minVitaminC,omitempty"`
	MaxVitaminC          *float32      `json:"maxVitaminC,omitempty"`
	MinVitaminD          *float32      `json:"minVitaminD,omitempty"`
	MaxVitaminD          *float32      `json:"maxVitaminD,omitempty"`
	MinVitaminE          *float32      `json:"minVitaminE,omitempty"`
	MaxVitaminE          *float32      `json:"maxVitaminE,omitempty"`
	MinVitaminK          *float32      `json:"minVitaminK,omitempty"`
	MaxVitaminK          *float32      `json:"maxVitaminK,omitempty"`
	MinVitaminB1         *float32      `json:"minVitaminB1,omitempty"`
	MaxVitaminB1         *float32      `json:"maxVitaminB1,omitempty"`
	MinVitaminB2         *float32      `json:"minVitaminB2,omitempty"`
	MaxVitaminB2         *float32      `json:"maxVitaminB2,omitempty"`
	MinVitaminB5         *float32      `json:"minVitaminB5,omitempty"`
	MaxVitaminB5         *float32      `json:"maxVitaminB5,omitempty"`
	MinVitaminB3         *float32      `json:"minVitaminB3,omitempty"`
	MaxVitaminB3         *float32      `json:"maxVitaminB3,omitempty"`
	MinVitaminB6         *float32      `json:"minVitaminB6,omitempty"`
	MaxVitaminB6         *float32      `json:"maxVitaminB6,omitempty"`
	MinVitaminB12        *float32      `json:"minVitaminB12,omitempty"`
	MaxVitaminB12        *float32      `json:"maxVitaminB12,omitempty"`
	MinFiber             *float32      `json:"minFiber,omitempty"`
	MaxFiber             *float32      `json:"maxFiber,omitempty"`
	MinFolate            *float32      `json:"minFolate,omitempty"`
	MaxFolate            *float32      `json:"maxFolate,omitempty"`
	MinFolicAcid         *float32      `json:"minFolicAcid,omitempty"`
	MaxFolicAcid         *float32      `json:"maxFolicAcid,omitempty"`
	MinIodine            *float32      `json:"minIodine,omitempty"`
	MaxIodine            *float32      `json:"maxIodine,omitempty"`
	MinIron              *float32      `json:"minIron,omitempty"`
	MaxIron              *float32      `json:"maxIron,omitempty"`
	MinMagnesium         *float32      `json:"minMagnesium,omitempty"`
	MaxMagnesium         *float32      `json:"maxMagnesium,omitempty"`
	MinManganese         *float32      `json:"minManganese,omitempty"`
	MaxManganese         *float32      `json:"maxManganese,omitempty"`
	MinPhosphorus        *float32      `json:"minPhosphorus,omitempty"`
	MaxPhosphorus        *float32      `json:"maxPhosphorus,omitempty"`
	MinPotassium         *float32      `json:"minPotassium,omitempty"`
	MaxPotassium         *float32      `json:"maxPotassium,omitempty"`
	MinSelenium          *float32      `json:"minSelenium,omitempty"`
	MaxSelenium          *float32      `json:"maxSelenium,omitempty"`
	MinSodium            *float32      `json:"minSodium,omitempty"`
	MaxSodium            *float32      `json:"maxSodium,omitempty"`
	MinSugar             *float32      `json:"minSugar,omitempty"`
	MaxSugar             *float32      `json:"maxSugar,omitempty"`
	MinZinc              *float32      `json:"minZinc,omitempty"`
	MaxZinc              *float32      `json:"maxZinc,omitempty"`
	Offset               *Offset       `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number               *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	LimitLicense         *LimitLicense `json:"limitLicense,omitempty"`
}

func (s SearchRecipesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByIngredientsQuery struct {
	Ingredients  *Ingredients  `json:"ingredients,omitempty"`
	Number       *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	LimitLicense *LimitLicense `json:"limitLicense,omitempty"`
	Ranking      *float32      `json:"ranking,omitempty"`
	IgnorePantry *IgnorePantry `json:"ignorePantry,omitempty"`
}

func (s SearchRecipesByIngredientsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchRecipesByNutrientsQuery struct {
	MinCarbs        *float32      `json:"minCarbs,omitempty"`
	MaxCarbs        *float32      `json:"maxCarbs,omitempty"`
	MinProtein      *float32      `json:"minProtein,omitempty"`
	MaxProtein      *float32      `json:"maxProtein,omitempty"`
	MinCalories     *float32      `json:"minCalories,omitempty"`
	MaxCalories     *float32      `json:"maxCalories,omitempty"`
	MinFat          *float32      `json:"minFat,omitempty"`
	MaxFat          *float32      `json:"maxFat,omitempty"`
	MinAlcohol      *float32      `json:"minAlcohol,omitempty"`
	MaxAlcohol      *float32      `json:"maxAlcohol,omitempty"`
	MinCaffeine     *float32      `json:"minCaffeine,omitempty"`
	MaxCaffeine     *float32      `json:"maxCaffeine,omitempty"`
	MinCopper       *float32      `json:"minCopper,omitempty"`
	MaxCopper       *float32      `json:"maxCopper,omitempty"`
	MinCalcium      *float32      `json:"minCalcium,omitempty"`
	MaxCalcium      *float32      `json:"maxCalcium,omitempty"`
	MinCholine      *float32      `json:"minCholine,omitempty"`
	MaxCholine      *float32      `json:"maxCholine,omitempty"`
	MinCholesterol  *float32      `json:"minCholesterol,omitempty"`
	MaxCholesterol  *float32      `json:"maxCholesterol,omitempty"`
	MinFluoride     *float32      `json:"minFluoride,omitempty"`
	MaxFluoride     *float32      `json:"maxFluoride,omitempty"`
	MinSaturatedFat *float32      `json:"minSaturatedFat,omitempty"`
	MaxSaturatedFat *float32      `json:"maxSaturatedFat,omitempty"`
	MinVitaminA     *float32      `json:"minVitaminA,omitempty"`
	MaxVitaminA     *float32      `json:"maxVitaminA,omitempty"`
	MinVitaminC     *float32      `json:"minVitaminC,omitempty"`
	MaxVitaminC     *float32      `json:"maxVitaminC,omitempty"`
	MinVitaminD     *float32      `json:"minVitaminD,omitempty"`
	MaxVitaminD     *float32      `json:"maxVitaminD,omitempty"`
	MinVitaminE     *float32      `json:"minVitaminE,omitempty"`
	MaxVitaminE     *float32      `json:"maxVitaminE,omitempty"`
	MinVitaminK     *float32      `json:"minVitaminK,omitempty"`
	MaxVitaminK     *float32      `json:"maxVitaminK,omitempty"`
	MinVitaminB1    *float32      `json:"minVitaminB1,omitempty"`
	MaxVitaminB1    *float32      `json:"maxVitaminB1,omitempty"`
	MinVitaminB2    *float32      `json:"minVitaminB2,omitempty"`
	MaxVitaminB2    *float32      `json:"maxVitaminB2,omitempty"`
	MinVitaminB5    *float32      `json:"minVitaminB5,omitempty"`
	MaxVitaminB5    *float32      `json:"maxVitaminB5,omitempty"`
	MinVitaminB3    *float32      `json:"minVitaminB3,omitempty"`
	MaxVitaminB3    *float32      `json:"maxVitaminB3,omitempty"`
	MinVitaminB6    *float32      `json:"minVitaminB6,omitempty"`
	MaxVitaminB6    *float32      `json:"maxVitaminB6,omitempty"`
	MinVitaminB12   *float32      `json:"minVitaminB12,omitempty"`
	MaxVitaminB12   *float32      `json:"maxVitaminB12,omitempty"`
	MinFiber        *float32      `json:"minFiber,omitempty"`
	MaxFiber        *float32      `json:"maxFiber,omitempty"`
	MinFolate       *float32      `json:"minFolate,omitempty"`
	MaxFolate       *float32      `json:"maxFolate,omitempty"`
	MinFolicAcid    *float32      `json:"minFolicAcid,omitempty"`
	MaxFolicAcid    *float32      `json:"maxFolicAcid,omitempty"`
	MinIodine       *float32      `json:"minIodine,omitempty"`
	MaxIodine       *float32      `json:"maxIodine,omitempty"`
	MinIron         *float32      `json:"minIron,omitempty"`
	MaxIron         *float32      `json:"maxIron,omitempty"`
	MinMagnesium    *float32      `json:"minMagnesium,omitempty"`
	MaxMagnesium    *float32      `json:"maxMagnesium,omitempty"`
	MinManganese    *float32      `json:"minManganese,omitempty"`
	MaxManganese    *float32      `json:"maxManganese,omitempty"`
	MinPhosphorus   *float32      `json:"minPhosphorus,omitempty"`
	MaxPhosphorus   *float32      `json:"maxPhosphorus,omitempty"`
	MinPotassium    *float32      `json:"minPotassium,omitempty"`
	MaxPotassium    *float32      `json:"maxPotassium,omitempty"`
	MinSelenium     *float32      `json:"minSelenium,omitempty"`
	MaxSelenium     *float32      `json:"maxSelenium,omitempty"`
	MinSodium       *float32      `json:"minSodium,omitempty"`
	MaxSodium       *float32      `json:"maxSodium,omitempty"`
	MinSugar        *float32      `json:"minSugar,omitempty"`
	MaxSugar        *float32      `json:"maxSugar,omitempty"`
	MinZinc         *float32      `json:"minZinc,omitempty"`
	MaxZinc         *float32      `json:"maxZinc,omitempty"`
	Offset          *Offset       `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number          *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	Random          *bool         `json:"random,omitempty"`
	LimitLicense    *LimitLicense `json:"limitLicense,omitempty"`
}

func (s SearchRecipesByNutrientsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetRecipeInformationQuery struct {
	IncludeNutrition *IncludeNutrition `json:"includeNutrition,omitempty"`
}

type GetRecipeInformationBulkQuery struct {
	Ids              string            `json:"ids" validate:"required"`
	IncludeNutrition *IncludeNutrition `json:"includeNutrition,omitempty"`
}

func (g GetRecipeInformationBulkQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSimilarRecipesQuery struct {
	Number       *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	LimitLicense *LimitLicense `json:"limitLicense,omitempty"`
}

func (g GetSimilarRecipesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomRecipesQuery struct {
	LimitLicense *LimitLicense `json:"limitLicense,omitempty"`
	Tags         *Tags         `json:"tags,omitempty"`
	Number       *Number       `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (g GetRandomRecipesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AutocompleteRecipeSearchQuery struct {
	Query  *Query  `json:"query,omitempty"`
	Number *Number `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (a AutocompleteRecipeSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type GetRecipeTasteByIDQuery struct {
	Normalize *GetRecipeTasteByIDQueryNormalize `json:"normalize,omitempty"`
}

func (g GetRecipeTasteByIDQuery) Validate() error {
	var errors runtime.ValidationErrors
	if g.Normalize != nil {
		if v, ok := any(g.Normalize).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Normalize", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RecipeTasteByIDImageQuery struct {
	Normalize *bool `json:"normalize,omitempty"`
	Rgb       *Rgb  `json:"rgb,omitempty"`
}

type IngredientsByIDImageQuery struct {
	Measure *IngredientsByIDImageQueryMeasure `json:"measure,omitempty"`
}

func (i IngredientsByIDImageQuery) Validate() error {
	var errors runtime.ValidationErrors
	if i.Measure != nil {
		if v, ok := any(i.Measure).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measure", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RecipeNutritionLabelWidgetQuery struct {
	DefaultCSS            *DefaultCSS `json:"defaultCss,omitempty"`
	ShowOptionalNutrients *bool       `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool       `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool       `json:"showIngredients,omitempty"`
}

type RecipeNutritionLabelImageQuery struct {
	ShowOptionalNutrients *bool `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool `json:"showIngredients,omitempty"`
}

type GetAnalyzedRecipeInstructionsQuery struct {
	StepBreakdown *bool `json:"stepBreakdown,omitempty"`
}

type ExtractRecipeFromWebsiteQuery struct {
	URL              string            `json:"url" validate:"required"`
	ForceExtraction  *bool             `json:"forceExtraction,omitempty"`
	Analyze          *bool             `json:"analyze,omitempty"`
	IncludeNutrition *IncludeNutrition `json:"includeNutrition,omitempty"`
	IncludeTaste     *IncludeTaste     `json:"includeTaste,omitempty"`
}

func (e ExtractRecipeFromWebsiteQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(e))
}

type VisualizeRecipeIngredientsByIDQuery struct {
	DefaultCSS *DefaultCSS                                 `json:"defaultCss,omitempty"`
	Measure    *VisualizeRecipeIngredientsByIDQueryMeasure `json:"measure,omitempty"`
}

func (v VisualizeRecipeIngredientsByIDQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v.Measure != nil {
		if v, ok := any(v.Measure).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Measure", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeRecipeTasteByIDQuery struct {
	Normalize *VisualizeRecipeTasteByIDQueryNormalize `json:"normalize,omitempty"`
	Rgb       *Rgb                                    `json:"rgb,omitempty"`
}

func (v VisualizeRecipeTasteByIDQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v.Normalize != nil {
		if v, ok := any(v.Normalize).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Normalize", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeRecipeEquipmentByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type VisualizeRecipePriceBreakdownByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type VisualizeRecipeTasteQuery struct {
	Language  *Language `json:"language,omitempty"`
	Normalize *bool     `json:"normalize,omitempty"`
	Rgb       *Rgb      `json:"rgb,omitempty"`
}

type VisualizeRecipeNutritionQuery struct {
	Language *Language `json:"language,omitempty"`
}

type VisualizePriceBreakdownQuery struct {
	Language *Language `json:"language,omitempty"`
}

type AnalyzeRecipeQuery struct {
	Language         *string `json:"language,omitempty"`
	IncludeNutrition *bool   `json:"includeNutrition,omitempty"`
	IncludeTaste     *bool   `json:"includeTaste,omitempty"`
}

type CreateRecipeCardGetQuery struct {
	Mask            *string `json:"mask,omitempty"`
	BackgroundImage *string `json:"backgroundImage,omitempty"`
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	FontColor       *string `json:"fontColor,omitempty"`
}

type AnalyzeARecipeSearchQueryQuery struct {
	Q string `json:"q" validate:"required"`
}

func (a AnalyzeARecipeSearchQueryQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type ConvertAmountsQuery struct {
	IngredientName string  `json:"ingredientName" validate:"required"`
	SourceAmount   float32 `json:"sourceAmount" validate:"required"`
	SourceUnit     string  `json:"sourceUnit" validate:"required"`
	TargetUnit     string  `json:"targetUnit" validate:"required"`
}

func (c ConvertAmountsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ParseIngredientsQuery struct {
	Language *Language `json:"language,omitempty"`
}

type VisualizeRecipeNutritionByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type VisualizeIngredientsQuery struct {
	Language *Language `json:"language,omitempty"`
}

type GuessNutritionByDishNameQuery struct {
	Title string `json:"title" validate:"required"`
}

func (g GuessNutritionByDishNameQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientInformationQuery struct {
	Amount *float32 `json:"amount,omitempty"`
	Unit   *string  `json:"unit,omitempty"`
}

type ComputeIngredientAmountQuery struct {
	Nutrient string  `json:"nutrient" validate:"required"`
	Target   float32 `json:"target" validate:"required"`
	Unit     *string `json:"unit,omitempty"`
}

func (c ComputeIngredientAmountQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ComputeGlycemicLoadQuery struct {
	Language *Language `json:"language,omitempty"`
}

type AutocompleteIngredientSearchQuery struct {
	Query           *Query    `json:"query,omitempty"`
	Number          *Number   `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	MetaInformation *bool     `json:"metaInformation,omitempty"`
	Intolerances    *string   `json:"intolerances,omitempty"`
	Language        *Language `json:"language,omitempty"`
}

func (a AutocompleteIngredientSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type IngredientSearchQuery struct {
	Query             *Query    `json:"query,omitempty"`
	AddChildren       *bool     `json:"addChildren,omitempty"`
	MinProteinPercent *float32  `json:"minProteinPercent,omitempty"`
	MaxProteinPercent *float32  `json:"maxProteinPercent,omitempty"`
	MinFatPercent     *float32  `json:"minFatPercent,omitempty"`
	MaxFatPercent     *float32  `json:"maxFatPercent,omitempty"`
	MinCarbsPercent   *float32  `json:"minCarbsPercent,omitempty"`
	MaxCarbsPercent   *float32  `json:"maxCarbsPercent,omitempty"`
	MetaInformation   *bool     `json:"metaInformation,omitempty"`
	Intolerances      *string   `json:"intolerances,omitempty"`
	Sort              *string   `json:"sort,omitempty"`
	SortDirection     *string   `json:"sortDirection,omitempty"`
	Offset            *Offset   `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number            *Number   `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
	Language          *Language `json:"language,omitempty"`
}

func (i IngredientSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type GetIngredientSubstitutesQuery struct {
	IngredientName string `json:"ingredientName" validate:"required"`
}

func (g GetIngredientSubstitutesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type SearchGroceryProductsQuery struct {
	Query                 *Query                                           `json:"query,omitempty"`
	MinCalories           *float32                                         `json:"minCalories,omitempty"`
	MaxCalories           *float32                                         `json:"maxCalories,omitempty"`
	MinCarbs              *float32                                         `json:"minCarbs,omitempty"`
	MaxCarbs              *float32                                         `json:"maxCarbs,omitempty"`
	MinProtein            *float32                                         `json:"minProtein,omitempty"`
	MaxProtein            *float32                                         `json:"maxProtein,omitempty"`
	MinFat                *float32                                         `json:"minFat,omitempty"`
	MaxFat                *float32                                         `json:"maxFat,omitempty"`
	AddProductInformation *SearchGroceryProductsQueryAddProductInformation `json:"addProductInformation,omitempty"`
	Offset                *Offset                                          `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number                *Number                                          `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchGroceryProductsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if s.AddProductInformation != nil {
		if v, ok := any(s.AddProductInformation).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AddProductInformation", err)
			}
		}
	}
	if s.Offset != nil {
		if err := typesValidator.Var(s.Offset, "omitempty,gte=0,lte=900"); err != nil {
			errors = errors.Append("Offset", err)
		}
	}
	if s.Number != nil {
		if err := typesValidator.Var(s.Number, "omitempty,gte=1,lte=100"); err != nil {
			errors = errors.Append("Number", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchCustomFoodsQuery struct {
	Query    *Query  `json:"query,omitempty"`
	Username string  `json:"username" validate:"required"`
	Hash     string  `json:"hash" validate:"required"`
	Offset   *Offset `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number   *Number `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchCustomFoodsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type AutocompleteProductSearchQuery struct {
	Query  string `json:"query" validate:"required"`
	Number *int64 `json:"number,omitempty" validate:"omitempty,gte=1,lte=25"`
}

func (a AutocompleteProductSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type VisualizeProductNutritionByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type ProductNutritionLabelWidgetQuery struct {
	DefaultCSS            *DefaultCSS `json:"defaultCss,omitempty"`
	ShowOptionalNutrients *bool       `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool       `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool       `json:"showIngredients,omitempty"`
}

type ProductNutritionLabelImageQuery struct {
	ShowOptionalNutrients *bool `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool `json:"showIngredients,omitempty"`
}

type ClassifyGroceryProductQuery struct {
	Locale *ClassifyGroceryProductQueryLocale `json:"locale,omitempty"`
}

func (c ClassifyGroceryProductQuery) Validate() error {
	var errors runtime.ValidationErrors
	if c.Locale != nil {
		if v, ok := any(c.Locale).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Locale", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ClassifyGroceryProductBulkQuery struct {
	Locale *string `json:"locale,omitempty"`
}

type AutocompleteMenuItemSearchQuery struct {
	Query  string   `json:"query" validate:"required"`
	Number *float32 `json:"number,omitempty" validate:"omitempty,gte=1,lte=25"`
}

func (a AutocompleteMenuItemSearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type SearchMenuItemsQuery struct {
	Query                  *Query                                      `json:"query,omitempty"`
	MinCalories            *float32                                    `json:"minCalories,omitempty"`
	MaxCalories            *float32                                    `json:"maxCalories,omitempty"`
	MinCarbs               *float32                                    `json:"minCarbs,omitempty"`
	MaxCarbs               *float32                                    `json:"maxCarbs,omitempty"`
	MinProtein             *float32                                    `json:"minProtein,omitempty"`
	MaxProtein             *float32                                    `json:"maxProtein,omitempty"`
	MinFat                 *float32                                    `json:"minFat,omitempty"`
	MaxFat                 *float32                                    `json:"maxFat,omitempty"`
	AddMenuItemInformation *SearchMenuItemsQueryAddMenuItemInformation `json:"addMenuItemInformation,omitempty"`
	Offset                 *Offset                                     `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number                 *Number                                     `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchMenuItemsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if s.AddMenuItemInformation != nil {
		if v, ok := any(s.AddMenuItemInformation).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AddMenuItemInformation", err)
			}
		}
	}
	if s.Offset != nil {
		if err := typesValidator.Var(s.Offset, "omitempty,gte=0,lte=900"); err != nil {
			errors = errors.Append("Offset", err)
		}
	}
	if s.Number != nil {
		if err := typesValidator.Var(s.Number, "omitempty,gte=1,lte=100"); err != nil {
			errors = errors.Append("Number", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeMenuItemNutritionByIDQuery struct {
	DefaultCSS *DefaultCSS `json:"defaultCss,omitempty"`
}

type MenuItemNutritionLabelWidgetQuery struct {
	DefaultCSS            *DefaultCSS `json:"defaultCss,omitempty"`
	ShowOptionalNutrients *bool       `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool       `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool       `json:"showIngredients,omitempty"`
}

type MenuItemNutritionLabelImageQuery struct {
	ShowOptionalNutrients *bool `json:"showOptionalNutrients,omitempty"`
	ShowZeroValues        *bool `json:"showZeroValues,omitempty"`
	ShowIngredients       *bool `json:"showIngredients,omitempty"`
}

type GenerateMealPlanQuery struct {
	TimeFrame      *string  `json:"timeFrame,omitempty"`
	TargetCalories *float32 `json:"targetCalories,omitempty"`
	Diet           *string  `json:"diet,omitempty"`
	Exclude        *string  `json:"exclude,omitempty"`
}

type GetMealPlanWeekQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GetMealPlanWeekQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ClearMealPlanDayQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (c ClearMealPlanDayQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AddToMealPlanQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (a AddToMealPlanQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteFromMealPlanQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (d DeleteFromMealPlanQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetMealPlanTemplatesQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GetMealPlanTemplatesQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AddMealPlanTemplateQuery struct {
	Hash string `json:"hash" validate:"required"`
}

func (a AddMealPlanTemplateQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type GetMealPlanTemplateQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GetMealPlanTemplateQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type DeleteMealPlanTemplateQuery struct {
	Hash string `json:"hash" validate:"required"`
}

func (d DeleteMealPlanTemplateQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetShoppingListQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GetShoppingListQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GenerateShoppingListQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (g GenerateShoppingListQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type AddToShoppingListQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (a AddToShoppingListQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type DeleteFromShoppingListQuery struct {
	Hash Hash `json:"hash" validate:"required"`
}

func (d DeleteFromShoppingListQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type SearchRestaurantsQuery struct {
	Query     *string  `json:"query,omitempty"`
	Lat       *float32 `json:"lat,omitempty"`
	Lng       *float32 `json:"lng,omitempty"`
	Distance  *float32 `json:"distance,omitempty"`
	Budget    *float32 `json:"budget,omitempty"`
	Cuisine   *string  `json:"cuisine,omitempty"`
	MinRating *float32 `json:"min-rating,omitempty"`
	IsOpen    *bool    `json:"is-open,omitempty"`
	Sort      *string  `json:"sort,omitempty"`
	Page      *float32 `json:"page,omitempty"`
}

type GetDishPairingForWineQuery struct {
	Wine string `json:"wine" validate:"required"`
}

func (g GetDishPairingForWineQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWinePairingQuery struct {
	Food     string   `json:"food" validate:"required"`
	MaxPrice *float32 `json:"maxPrice,omitempty"`
}

func (g GetWinePairingQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWineDescriptionQuery struct {
	Wine string `json:"wine" validate:"required"`
}

func (g GetWineDescriptionQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWineRecommendationQuery struct {
	Wine      string   `json:"wine" validate:"required"`
	MaxPrice  *float32 `json:"maxPrice,omitempty"`
	MinRating *float32 `json:"minRating,omitempty"`
	Number    *float32 `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (g GetWineRecommendationQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ImageClassificationByURLQuery struct {
	ImageURL string `json:"imageUrl" validate:"required"`
}

func (i ImageClassificationByURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURLQuery struct {
	ImageURL string `json:"imageUrl" validate:"required"`
}

func (i ImageAnalysisByURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type QuickAnswerQuery struct {
	Q string `json:"q" validate:"required"`
}

func (q QuickAnswerQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(q))
}

type SearchSiteContentQuery struct {
	Query string `json:"query" validate:"required"`
}

func (s SearchSiteContentQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchAllFoodQuery struct {
	Query  string  `json:"query" validate:"required"`
	Offset *Offset `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number *Number `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchAllFoodQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchFoodVideosQuery struct {
	Query              *Query   `json:"query,omitempty"`
	Type               *string  `json:"type,omitempty"`
	Cuisine            *string  `json:"cuisine,omitempty"`
	Diet               *string  `json:"diet,omitempty"`
	IncludeIngredients *string  `json:"includeIngredients,omitempty"`
	ExcludeIngredients *string  `json:"excludeIngredients,omitempty"`
	MinLength          *float32 `json:"minLength,omitempty"`
	MaxLength          *float32 `json:"maxLength,omitempty"`
	Offset             *Offset  `json:"offset,omitempty" validate:"omitempty,gte=0,lte=900"`
	Number             *Number  `json:"number,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchFoodVideosQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type TalkToChatbotQuery struct {
	Text      string  `json:"text" validate:"required"`
	ContextID *string `json:"contextId,omitempty"`
}

func (t TalkToChatbotQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type GetConversationSuggestsQuery struct {
	Query  string   `json:"query" validate:"required"`
	Number *float32 `json:"number,omitempty"`
}

func (g GetConversationSuggestsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}
