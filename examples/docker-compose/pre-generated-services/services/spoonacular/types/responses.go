// Code generated by oapi-codegen. DO NOT EDIT.

package types

import (
	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
)

type SearchRecipesResponse struct {
	Offset       int64                          `json:"offset" validate:"required"`
	Number       int64                          `json:"number" validate:"required"`
	Results      SearchRecipes_Response_Results `json:"results" validate:"required"`
	TotalResults int64                          `json:"totalResults" validate:"required"`
}

func (s SearchRecipesResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(s.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if v, ok := any(s.Results).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Results", err)
		}
	}
	if err := typesValidator.Var(s.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchRecipesByIngredientsResponse SearchRecipesByIngredients_Response

func (s SearchRecipesByIngredientsResponse) Validate() error {
	if val, ok := any(SearchRecipesByIngredients_Response(s)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type SearchRecipesByNutrientsResponse SearchRecipesByNutrients_Response

func (s SearchRecipesByNutrientsResponse) Validate() error {
	if val, ok := any(SearchRecipesByNutrients_Response(s)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type GetRecipeInformationResponse struct {
	ID                       int64                                             `json:"id" validate:"required"`
	Title                    string                                            `json:"title" validate:"required,min=1"`
	Image                    string                                            `json:"image" validate:"required,min=1"`
	ImageType                string                                            `json:"imageType" validate:"required,min=1"`
	Servings                 float32                                           `json:"servings" validate:"required"`
	ReadyInMinutes           int64                                             `json:"readyInMinutes" validate:"required"`
	License                  string                                            `json:"license" validate:"required,min=1"`
	SourceName               string                                            `json:"sourceName" validate:"required,min=1"`
	SourceURL                string                                            `json:"sourceUrl" validate:"required,min=1"`
	SpoonacularSourceURL     string                                            `json:"spoonacularSourceUrl" validate:"required,min=1"`
	AggregateLikes           int64                                             `json:"aggregateLikes" validate:"required"`
	HealthScore              float32                                           `json:"healthScore" validate:"required"`
	SpoonacularScore         float32                                           `json:"spoonacularScore" validate:"required"`
	PricePerServing          float32                                           `json:"pricePerServing" validate:"required"`
	AnalyzedInstructions     []map[string]any                                  `json:"analyzedInstructions" validate:"required"`
	Cheap                    bool                                              `json:"cheap"`
	CreditsText              string                                            `json:"creditsText" validate:"required,min=1"`
	Cuisines                 []string                                          `json:"cuisines" validate:"required"`
	DairyFree                bool                                              `json:"dairyFree"`
	Diets                    []string                                          `json:"diets" validate:"required"`
	Gaps                     string                                            `json:"gaps" validate:"required,min=1"`
	GlutenFree               bool                                              `json:"glutenFree"`
	Instructions             string                                            `json:"instructions" validate:"required"`
	Ketogenic                bool                                              `json:"ketogenic"`
	LowFodmap                bool                                              `json:"lowFodmap"`
	Occasions                []string                                          `json:"occasions" validate:"required"`
	Sustainable              bool                                              `json:"sustainable"`
	Vegan                    bool                                              `json:"vegan"`
	Vegetarian               bool                                              `json:"vegetarian"`
	VeryHealthy              bool                                              `json:"veryHealthy"`
	VeryPopular              bool                                              `json:"veryPopular"`
	Whole30                  bool                                              `json:"whole30"`
	WeightWatcherSmartPoints float32                                           `json:"weightWatcherSmartPoints" validate:"required"`
	DishTypes                []string                                          `json:"dishTypes" validate:"required"`
	ExtendedIngredients      GetRecipeInformation_Response_ExtendedIngredients `json:"extendedIngredients" validate:"required"`
	Summary                  string                                            `json:"summary" validate:"required,min=1"`
	WinePairing              GetRecipeInformation_Response_WinePairing         `json:"winePairing"`
}

func (g GetRecipeInformationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Servings, "required"); err != nil {
		errors = errors.Append("Servings", err)
	}
	if err := typesValidator.Var(g.ReadyInMinutes, "required"); err != nil {
		errors = errors.Append("ReadyInMinutes", err)
	}
	if err := typesValidator.Var(g.License, "required,min=1"); err != nil {
		errors = errors.Append("License", err)
	}
	if err := typesValidator.Var(g.SourceName, "required,min=1"); err != nil {
		errors = errors.Append("SourceName", err)
	}
	if err := typesValidator.Var(g.SourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SourceURL", err)
	}
	if err := typesValidator.Var(g.SpoonacularSourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SpoonacularSourceURL", err)
	}
	if err := typesValidator.Var(g.AggregateLikes, "required"); err != nil {
		errors = errors.Append("AggregateLikes", err)
	}
	if err := typesValidator.Var(g.HealthScore, "required"); err != nil {
		errors = errors.Append("HealthScore", err)
	}
	if err := typesValidator.Var(g.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if err := typesValidator.Var(g.PricePerServing, "required"); err != nil {
		errors = errors.Append("PricePerServing", err)
	}
	if err := typesValidator.Var(g.AnalyzedInstructions, "required"); err != nil {
		errors = errors.Append("AnalyzedInstructions", err)
	}
	if err := typesValidator.Var(g.CreditsText, "required,min=1"); err != nil {
		errors = errors.Append("CreditsText", err)
	}
	if err := typesValidator.Var(g.Cuisines, "required"); err != nil {
		errors = errors.Append("Cuisines", err)
	}
	if err := typesValidator.Var(g.Diets, "required"); err != nil {
		errors = errors.Append("Diets", err)
	}
	if err := typesValidator.Var(g.Gaps, "required,min=1"); err != nil {
		errors = errors.Append("Gaps", err)
	}
	if err := typesValidator.Var(g.Instructions, "required"); err != nil {
		errors = errors.Append("Instructions", err)
	}
	if err := typesValidator.Var(g.Occasions, "required"); err != nil {
		errors = errors.Append("Occasions", err)
	}
	if err := typesValidator.Var(g.WeightWatcherSmartPoints, "required"); err != nil {
		errors = errors.Append("WeightWatcherSmartPoints", err)
	}
	if err := typesValidator.Var(g.DishTypes, "required"); err != nil {
		errors = errors.Append("DishTypes", err)
	}
	if v, ok := any(g.ExtendedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ExtendedIngredients", err)
		}
	}
	if err := typesValidator.Var(g.Summary, "required,min=1"); err != nil {
		errors = errors.Append("Summary", err)
	}
	if v, ok := any(g.WinePairing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WinePairing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRecipeInformationBulkResponse GetRecipeInformationBulk_Response

func (g GetRecipeInformationBulkResponse) Validate() error {
	if val, ok := any(GetRecipeInformationBulk_Response(g)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type GetSimilarRecipesResponse GetSimilarRecipes_Response

func (g GetSimilarRecipesResponse) Validate() error {
	if val, ok := any(GetSimilarRecipes_Response(g)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type GetRandomRecipesResponse struct {
	Recipes GetRandomRecipes_Response_Recipes `json:"recipes" validate:"required"`
}

func (g GetRandomRecipesResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Recipes).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Recipes", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteRecipeSearchResponse AutocompleteRecipeSearch_Response

func (a AutocompleteRecipeSearchResponse) Validate() error {
	if val, ok := any(AutocompleteRecipeSearch_Response(a)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type GetRecipeTasteByIDResponse struct {
	Sweetness  float32 `json:"sweetness" validate:"required"`
	Saltiness  float32 `json:"saltiness" validate:"required"`
	Sourness   float32 `json:"sourness" validate:"required"`
	Bitterness float32 `json:"bitterness" validate:"required"`
	Savoriness float32 `json:"savoriness" validate:"required"`
	Fattiness  float32 `json:"fattiness" validate:"required"`
	Spiciness  float32 `json:"spiciness" validate:"required"`
}

func (g GetRecipeTasteByIDResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type RecipeTasteByIDImageResponse = map[string]any

type GetRecipeEquipmentByIDResponse struct {
	Equipment GetRecipeEquipmentByID_Response_Equipment `json:"equipment" validate:"required"`
}

func (g GetRecipeEquipmentByIDResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Equipment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Equipment", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EquipmentByIDImageResponse = map[string]any

type GetRecipePriceBreakdownByIDResponse struct {
	Ingredients         GetRecipePriceBreakdownByID_Response_Ingredients `json:"ingredients" validate:"required"`
	TotalCost           float32                                          `json:"totalCost" validate:"required"`
	TotalCostPerServing float32                                          `json:"totalCostPerServing" validate:"required"`
}

func (g GetRecipePriceBreakdownByIDResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if err := typesValidator.Var(g.TotalCost, "required"); err != nil {
		errors = errors.Append("TotalCost", err)
	}
	if err := typesValidator.Var(g.TotalCostPerServing, "required"); err != nil {
		errors = errors.Append("TotalCostPerServing", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PriceBreakdownByIDImageResponse = map[string]any

type GetRecipeIngredientsByIDResponse struct {
	Ingredients GetRecipeIngredientsByID_Response_Ingredients `json:"ingredients" validate:"required"`
}

func (g GetRecipeIngredientsByIDResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type IngredientsByIDImageResponse = map[string]any

type GetRecipeNutritionWidgetByIDResponse struct {
	Calories string                                     `json:"calories" validate:"required,min=1"`
	Carbs    string                                     `json:"carbs" validate:"required,min=1"`
	Fat      string                                     `json:"fat" validate:"required,min=1"`
	Protein  string                                     `json:"protein" validate:"required,min=1"`
	Bad      GetRecipeNutritionWidgetByID_Response_Bad  `json:"bad" validate:"required"`
	Good     GetRecipeNutritionWidgetByID_Response_Good `json:"good" validate:"required"`
}

func (g GetRecipeNutritionWidgetByIDResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.Calories, "required,min=1"); err != nil {
		errors = errors.Append("Calories", err)
	}
	if err := typesValidator.Var(g.Carbs, "required,min=1"); err != nil {
		errors = errors.Append("Carbs", err)
	}
	if err := typesValidator.Var(g.Fat, "required,min=1"); err != nil {
		errors = errors.Append("Fat", err)
	}
	if err := typesValidator.Var(g.Protein, "required,min=1"); err != nil {
		errors = errors.Append("Protein", err)
	}
	if v, ok := any(g.Bad).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Bad", err)
		}
	}
	if v, ok := any(g.Good).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Good", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RecipeNutritionByIDImageResponse = map[string]any

type RecipeNutritionLabelWidgetResponse = string

type RecipeNutritionLabelImageResponse = map[string]any

type GetAnalyzedRecipeInstructionsResponse struct {
	ParsedInstructions GetAnalyzedRecipeInstructions_Response_ParsedInstructions `json:"parsedInstructions" validate:"required"`
	Ingredients        GetAnalyzedRecipeInstructions_Response_Ingredients        `json:"ingredients" validate:"required"`
	Equipment          GetAnalyzedRecipeInstructions_Response_Equipment          `json:"equipment" validate:"required"`
}

func (g GetAnalyzedRecipeInstructionsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ParsedInstructions).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ParsedInstructions", err)
		}
	}
	if v, ok := any(g.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if v, ok := any(g.Equipment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Equipment", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ExtractRecipeFromWebsiteResponse struct {
	ID                       int64                                                 `json:"id" validate:"required"`
	Title                    string                                                `json:"title" validate:"required,min=1"`
	Image                    string                                                `json:"image" validate:"required,min=1"`
	ImageType                string                                                `json:"imageType" validate:"required,min=1"`
	Servings                 float32                                               `json:"servings" validate:"required"`
	ReadyInMinutes           int64                                                 `json:"readyInMinutes" validate:"required"`
	License                  string                                                `json:"license" validate:"required,min=1"`
	SourceName               string                                                `json:"sourceName" validate:"required,min=1"`
	SourceURL                string                                                `json:"sourceUrl" validate:"required,min=1"`
	SpoonacularSourceURL     string                                                `json:"spoonacularSourceUrl" validate:"required,min=1"`
	AggregateLikes           int64                                                 `json:"aggregateLikes" validate:"required"`
	HealthScore              float32                                               `json:"healthScore" validate:"required"`
	SpoonacularScore         float32                                               `json:"spoonacularScore" validate:"required"`
	PricePerServing          float32                                               `json:"pricePerServing" validate:"required"`
	AnalyzedInstructions     []map[string]any                                      `json:"analyzedInstructions" validate:"required"`
	Cheap                    bool                                                  `json:"cheap"`
	CreditsText              string                                                `json:"creditsText" validate:"required,min=1"`
	Cuisines                 []string                                              `json:"cuisines" validate:"required"`
	DairyFree                bool                                                  `json:"dairyFree"`
	Diets                    []string                                              `json:"diets" validate:"required"`
	Gaps                     string                                                `json:"gaps" validate:"required,min=1"`
	GlutenFree               bool                                                  `json:"glutenFree"`
	Instructions             string                                                `json:"instructions" validate:"required"`
	Ketogenic                bool                                                  `json:"ketogenic"`
	LowFodmap                bool                                                  `json:"lowFodmap"`
	Occasions                []string                                              `json:"occasions" validate:"required"`
	Sustainable              bool                                                  `json:"sustainable"`
	Vegan                    bool                                                  `json:"vegan"`
	Vegetarian               bool                                                  `json:"vegetarian"`
	VeryHealthy              bool                                                  `json:"veryHealthy"`
	VeryPopular              bool                                                  `json:"veryPopular"`
	Whole30                  bool                                                  `json:"whole30"`
	WeightWatcherSmartPoints float32                                               `json:"weightWatcherSmartPoints" validate:"required"`
	DishTypes                []string                                              `json:"dishTypes" validate:"required"`
	ExtendedIngredients      ExtractRecipeFromWebsite_Response_ExtendedIngredients `json:"extendedIngredients" validate:"required"`
	Summary                  string                                                `json:"summary" validate:"required,min=1"`
	WinePairing              ExtractRecipeFromWebsite_Response_WinePairing         `json:"winePairing"`
}

func (e ExtractRecipeFromWebsiteResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(e.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(e.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(e.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(e.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(e.Servings, "required"); err != nil {
		errors = errors.Append("Servings", err)
	}
	if err := typesValidator.Var(e.ReadyInMinutes, "required"); err != nil {
		errors = errors.Append("ReadyInMinutes", err)
	}
	if err := typesValidator.Var(e.License, "required,min=1"); err != nil {
		errors = errors.Append("License", err)
	}
	if err := typesValidator.Var(e.SourceName, "required,min=1"); err != nil {
		errors = errors.Append("SourceName", err)
	}
	if err := typesValidator.Var(e.SourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SourceURL", err)
	}
	if err := typesValidator.Var(e.SpoonacularSourceURL, "required,min=1"); err != nil {
		errors = errors.Append("SpoonacularSourceURL", err)
	}
	if err := typesValidator.Var(e.AggregateLikes, "required"); err != nil {
		errors = errors.Append("AggregateLikes", err)
	}
	if err := typesValidator.Var(e.HealthScore, "required"); err != nil {
		errors = errors.Append("HealthScore", err)
	}
	if err := typesValidator.Var(e.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if err := typesValidator.Var(e.PricePerServing, "required"); err != nil {
		errors = errors.Append("PricePerServing", err)
	}
	if err := typesValidator.Var(e.AnalyzedInstructions, "required"); err != nil {
		errors = errors.Append("AnalyzedInstructions", err)
	}
	if err := typesValidator.Var(e.CreditsText, "required,min=1"); err != nil {
		errors = errors.Append("CreditsText", err)
	}
	if err := typesValidator.Var(e.Cuisines, "required"); err != nil {
		errors = errors.Append("Cuisines", err)
	}
	if err := typesValidator.Var(e.Diets, "required"); err != nil {
		errors = errors.Append("Diets", err)
	}
	if err := typesValidator.Var(e.Gaps, "required,min=1"); err != nil {
		errors = errors.Append("Gaps", err)
	}
	if err := typesValidator.Var(e.Instructions, "required"); err != nil {
		errors = errors.Append("Instructions", err)
	}
	if err := typesValidator.Var(e.Occasions, "required"); err != nil {
		errors = errors.Append("Occasions", err)
	}
	if err := typesValidator.Var(e.WeightWatcherSmartPoints, "required"); err != nil {
		errors = errors.Append("WeightWatcherSmartPoints", err)
	}
	if err := typesValidator.Var(e.DishTypes, "required"); err != nil {
		errors = errors.Append("DishTypes", err)
	}
	if v, ok := any(e.ExtendedIngredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ExtendedIngredients", err)
		}
	}
	if err := typesValidator.Var(e.Summary, "required,min=1"); err != nil {
		errors = errors.Append("Summary", err)
	}
	if v, ok := any(e.WinePairing).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("WinePairing", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeRecipeIngredientsByIDResponse = string

type VisualizeRecipeTasteByIDResponse = string

type VisualizeRecipeEquipmentByIDResponse = string

type VisualizeRecipePriceBreakdownByIDResponse = string

type VisualizeRecipeTasteResponse = string

type VisualizeRecipeNutritionResponse = string

type VisualizePriceBreakdownResponse = string

type VisualizeEquipmentResponse = string

type AnalyzeRecipeResponse = map[string]any

type SummarizeRecipeResponse struct {
	ID      int64  `json:"id" validate:"required"`
	Summary string `json:"summary" validate:"required,min=1"`
	Title   string `json:"title" validate:"required,min=1"`
}

func (s SummarizeRecipeResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type CreateRecipeCardGetResponse = map[string]any

type CreateRecipeCardResponse struct {
	URL string `json:"url" validate:"required,min=1"`
}

func (c CreateRecipeCardResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AnalyzeRecipeInstructionsResponse struct {
	ParsedInstructions AnalyzeRecipeInstructions_Response_ParsedInstructions `json:"parsedInstructions" validate:"required"`
	Ingredients        AnalyzeRecipeInstructions_Response_Ingredients        `json:"ingredients" validate:"required"`
	Equipment          AnalyzeRecipeInstructions_Response_Equipment          `json:"equipment" validate:"required"`
}

func (a AnalyzeRecipeInstructionsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ParsedInstructions).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ParsedInstructions", err)
		}
	}
	if v, ok := any(a.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if v, ok := any(a.Equipment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Equipment", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ClassifyCuisineResponse struct {
	Cuisine    string   `json:"cuisine" validate:"required,min=1"`
	Cuisines   []string `json:"cuisines" validate:"required"`
	Confidence float32  `json:"confidence" validate:"required"`
}

func (c ClassifyCuisineResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AnalyzeARecipeSearchQueryResponse struct {
	Dishes      AnalyzeARecipeSearchQuery_Response_Dishes      `json:"dishes" validate:"required"`
	Ingredients AnalyzeARecipeSearchQuery_Response_Ingredients `json:"ingredients" validate:"required"`
	Cuisines    []string                                       `json:"cuisines" validate:"required"`
	Modifiers   []string                                       `json:"modifiers" validate:"required"`
}

func (a AnalyzeARecipeSearchQueryResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Dishes).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Dishes", err)
		}
	}
	if v, ok := any(a.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if err := typesValidator.Var(a.Cuisines, "required"); err != nil {
		errors = errors.Append("Cuisines", err)
	}
	if err := typesValidator.Var(a.Modifiers, "required"); err != nil {
		errors = errors.Append("Modifiers", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ConvertAmountsResponse struct {
	SourceAmount float32 `json:"sourceAmount" validate:"required"`
	SourceUnit   string  `json:"sourceUnit" validate:"required,min=1"`
	TargetAmount float32 `json:"targetAmount" validate:"required"`
	TargetUnit   string  `json:"targetUnit" validate:"required,min=1"`
	Answer       string  `json:"answer" validate:"required,min=1"`
}

func (c ConvertAmountsResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ParseIngredientsResponse ParseIngredients_Response

func (p ParseIngredientsResponse) Validate() error {
	if val, ok := any(ParseIngredients_Response(p)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type VisualizeRecipeNutritionByIDResponse = string

type VisualizeIngredientsResponse = string

type GuessNutritionByDishNameResponse struct {
	Calories    GuessNutritionByDishName_Response_Calories `json:"calories"`
	Carbs       GuessNutritionByDishName_Response_Carbs    `json:"carbs"`
	Fat         GuessNutritionByDishName_Response_Fat      `json:"fat"`
	Protein     GuessNutritionByDishName_Response_Protein  `json:"protein"`
	RecipesUsed int64                                      `json:"recipesUsed" validate:"required"`
}

func (g GuessNutritionByDishNameResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Calories).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Calories", err)
		}
	}
	if v, ok := any(g.Carbs).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Carbs", err)
		}
	}
	if v, ok := any(g.Fat).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Fat", err)
		}
	}
	if v, ok := any(g.Protein).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Protein", err)
		}
	}
	if err := typesValidator.Var(g.RecipesUsed, "required"); err != nil {
		errors = errors.Append("RecipesUsed", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientInformationResponse struct {
	ID                int64                                           `json:"id" validate:"required"`
	Original          string                                          `json:"original" validate:"required,min=1"`
	OriginalName      string                                          `json:"originalName" validate:"required,min=1"`
	Name              string                                          `json:"name" validate:"required,min=1"`
	NameClean         string                                          `json:"nameClean" validate:"required,min=1"`
	Amount            float32                                         `json:"amount" validate:"required"`
	Unit              string                                          `json:"unit" validate:"required"`
	UnitShort         string                                          `json:"unitShort" validate:"required"`
	UnitLong          string                                          `json:"unitLong" validate:"required"`
	PossibleUnits     []string                                        `json:"possibleUnits" validate:"required"`
	EstimatedCost     GetIngredientInformation_Response_EstimatedCost `json:"estimatedCost"`
	Consistency       string                                          `json:"consistency" validate:"required,min=1"`
	ShoppingListUnits []string                                        `json:"shoppingListUnits" validate:"required"`
	Aisle             string                                          `json:"aisle" validate:"required,min=1"`
	Image             string                                          `json:"image" validate:"required,min=1"`
	Meta              []map[string]any                                `json:"meta" validate:"required"`
	Nutrition         GetIngredientInformation_Response_Nutrition     `json:"nutrition"`
	CategoryPath      []string                                        `json:"categoryPath" validate:"required"`
}

func (g GetIngredientInformationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Original, "required,min=1"); err != nil {
		errors = errors.Append("Original", err)
	}
	if err := typesValidator.Var(g.OriginalName, "required,min=1"); err != nil {
		errors = errors.Append("OriginalName", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.NameClean, "required,min=1"); err != nil {
		errors = errors.Append("NameClean", err)
	}
	if err := typesValidator.Var(g.Amount, "required"); err != nil {
		errors = errors.Append("Amount", err)
	}
	if err := typesValidator.Var(g.Unit, "required"); err != nil {
		errors = errors.Append("Unit", err)
	}
	if err := typesValidator.Var(g.UnitShort, "required"); err != nil {
		errors = errors.Append("UnitShort", err)
	}
	if err := typesValidator.Var(g.UnitLong, "required"); err != nil {
		errors = errors.Append("UnitLong", err)
	}
	if err := typesValidator.Var(g.PossibleUnits, "required"); err != nil {
		errors = errors.Append("PossibleUnits", err)
	}
	if v, ok := any(g.EstimatedCost).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EstimatedCost", err)
		}
	}
	if err := typesValidator.Var(g.Consistency, "required,min=1"); err != nil {
		errors = errors.Append("Consistency", err)
	}
	if err := typesValidator.Var(g.ShoppingListUnits, "required"); err != nil {
		errors = errors.Append("ShoppingListUnits", err)
	}
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if err := typesValidator.Var(g.Image, "required,min=1"); err != nil {
		errors = errors.Append("Image", err)
	}
	if err := typesValidator.Var(g.Meta, "required"); err != nil {
		errors = errors.Append("Meta", err)
	}
	if v, ok := any(g.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if err := typesValidator.Var(g.CategoryPath, "required"); err != nil {
		errors = errors.Append("CategoryPath", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ComputeIngredientAmountResponse struct {
	Amount float32 `json:"amount" validate:"required"`
	Unit   string  `json:"unit" validate:"required,min=1"`
}

func (c ComputeIngredientAmountResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ComputeGlycemicLoadResponse struct {
	TotalGlycemicLoad float32                                  `json:"totalGlycemicLoad" validate:"required"`
	Ingredients       ComputeGlycemicLoad_Response_Ingredients `json:"ingredients" validate:"required"`
}

func (c ComputeGlycemicLoadResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.TotalGlycemicLoad, "required"); err != nil {
		errors = errors.Append("TotalGlycemicLoad", err)
	}
	if v, ok := any(c.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteIngredientSearchResponse AutocompleteIngredientSearch_Response

func (a AutocompleteIngredientSearchResponse) Validate() error {
	if val, ok := any(AutocompleteIngredientSearch_Response(a)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type IngredientSearchResponse struct {
	Results      IngredientSearch_Response_Results `json:"results" validate:"required"`
	Offset       int64                             `json:"offset" validate:"required"`
	Number       int64                             `json:"number" validate:"required"`
	TotalResults int64                             `json:"totalResults" validate:"required"`
}

func (i IngredientSearchResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(i.Results).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Results", err)
		}
	}
	if err := typesValidator.Var(i.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(i.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if err := typesValidator.Var(i.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetIngredientSubstitutesResponse struct {
	Ingredient  string   `json:"ingredient" validate:"required,min=1"`
	Substitutes []string `json:"substitutes" validate:"required"`
	Message     string   `json:"message" validate:"required,min=1"`
}

func (g GetIngredientSubstitutesResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetIngredientSubstitutesByIDResponse struct {
	Ingredient  string   `json:"ingredient" validate:"required,min=1"`
	Substitutes []string `json:"substitutes" validate:"required"`
	Message     string   `json:"message" validate:"required,min=1"`
}

func (g GetIngredientSubstitutesByIDResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type SearchGroceryProductsResponse struct {
	Products      SearchGroceryProducts_Response_Products `json:"products" validate:"required"`
	TotalProducts int64                                   `json:"totalProducts" validate:"required"`
	Type          string                                  `json:"type" validate:"required,min=1"`
	Offset        int64                                   `json:"offset" validate:"required"`
	Number        int64                                   `json:"number" validate:"required"`
}

func (s SearchGroceryProductsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.Products).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Products", err)
		}
	}
	if err := typesValidator.Var(s.TotalProducts, "required"); err != nil {
		errors = errors.Append("TotalProducts", err)
	}
	if err := typesValidator.Var(s.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(s.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchGroceryProductsByUPCResponse struct {
	ID               int64                                           `json:"id" validate:"required"`
	Title            string                                          `json:"title" validate:"required,min=1"`
	Badges           []string                                        `json:"badges" validate:"required"`
	ImportantBadges  []string                                        `json:"importantBadges" validate:"required"`
	Breadcrumbs      []string                                        `json:"breadcrumbs" validate:"required"`
	GeneratedText    string                                          `json:"generatedText" validate:"required,min=1"`
	ImageType        string                                          `json:"imageType" validate:"required,min=1"`
	IngredientCount  *int64                                          `json:"ingredientCount,omitempty"`
	IngredientList   string                                          `json:"ingredientList" validate:"required,min=1"`
	Ingredients      SearchGroceryProductsByUPC_Response_Ingredients `json:"ingredients" validate:"required"`
	Likes            float32                                         `json:"likes" validate:"required"`
	Nutrition        SearchGroceryProductsByUPC_Response_Nutrition   `json:"nutrition"`
	Price            float32                                         `json:"price" validate:"required"`
	Servings         SearchGroceryProductsByUPC_Response_Servings    `json:"servings"`
	SpoonacularScore float32                                         `json:"spoonacularScore" validate:"required"`
}

func (s SearchGroceryProductsByUPCResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(s.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(s.Badges, "required"); err != nil {
		errors = errors.Append("Badges", err)
	}
	if err := typesValidator.Var(s.ImportantBadges, "required"); err != nil {
		errors = errors.Append("ImportantBadges", err)
	}
	if err := typesValidator.Var(s.Breadcrumbs, "required"); err != nil {
		errors = errors.Append("Breadcrumbs", err)
	}
	if err := typesValidator.Var(s.GeneratedText, "required,min=1"); err != nil {
		errors = errors.Append("GeneratedText", err)
	}
	if err := typesValidator.Var(s.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(s.IngredientList, "required,min=1"); err != nil {
		errors = errors.Append("IngredientList", err)
	}
	if v, ok := any(s.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if err := typesValidator.Var(s.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if v, ok := any(s.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if err := typesValidator.Var(s.Price, "required"); err != nil {
		errors = errors.Append("Price", err)
	}
	if v, ok := any(s.Servings).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Servings", err)
		}
	}
	if err := typesValidator.Var(s.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchCustomFoodsResponse struct {
	CustomFoods SearchCustomFoods_Response_CustomFoods `json:"customFoods" validate:"required"`
	Type        string                                 `json:"type" validate:"required,min=1"`
	Offset      int64                                  `json:"offset" validate:"required"`
	Number      int64                                  `json:"number" validate:"required"`
}

func (s SearchCustomFoodsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.CustomFoods).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("CustomFoods", err)
		}
	}
	if err := typesValidator.Var(s.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(s.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetProductInformationResponse struct {
	ID               int64                                      `json:"id" validate:"required"`
	Title            string                                     `json:"title" validate:"required,min=1"`
	Breadcrumbs      []string                                   `json:"breadcrumbs" validate:"required"`
	ImageType        string                                     `json:"imageType" validate:"required,min=1"`
	Badges           []string                                   `json:"badges" validate:"required"`
	ImportantBadges  []string                                   `json:"importantBadges" validate:"required"`
	IngredientCount  int64                                      `json:"ingredientCount" validate:"required"`
	GeneratedText    *struct{}                                  `json:"generatedText,omitempty"`
	IngredientList   string                                     `json:"ingredientList" validate:"required,min=1"`
	Ingredients      GetProductInformation_Response_Ingredients `json:"ingredients" validate:"required"`
	Likes            float32                                    `json:"likes" validate:"required"`
	Aisle            string                                     `json:"aisle" validate:"required,min=1"`
	Nutrition        GetProductInformation_Response_Nutrition   `json:"nutrition"`
	Price            float32                                    `json:"price" validate:"required"`
	Servings         GetProductInformation_Response_Servings    `json:"servings"`
	SpoonacularScore float32                                    `json:"spoonacularScore" validate:"required"`
}

func (g GetProductInformationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.Breadcrumbs, "required"); err != nil {
		errors = errors.Append("Breadcrumbs", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Badges, "required"); err != nil {
		errors = errors.Append("Badges", err)
	}
	if err := typesValidator.Var(g.ImportantBadges, "required"); err != nil {
		errors = errors.Append("ImportantBadges", err)
	}
	if err := typesValidator.Var(g.IngredientCount, "required"); err != nil {
		errors = errors.Append("IngredientCount", err)
	}
	if err := typesValidator.Var(g.IngredientList, "required,min=1"); err != nil {
		errors = errors.Append("IngredientList", err)
	}
	if v, ok := any(g.Ingredients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Ingredients", err)
		}
	}
	if err := typesValidator.Var(g.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if err := typesValidator.Var(g.Aisle, "required,min=1"); err != nil {
		errors = errors.Append("Aisle", err)
	}
	if v, ok := any(g.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if err := typesValidator.Var(g.Price, "required"); err != nil {
		errors = errors.Append("Price", err)
	}
	if v, ok := any(g.Servings).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Servings", err)
		}
	}
	if err := typesValidator.Var(g.SpoonacularScore, "required"); err != nil {
		errors = errors.Append("SpoonacularScore", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetComparableProductsResponse struct {
	ComparableProducts GetComparableProducts_Response_ComparableProducts `json:"comparableProducts"`
}

func (g GetComparableProductsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ComparableProducts).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ComparableProducts", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AutocompleteProductSearchResponse struct {
	Results AutocompleteProductSearch_Response_Results `json:"results" validate:"required"`
}

func (a AutocompleteProductSearchResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Results).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Results", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeProductNutritionByIDResponse = string

type ProductNutritionByIDImageResponse = map[string]any

type ProductNutritionLabelWidgetResponse = string

type ProductNutritionLabelImageResponse = map[string]any

type ClassifyGroceryProductResponse struct {
	CleanTitle  string   `json:"cleanTitle" validate:"required,min=1"`
	Image       string   `json:"image" validate:"required,min=1"`
	Category    string   `json:"category" validate:"required,min=1"`
	Breadcrumbs []string `json:"breadcrumbs" validate:"required"`
	UsdaCode    int64    `json:"usdaCode" validate:"required"`
}

func (c ClassifyGroceryProductResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ClassifyGroceryProductBulkResponse ClassifyGroceryProductBulk_Response

func (c ClassifyGroceryProductBulkResponse) Validate() error {
	if val, ok := any(ClassifyGroceryProductBulk_Response(c)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type MapIngredientsToGroceryProductsResponse MapIngredientsToGroceryProducts_Response

func (m MapIngredientsToGroceryProductsResponse) Validate() error {
	if val, ok := any(MapIngredientsToGroceryProducts_Response(m)).(runtime.Validator); ok {
		return val.Validate()
	}
	return nil
}

type AutocompleteMenuItemSearchResponse struct {
	Results AutocompleteMenuItemSearch_Response_Results `json:"results" validate:"required"`
}

func (a AutocompleteMenuItemSearchResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Results).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Results", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchMenuItemsResponse struct {
	MenuItems      SearchMenuItems_Response_MenuItems `json:"menuItems" validate:"required"`
	TotalMenuItems int64                              `json:"totalMenuItems" validate:"required"`
	Type           string                             `json:"type" validate:"required,min=1"`
	Offset         int64                              `json:"offset" validate:"required"`
	Number         int64                              `json:"number" validate:"required"`
}

func (s SearchMenuItemsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.MenuItems).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("MenuItems", err)
		}
	}
	if err := typesValidator.Var(s.TotalMenuItems, "required"); err != nil {
		errors = errors.Append("TotalMenuItems", err)
	}
	if err := typesValidator.Var(s.Type, "required,min=1"); err != nil {
		errors = errors.Append("Type", err)
	}
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if err := typesValidator.Var(s.Number, "required"); err != nil {
		errors = errors.Append("Number", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMenuItemInformationResponse struct {
	ID               int64                                     `json:"id" validate:"required"`
	Title            string                                    `json:"title" validate:"required,min=1"`
	RestaurantChain  string                                    `json:"restaurantChain" validate:"required,min=1"`
	Nutrition        GetMenuItemInformation_Response_Nutrition `json:"nutrition"`
	Badges           []string                                  `json:"badges" validate:"required"`
	Breadcrumbs      []string                                  `json:"breadcrumbs" validate:"required"`
	GeneratedText    *string                                   `json:"generatedText,omitempty"`
	ImageType        string                                    `json:"imageType" validate:"required,min=1"`
	Likes            float32                                   `json:"likes" validate:"required"`
	Servings         GetMenuItemInformation_Response_Servings  `json:"servings"`
	Price            *float32                                  `json:"price,omitempty"`
	SpoonacularScore *float32                                  `json:"spoonacularScore,omitempty"`
}

func (g GetMenuItemInformationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Title, "required,min=1"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(g.RestaurantChain, "required,min=1"); err != nil {
		errors = errors.Append("RestaurantChain", err)
	}
	if v, ok := any(g.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if err := typesValidator.Var(g.Badges, "required"); err != nil {
		errors = errors.Append("Badges", err)
	}
	if err := typesValidator.Var(g.Breadcrumbs, "required"); err != nil {
		errors = errors.Append("Breadcrumbs", err)
	}
	if err := typesValidator.Var(g.ImageType, "required,min=1"); err != nil {
		errors = errors.Append("ImageType", err)
	}
	if err := typesValidator.Var(g.Likes, "required"); err != nil {
		errors = errors.Append("Likes", err)
	}
	if v, ok := any(g.Servings).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Servings", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type VisualizeMenuItemNutritionByIDResponse = string

type MenuItemNutritionByIDImageResponse = map[string]any

type MenuItemNutritionLabelWidgetResponse = string

type MenuItemNutritionLabelImageResponse = map[string]any

type GenerateMealPlanResponse struct {
	Meals     GenerateMealPlan_Response_Meals     `json:"meals" validate:"required"`
	Nutrients GenerateMealPlan_Response_Nutrients `json:"nutrients"`
}

func (g GenerateMealPlanResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Meals).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Meals", err)
		}
	}
	if v, ok := any(g.Nutrients).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrients", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanWeekResponse struct {
	Days GetMealPlanWeek_Response_Days `json:"days" validate:"required"`
}

func (g GetMealPlanWeekResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Days).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Days", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ClearMealPlanDayResponse = map[string]any

type AddToMealPlanResponse = map[string]any

type DeleteFromMealPlanResponse = map[string]any

type GetMealPlanTemplatesResponse struct {
	Templates GetMealPlanTemplates_Response_Templates `json:"templates" validate:"required"`
}

func (g GetMealPlanTemplatesResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Templates).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Templates", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AddMealPlanTemplateResponse struct {
	Name            string                             `json:"name" validate:"required,min=1"`
	Items           AddMealPlanTemplate_Response_Items `json:"items" validate:"required"`
	PublishAsPublic bool                               `json:"publishAsPublic"`
}

func (a AddMealPlanTemplateResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(a.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(a.Items).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Items", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetMealPlanTemplateResponse struct {
	ID   int64                             `json:"id" validate:"required"`
	Name string                            `json:"name" validate:"required,min=1"`
	Days GetMealPlanTemplate_Response_Days `json:"days" validate:"required"`
}

func (g GetMealPlanTemplateResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(g.Name, "required,min=1"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(g.Days).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Days", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteMealPlanTemplateResponse = map[string]any

type GetShoppingListResponse struct {
	Aisles    GetShoppingList_Response_Aisles `json:"aisles" validate:"required"`
	Cost      float32                         `json:"cost" validate:"required"`
	StartDate float32                         `json:"startDate" validate:"required"`
	EndDate   float32                         `json:"endDate" validate:"required"`
}

func (g GetShoppingListResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Aisles).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Aisles", err)
		}
	}
	if err := typesValidator.Var(g.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(g.StartDate, "required"); err != nil {
		errors = errors.Append("StartDate", err)
	}
	if err := typesValidator.Var(g.EndDate, "required"); err != nil {
		errors = errors.Append("EndDate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GenerateShoppingListResponse struct {
	Aisles    GenerateShoppingList_Response_Aisles `json:"aisles" validate:"required"`
	Cost      float32                              `json:"cost" validate:"required"`
	StartDate float32                              `json:"startDate" validate:"required"`
	EndDate   float32                              `json:"endDate" validate:"required"`
}

func (g GenerateShoppingListResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Aisles).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Aisles", err)
		}
	}
	if err := typesValidator.Var(g.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(g.StartDate, "required"); err != nil {
		errors = errors.Append("StartDate", err)
	}
	if err := typesValidator.Var(g.EndDate, "required"); err != nil {
		errors = errors.Append("EndDate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ConnectUserResponse struct {
	Username string `json:"username" validate:"required,min=1"`
	Hash     string `json:"hash" validate:"required,min=1"`
}

func (c ConnectUserResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type AddToShoppingListResponse struct {
	Aisles    AddToShoppingList_Response_Aisles `json:"aisles" validate:"required"`
	Cost      float32                           `json:"cost" validate:"required"`
	StartDate float32                           `json:"startDate" validate:"required"`
	EndDate   float32                           `json:"endDate" validate:"required"`
}

func (a AddToShoppingListResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Aisles).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Aisles", err)
		}
	}
	if err := typesValidator.Var(a.Cost, "required"); err != nil {
		errors = errors.Append("Cost", err)
	}
	if err := typesValidator.Var(a.StartDate, "required"); err != nil {
		errors = errors.Append("StartDate", err)
	}
	if err := typesValidator.Var(a.EndDate, "required"); err != nil {
		errors = errors.Append("EndDate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteFromShoppingListResponse = map[string]any

type SearchRestaurantsResponse struct {
	Restaurants *SearchRestaurants_Response_Restaurants `json:"restaurants,omitempty"`
}

func (s SearchRestaurantsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if s.Restaurants != nil {
		if v, ok := any(s.Restaurants).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Restaurants", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDishPairingForWineResponse struct {
	Pairings []string `json:"pairings" validate:"required"`
	Text     string   `json:"text" validate:"required,min=1"`
}

func (g GetDishPairingForWineResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWinePairingResponse struct {
	PairedWines    []string                               `json:"pairedWines" validate:"required"`
	PairingText    string                                 `json:"pairingText" validate:"required,min=1"`
	ProductMatches GetWinePairing_Response_ProductMatches `json:"productMatches" validate:"required"`
}

func (g GetWinePairingResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.PairedWines, "required"); err != nil {
		errors = errors.Append("PairedWines", err)
	}
	if err := typesValidator.Var(g.PairingText, "required,min=1"); err != nil {
		errors = errors.Append("PairingText", err)
	}
	if v, ok := any(g.ProductMatches).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ProductMatches", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetWineDescriptionResponse struct {
	WineDescription string `json:"wineDescription" validate:"required,min=1"`
}

func (g GetWineDescriptionResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetWineRecommendationResponse struct {
	RecommendedWines GetWineRecommendation_Response_RecommendedWines `json:"recommendedWines" validate:"required"`
	TotalFound       int64                                           `json:"totalFound" validate:"required"`
}

func (g GetWineRecommendationResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.RecommendedWines).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RecommendedWines", err)
		}
	}
	if err := typesValidator.Var(g.TotalFound, "required"); err != nil {
		errors = errors.Append("TotalFound", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ImageClassificationByURLResponse struct {
	Category    string  `json:"category" validate:"required,min=1"`
	Probability float32 `json:"probability" validate:"required"`
}

func (i ImageClassificationByURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(i))
}

type ImageAnalysisByURLResponse struct {
	Nutrition ImageAnalysisByURL_Response_Nutrition `json:"nutrition"`
	Category  ImageAnalysisByURL_Response_Category  `json:"category"`
	Recipes   ImageAnalysisByURL_Response_Recipes   `json:"recipes" validate:"required"`
}

func (i ImageAnalysisByURLResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(i.Nutrition).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Nutrition", err)
		}
	}
	if v, ok := any(i.Category).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Category", err)
		}
	}
	if v, ok := any(i.Recipes).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Recipes", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type QuickAnswerResponse struct {
	Answer string `json:"answer" validate:"required,min=1"`
	Image  string `json:"image" validate:"required,min=1"`
}

func (q QuickAnswerResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(q))
}

type DetectFoodInTextResponse struct {
	Annotations DetectFoodInText_Response_Annotations `json:"annotations" validate:"required"`
}

func (d DetectFoodInTextResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Annotations).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Annotations", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchSiteContentResponse struct {
	Articles        SearchSiteContent_Response_Articles        `json:"Articles" validate:"required"`
	GroceryProducts SearchSiteContent_Response_GroceryProducts `json:"Grocery Products" validate:"required"`
	MenuItems       SearchSiteContent_Response_MenuItems       `json:"Menu Items" validate:"required"`
	Recipes         SearchSiteContent_Response_Recipes         `json:"Recipes" validate:"required"`
}

func (s SearchSiteContentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.Articles).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Articles", err)
		}
	}
	if v, ok := any(s.GroceryProducts).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GroceryProducts", err)
		}
	}
	if v, ok := any(s.MenuItems).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("MenuItems", err)
		}
	}
	if v, ok := any(s.Recipes).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Recipes", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchAllFoodResponse struct {
	Query         string                               `json:"query" validate:"required,min=1"`
	TotalResults  int64                                `json:"totalResults" validate:"required"`
	Limit         int64                                `json:"limit" validate:"required"`
	Offset        int64                                `json:"offset" validate:"required"`
	SearchResults SearchAllFood_Response_SearchResults `json:"searchResults" validate:"required"`
}

func (s SearchAllFoodResponse) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.Query, "required,min=1"); err != nil {
		errors = errors.Append("Query", err)
	}
	if err := typesValidator.Var(s.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if err := typesValidator.Var(s.Limit, "required"); err != nil {
		errors = errors.Append("Limit", err)
	}
	if err := typesValidator.Var(s.Offset, "required"); err != nil {
		errors = errors.Append("Offset", err)
	}
	if v, ok := any(s.SearchResults).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SearchResults", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchFoodVideosResponse struct {
	Videos       SearchFoodVideos_Response_Videos `json:"videos" validate:"required"`
	TotalResults int64                            `json:"totalResults" validate:"required"`
}

func (s SearchFoodVideosResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.Videos).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Videos", err)
		}
	}
	if err := typesValidator.Var(s.TotalResults, "required"); err != nil {
		errors = errors.Append("TotalResults", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetARandomFoodJokeResponse struct {
	Text string `json:"text" validate:"required,min=1"`
}

func (g GetARandomFoodJokeResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetRandomFoodTriviaResponse struct {
	Text string `json:"text" validate:"required,min=1"`
}

func (g GetRandomFoodTriviaResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type TalkToChatbotResponse struct {
	AnswerText string     `json:"answerText" validate:"required,min=1"`
	Media      []struct{} `json:"media" validate:"required"`
}

func (t TalkToChatbotResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type GetConversationSuggestsResponse struct {
	Suggests GetConversationSuggests_Response_Suggests `json:"suggests"`
	Words    []struct{}                                `json:"words" validate:"required"`
}

func (g GetConversationSuggestsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Suggests).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Suggests", err)
		}
	}
	if err := typesValidator.Var(g.Words, "required"); err != nil {
		errors = errors.Append("Words", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}
