// Code generated by oapi-codegen. DO NOT EDIT.

package zero

import (
	"embed"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"path"
	"strings"

	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/config"
	"github.com/cubahno/connexions/v2/pkg/db"
	"github.com/cubahno/connexions/v2/pkg/generator"
	"github.com/cubahno/connexions/v2/pkg/loader"
	"github.com/cubahno/connexions/v2/pkg/typedef"
	oapicodegen "github.com/doordash-oss/oapi-codegen-dd/v3/pkg/codegen"
	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
	yamlv4 "go.yaml.in/yaml/v4"
)

// OapiErrorKind represents the type of error that occurred during request processing.
type OapiErrorKind int

const (
	// OapiErrorKindParse indicates a parameter parsing error (invalid path/query/header parameter).
	OapiErrorKindParse OapiErrorKind = iota

	// OapiErrorKindDecode indicates a request body decoding error (invalid JSON, form data, etc.).
	OapiErrorKindDecode

	// OapiErrorKindValidation indicates a request validation error (failed schema validation).
	OapiErrorKindValidation

	// OapiErrorKindService indicates a service/business logic error returned by the service implementation.
	OapiErrorKindService
)

// OapiHandlerError represents an error that occurred during request handling (parse, decode, validation).
// When no typed error response is configured in the OpenAPI spec, this error type is used.
// Custom error handlers can type-assert to this type to access error details.
type OapiHandlerError struct {
	Kind          OapiErrorKind
	OperationID   string
	Message       string
	ParamName     string
	ParamLocation string
}

func (e OapiHandlerError) Error() string {
	return e.Message
}

// OapiErrorResponse is the default JSON error response structure used by OapiDefaultErrorHandler.
type OapiErrorResponse struct {
	Error         string `json:"error"`
	OperationID   string `json:"operation_id,omitempty"`
	ParamName     string `json:"param_name,omitempty"`
	ParamLocation string `json:"param_location,omitempty"`
}

// OapiErrorHandler handles errors that occur during request processing.
// Implement this interface to customize error responses, logging, and metrics.
type OapiErrorHandler interface {
	// HandleError writes an error response to w with the given status code.
	// The err is either an OapiHandlerError (for parse/decode/validation errors)
	// or a typed error matching the OpenAPI spec's error response schema.
	HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error)
}

// OapiDefaultErrorHandler provides the default error handling behavior.
// It writes JSON error responses. For OapiHandlerError, it uses OapiErrorResponse.
// For typed errors (from OpenAPI spec), it encodes them directly.
type OapiDefaultErrorHandler struct{}

// HandleError implements OapiErrorHandler with default JSON error responses.
func (h *OapiDefaultErrorHandler) HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)

	if handlerErr, ok := err.(OapiHandlerError); ok {
		_ = json.NewEncoder(w).Encode(OapiErrorResponse{
			Error:         handlerErr.Message,
			OperationID:   handlerErr.OperationID,
			ParamName:     handlerErr.ParamName,
			ParamLocation: handlerErr.ParamLocation,
		})
		return
	}

	// Typed error from OpenAPI spec - encode directly
	_ = json.NewEncoder(w).Encode(err)
}

// ServiceInterface defines the service interface for business logic.
type ServiceInterface interface {
}

// HTTPAdapter adapts the ServiceInterface to HTTP handlers.
// This struct is generated and should not be modified.
type HTTPAdapter struct {
	svc        ServiceInterface
	errHandler OapiErrorHandler
}

// NewHTTPAdapter creates a new HTTPAdapter wrapping the given service.
// If errHandler is nil, OapiDefaultErrorHandler is used.
func NewHTTPAdapter(svc ServiceInterface, errHandler OapiErrorHandler) *HTTPAdapter {
	if errHandler == nil {
		errHandler = &OapiDefaultErrorHandler{}
	}
	return &HTTPAdapter{svc: svc, errHandler: errHandler}
}

// RouterOption is a function that configures the router.
type RouterOption func(*routerConfig)

type routerConfig struct {
	middlewares []func(http.Handler) http.Handler
	errHandler  OapiErrorHandler
}

// WithMiddleware adds middleware to the router.
func WithMiddleware(mw func(http.Handler) http.Handler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.middlewares = append(cfg.middlewares, mw)
	}
}

// WithErrorHandler sets a custom error handler for the router.
// If not set, OapiOapiDefaultErrorHandler is used.
func WithErrorHandler(h OapiErrorHandler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.errHandler = h
	}
}

// NewRouter creates a new chi.Router with the given service implementation.
func NewRouter(svc ServiceInterface, opts ...RouterOption) chi.Router {
	cfg := &routerConfig{}
	for _, opt := range opts {
		opt(cfg)
	}

	r := chi.NewRouter()
	for _, mw := range cfg.middlewares {
		r.Use(mw)
	}

	return r
}

// ============================================================================
// Connexions Service Registration
// ============================================================================

//go:embed setup/config.yml
var configSrc []byte

//go:embed setup/openapi.*
var openapiSpecFS embed.FS

//go:embed setup/codegen.yml
var codegenConfigSrc []byte

//go:embed setup/context.yml
var contextSrc []byte

var cfg *config.ServiceConfig

func init() {
	var err error
	cfg, err = config.NewServiceConfigFromBytes(configSrc)
	if err != nil {
		slog.Error("Failed to parse service config", "error", err)
		return
	}
	loader.Register(cfg.Name, RegisterAPIRouter)
}

// Register registers the service with the central router.
func RegisterAPIRouter(router *api.Router) {
	serviceName := cfg.Name

	// Read OpenAPI spec from embedded FS
	openapiSpec, err := readFirstEmbeddedFile(openapiSpecFS)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to read OpenAPI spec for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}

	// Load codegen config
	var codegenCfg oapicodegen.Configuration
	if err := yamlv4.Unmarshal(codegenConfigSrc, &codegenCfg); err != nil {
		slog.Error(fmt.Sprintf("Failed to parse codegen config for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}
	codegenCfg = codegenCfg.Merge(oapicodegen.NewDefaultConfiguration())

	// Create the typedef registry from the OpenAPI spec
	registry := typedef.NewRegistryFromSpec(openapiSpec, codegenCfg, cfg.SpecOptions)

	// Create the generator with service contexts
	orderedCtx := generator.LoadServiceContext(contextSrc, router.GetContexts())
	gen, err := generator.NewGenerator(orderedCtx)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to create generator for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}

	// Register with connexions using handler factory
	router.RegisterHTTPHandler(cfg, func(serviceDB db.DB) api.Handler {
		userSvc := &service{db: serviceDB}
		genSvc := &generatorService{service: userSvc, generator: gen, registry: registry}
		return newServiceHandler(genSvc, gen, registry)
	})

	slog.Info(fmt.Sprintf("Registered %s service", serviceName),
		"service", serviceName,
	)
}

// readFirstEmbeddedFile reads the first file from an embedded filesystem.
func readFirstEmbeddedFile(fsys embed.FS) ([]byte, error) {
	entries, err := fsys.ReadDir("setup")
	if err != nil {
		return nil, fmt.Errorf("reading embedded directory: %w", err)
	}
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasPrefix(entry.Name(), "openapi.") {
			return fsys.ReadFile(path.Join("setup", entry.Name()))
		}
	}
	return nil, errors.New("no openapi spec file found in embedded filesystem")
}

// ============================================================================
// Service Handler
// ============================================================================

// serviceHandler wraps the chi router and service to implement api.Handler.
type serviceHandler struct {
	router   chi.Router
	service  ServiceInterface
	gen      generator.Generate
	registry typedef.OperationRegistry
}

// newServiceHandler creates a new serviceHandler.
func newServiceHandler(svc ServiceInterface, gen generator.Generate, registry typedef.OperationRegistry) api.Handler {
	return &serviceHandler{
		router:   NewRouter(svc),
		service:  svc,
		gen:      gen,
		registry: registry,
	}
}

func (h *serviceHandler) Routes() api.RouteDescriptions {
	routes := h.router.Routes()
	descriptions := make(api.RouteDescriptions, 0, len(routes))
	for _, route := range routes {
		for method := range route.Handlers {
			descriptions = append(descriptions, &api.RouteDescription{
				Method: method,
				Path:   route.Pattern,
			})
		}
	}
	return descriptions
}

func (h *serviceHandler) RegisterRoutes(router chi.Router) {
	router.Mount("/", h.router)
}

func (h *serviceHandler) Generate(w http.ResponseWriter, r *http.Request) {
	var req api.GenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		slog.Error("Failed to decode request", "error", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	op := h.registry.FindOperation(req.Path, req.Method)
	res := h.gen.Request(&req, op)
	api.NewJSONResponse(w).Send(res)
}

// ============================================================================
// Generator Service (fallback to mock responses)
// ============================================================================

// generatorService implements ServiceInterface with generator fallback.
// It delegates to the user's service first; if that returns nil, it generates a mock response.
type generatorService struct {
	service   *service
	generator generator.Generate
	registry  typedef.OperationRegistry
}

// Ensure generatorService implements ServiceInterface.
var _ ServiceInterface = (*generatorService)(nil)

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
