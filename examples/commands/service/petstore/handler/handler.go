// Code generated by connexions. DO NOT EDIT.

package handler

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"github.com/cubahno/connexions/v2/examples/commands/service/petstore/types"
	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/config"
	"github.com/cubahno/connexions/v2/pkg/typedef"
	"github.com/go-chi/chi/v5"
)

// Handler implements HTTP handlers for the API.
type Handler struct {
	service   serviceInterface
	config    *config.HandlerConfig
	routeList api.RouteDescriptions
}

// New creates a new handler instance.
// The operations and responseSchemas are built from the typedef registry at runtime.
// Only operations that have generated handlers (filtered by codegen config) are included.
func New(contextsSrc []byte, defaultContexts []map[string]map[string]any, cfg *config.HandlerConfig, registry typedef.OperationRegistry) (*Handler, error) {
	svc, err := newService(contextsSrc, defaultContexts, registry)
	if err != nil {
		return nil, err
	}

	// Build route list from registry's route info
	routeInfo := registry.GetRouteInfo()

	// Filter to only routes that have handlers generated
	handlerOps := map[string]bool{
		"POST:/pet":                     true,
		"PUT:/pet":                      true,
		"GET:/pet/findByStatus":         true,
		"GET:/pet/findByTags":           true,
		"GET:/pet/{petId}":              true,
		"POST:/pet/{petId}":             true,
		"DELETE:/pet/{petId}":           true,
		"POST:/pet/{petId}/uploadImage": true,
		"GET:/store/inventory":          true,
		"POST:/store/order":             true,
		"GET:/store/order/{orderId}":    true,
		"DELETE:/store/order/{orderId}": true,
		"POST:/user":                    true,
		"POST:/user/createWithList":     true,
		"GET:/user/login":               true,
		"GET:/user/logout":              true,
		"GET:/user/{username}":          true,
		"PUT:/user/{username}":          true,
		"DELETE:/user/{username}":       true,
	}

	routes := make(api.RouteDescriptions, 0, len(handlerOps))
	for _, ri := range routeInfo {
		key := ri.Method + ":" + ri.Path
		if handlerOps[key] {
			routes = append(routes, &api.RouteDescription{
				ID:     ri.ID,
				Method: ri.Method,
				Path:   ri.Path,
			})
		}
	}
	routes.Sort()

	return &Handler{
		service:   svc,
		config:    cfg,
		routeList: routes,
	}, nil
}

// Type returns the route type.
func (h *Handler) Type() api.RouteType {
	return api.RouteTypeOpenAPI
}

// Routes returns all route descriptions for operations that have handlers.
func (h *Handler) Routes() api.RouteDescriptions {
	return h.routeList
}

// RegisterRoutes registers all HTTP handlers with the provided Chi router.
func (h *Handler) RegisterRoutes(router chi.Router) {
	prefix := "/" + strings.TrimPrefix(h.config.SelfPrefix, "/")
	router.Post(prefix, h.Generate)
	router.MethodFunc("POST", "/pet", h.addPet)
	router.MethodFunc("PUT", "/pet", h.updatePet)
	router.MethodFunc("GET", "/pet/findByStatus", h.findPetsByStatus)
	router.MethodFunc("GET", "/pet/findByTags", h.findPetsByTags)
	router.MethodFunc("GET", "/pet/{petId}", h.getPetByID)
	router.MethodFunc("POST", "/pet/{petId}", h.updatePetWithForm)
	router.MethodFunc("DELETE", "/pet/{petId}", h.deletePet)
	router.MethodFunc("POST", "/pet/{petId}/uploadImage", h.uploadFile)
	router.MethodFunc("GET", "/store/inventory", h.getInventory)
	router.MethodFunc("POST", "/store/order", h.placeOrder)
	router.MethodFunc("GET", "/store/order/{orderId}", h.getOrderByID)
	router.MethodFunc("DELETE", "/store/order/{orderId}", h.deleteOrder)
	router.MethodFunc("POST", "/user", h.createUser)
	router.MethodFunc("POST", "/user/createWithList", h.createUsersWithListInput)
	router.MethodFunc("GET", "/user/login", h.loginUser)
	router.MethodFunc("GET", "/user/logout", h.logoutUser)
	router.MethodFunc("GET", "/user/{username}", h.getUserByName)
	router.MethodFunc("PUT", "/user/{username}", h.updateUser)
	router.MethodFunc("DELETE", "/user/{username}", h.deleteUser)
}

// Generate generates a valid request from the OpenAPI spec.
func (h *Handler) Generate(w http.ResponseWriter, r *http.Request) {
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in Generate handler", "panic", rec)
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		}
	}()

	var req api.GenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		slog.Error("Failed to decode request", "error", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	req.Method = strings.ToUpper(req.Method)

	res := h.service.generateRequest(&req, nil)
	slog.Debug("Generated request", "request", string(res))
	w.Header().Set("Content-Type", "application/json")
	w.Write(res)
}

func (h *Handler) getError(path, method string, err error) []byte {
	return h.service.generateError(path, method, err.Error())
}

// addPet implements POST /pet
func (h *Handler) addPet(w http.ResponseWriter, r *http.Request) {
	const opPath = "/pet"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "AddPet", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.AddPetBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.addPet(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.AddPetResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// updatePet implements PUT /pet
func (h *Handler) updatePet(w http.ResponseWriter, r *http.Request) {
	const opPath = "/pet"
	const opMethod = "PUT"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "UpdatePet", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.UpdatePetBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.updatePet(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.UpdatePetResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// findPetsByStatus implements GET /pet/findByStatus
func (h *Handler) findPetsByStatus(w http.ResponseWriter, r *http.Request) {
	const opPath = "/pet/findByStatus"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "FindPetsByStatus", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.findPetsByStatus(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.FindPetsByStatusResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// findPetsByTags implements GET /pet/findByTags
func (h *Handler) findPetsByTags(w http.ResponseWriter, r *http.Request) {
	const opPath = "/pet/findByTags"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "FindPetsByTags", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.findPetsByTags(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.FindPetsByTagsResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getPetByID implements GET /pet/{petId}
func (h *Handler) getPetByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/pet/{petId}"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetPetByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getPetByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetPetByIDResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// updatePetWithForm implements POST /pet/{petId}
func (h *Handler) updatePetWithForm(w http.ResponseWriter, r *http.Request) {
	const opPath = "/pet/{petId}"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "UpdatePetWithForm", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.updatePetWithForm(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.UpdatePetWithFormResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// deletePet implements DELETE /pet/{petId}
func (h *Handler) deletePet(w http.ResponseWriter, r *http.Request) {
	const opPath = "/pet/{petId}"
	const opMethod = "DELETE"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "DeletePet", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	w.WriteHeader(200)
}

// uploadFile implements POST /pet/{petId}/uploadImage
func (h *Handler) uploadFile(w http.ResponseWriter, r *http.Request) {
	const opPath = "/pet/{petId}/uploadImage"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "UploadFile", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.UploadFileBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.uploadFile(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.UploadFileResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getInventory implements GET /store/inventory
func (h *Handler) getInventory(w http.ResponseWriter, r *http.Request) {
	const opPath = "/store/inventory"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetInventory", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getInventory(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetInventoryResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// placeOrder implements POST /store/order
func (h *Handler) placeOrder(w http.ResponseWriter, r *http.Request) {
	const opPath = "/store/order"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "PlaceOrder", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.PlaceOrderBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.placeOrder(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.PlaceOrderResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// getOrderByID implements GET /store/order/{orderId}
func (h *Handler) getOrderByID(w http.ResponseWriter, r *http.Request) {
	const opPath = "/store/order/{orderId}"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetOrderByID", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getOrderByID(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetOrderByIDResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// deleteOrder implements DELETE /store/order/{orderId}
func (h *Handler) deleteOrder(w http.ResponseWriter, r *http.Request) {
	const opPath = "/store/order/{orderId}"
	const opMethod = "DELETE"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "DeleteOrder", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	w.WriteHeader(200)
}

// createUser implements POST /user
func (h *Handler) createUser(w http.ResponseWriter, r *http.Request) {
	const opPath = "/user"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "CreateUser", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.CreateUserBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.createUser(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.CreateUserResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// createUsersWithListInput implements POST /user/createWithList
func (h *Handler) createUsersWithListInput(w http.ResponseWriter, r *http.Request) {
	const opPath = "/user/createWithList"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "CreateUsersWithListInput", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.CreateUsersWithListInputBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.createUsersWithListInput(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.CreateUsersWithListInputResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// loginUser implements GET /user/login
func (h *Handler) loginUser(w http.ResponseWriter, r *http.Request) {
	const opPath = "/user/login"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "LoginUser", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.loginUser(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.LoginUserResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	for k, vals := range res.Headers {
		for _, v := range vals {
			w.Header().Add(k, v)
		}
	}
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// logoutUser implements GET /user/logout
func (h *Handler) logoutUser(w http.ResponseWriter, r *http.Request) {
	const opPath = "/user/logout"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "LogoutUser", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	w.WriteHeader(200)
}

// getUserByName implements GET /user/{username}
func (h *Handler) getUserByName(w http.ResponseWriter, r *http.Request) {
	const opPath = "/user/{username}"
	const opMethod = "GET"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "GetUserByName", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.getUserByName(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.GetUserByNameResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}

// updateUser implements PUT /user/{username}
func (h *Handler) updateUser(w http.ResponseWriter, r *http.Request) {
	const opPath = "/user/{username}"
	const opMethod = "PUT"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "UpdateUser", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[types.UpdateUserBody](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	w.WriteHeader(200)
}

// deleteUser implements DELETE /user/{username}
func (h *Handler) deleteUser(w http.ResponseWriter, r *http.Request) {
	const opPath = "/user/{username}"
	const opMethod = "DELETE"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "DeleteUser", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	w.WriteHeader(200)
}
