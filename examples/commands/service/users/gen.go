// Code generated by oapi-codegen. DO NOT EDIT.

package users

import (
	"context"
	"embed"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"path"
	"strings"

	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/config"
	"github.com/cubahno/connexions/v2/pkg/db"
	"github.com/cubahno/connexions/v2/pkg/generator"
	"github.com/cubahno/connexions/v2/pkg/loader"
	"github.com/cubahno/connexions/v2/pkg/typedef"
	oapicodegen "github.com/doordash-oss/oapi-codegen-dd/v3/pkg/codegen"
	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
	yamlv4 "go.yaml.in/yaml/v4"
)

// OapiErrorKind represents the type of error that occurred during request processing.
type OapiErrorKind int

const (
	// OapiErrorKindParse indicates a parameter parsing error (invalid path/query/header parameter).
	OapiErrorKindParse OapiErrorKind = iota

	// OapiErrorKindDecode indicates a request body decoding error (invalid JSON, form data, etc.).
	OapiErrorKindDecode

	// OapiErrorKindValidation indicates a request validation error (failed schema validation).
	OapiErrorKindValidation

	// OapiErrorKindService indicates a service/business logic error returned by the service implementation.
	OapiErrorKindService
)

// OapiHandlerError represents an error that occurred during request handling (parse, decode, validation).
// When no typed error response is configured in the OpenAPI spec, this error type is used.
// Custom error handlers can type-assert to this type to access error details.
type OapiHandlerError struct {
	Kind          OapiErrorKind
	OperationID   string
	Message       string
	ParamName     string
	ParamLocation string
}

func (e OapiHandlerError) Error() string {
	return e.Message
}

// OapiErrorResponse is the default JSON error response structure used by OapiDefaultErrorHandler.
type OapiErrorResponse struct {
	Error         string `json:"error"`
	OperationID   string `json:"operation_id,omitempty"`
	ParamName     string `json:"param_name,omitempty"`
	ParamLocation string `json:"param_location,omitempty"`
}

// OapiErrorHandler handles errors that occur during request processing.
// Implement this interface to customize error responses, logging, and metrics.
type OapiErrorHandler interface {
	// HandleError writes an error response to w with the given status code.
	// The err is either an OapiHandlerError (for parse/decode/validation errors)
	// or a typed error matching the OpenAPI spec's error response schema.
	HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error)
}

// OapiDefaultErrorHandler provides the default error handling behavior.
// It writes JSON error responses. For OapiHandlerError, it uses OapiErrorResponse.
// For typed errors (from OpenAPI spec), it encodes them directly.
type OapiDefaultErrorHandler struct{}

// HandleError implements OapiErrorHandler with default JSON error responses.
func (h *OapiDefaultErrorHandler) HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)

	if handlerErr, ok := err.(OapiHandlerError); ok {
		_ = json.NewEncoder(w).Encode(OapiErrorResponse{
			Error:         handlerErr.Message,
			OperationID:   handlerErr.OperationID,
			ParamName:     handlerErr.ParamName,
			ParamLocation: handlerErr.ParamLocation,
		})
		return
	}

	// Typed error from OpenAPI spec - encode directly
	_ = json.NewEncoder(w).Encode(err)
}

// ServiceInterface defines the service interface for business logic.
type ServiceInterface interface {
	// ListUsers List all users (JSON)
	ListUsers(ctx context.Context) (*ListUsersResponseData, error)
	// GetUser Get user by ID (JSON with charset)
	GetUser(ctx context.Context, opts *GetUserServiceRequestOptions) (*GetUserResponseData, error)
	// GetUserAvatar Get user avatar (image)
	GetUserAvatar(ctx context.Context, opts *GetUserAvatarServiceRequestOptions) (*GetUserAvatarResponseData, error)
	// GetUserProfile Get user profile (HTML with charset)
	GetUserProfile(ctx context.Context, opts *GetUserProfileServiceRequestOptions) (*GetUserProfileResponseData, error)
	// ExportUsers Export users (CSV)
	ExportUsers(ctx context.Context) (*ExportUsersResponseData, error)
	// GetUserConfig Get user config (XML)
	GetUserConfig(ctx context.Context, opts *GetUserConfigServiceRequestOptions) (*GetUserConfigResponseData, error)
	// GetUserAPIData Get user data (JSON API format)
	GetUserAPIData(ctx context.Context, opts *GetUserAPIDataServiceRequestOptions) (*GetUserAPIDataResponseData, error)
	// GetUserHal Get user HAL format
	GetUserHal(ctx context.Context, opts *GetUserHalServiceRequestOptions) (*GetUserHalResponseData, error)
	// GetUserProblem Get user with RFC 7807 problem
	GetUserProblem(ctx context.Context, opts *GetUserProblemServiceRequestOptions) (*GetUserProblemResponseData, error)
	// StreamUsers Stream users (NDJSON)
	StreamUsers(ctx context.Context) (*StreamUsersResponseData, error)
	// GetUserPdf Get user PDF report
	GetUserPdf(ctx context.Context, opts *GetUserPdfServiceRequestOptions) (*GetUserPdfResponseData, error)
}

// HTTPAdapter adapts the ServiceInterface to HTTP handlers.
// This struct is generated and should not be modified.
type HTTPAdapter struct {
	svc        ServiceInterface
	errHandler OapiErrorHandler
}

// NewHTTPAdapter creates a new HTTPAdapter wrapping the given service.
// If errHandler is nil, OapiDefaultErrorHandler is used.
func NewHTTPAdapter(svc ServiceInterface, errHandler OapiErrorHandler) *HTTPAdapter {
	if errHandler == nil {
		errHandler = &OapiDefaultErrorHandler{}
	}
	return &HTTPAdapter{svc: svc, errHandler: errHandler}
}

// ListUsers handles GET /users
func (a *HTTPAdapter) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.ListUsers(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetUser handles GET /users/{id}
func (a *HTTPAdapter) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetUserAvatar handles GET /users/{id}/avatar
func (a *HTTPAdapter) GetUserAvatar(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserAvatarServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserAvatarPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUserAvatar(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "image/png")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetUserProfile handles GET /users/{id}/profile
func (a *HTTPAdapter) GetUserProfile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserProfileServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserProfilePath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUserProfile(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = fmt.Fprintf(w, "%v", *resp.Body)
	}
}

// ExportUsers handles GET /users/export
func (a *HTTPAdapter) ExportUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.ExportUsers(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "text/csv")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetUserConfig handles GET /users/{id}/config
func (a *HTTPAdapter) GetUserConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserConfigServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserConfigPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUserConfig(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/xml")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetUserAPIData handles GET /users/{id}/api-data
func (a *HTTPAdapter) GetUserAPIData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserAPIDataServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserAPIDataPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUserAPIData(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetUserHal handles GET /users/{id}/hal
func (a *HTTPAdapter) GetUserHal(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserHalServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserHalPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUserHal(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/hal+json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetUserProblem handles GET /users/{id}/problem
func (a *HTTPAdapter) GetUserProblem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserProblemServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserProblemPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUserProblem(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// StreamUsers handles GET /users/stream
func (a *HTTPAdapter) StreamUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.StreamUsers(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/x-ndjson")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// GetUserPdf handles GET /users/{id}/pdf
func (a *HTTPAdapter) GetUserPdf(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserPdfServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserPdfPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUserPdf(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/pdf")

	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_, _ = w.Write(resp.Body)
	}
}

// RouterOption is a function that configures the router.
type RouterOption func(*routerConfig)

type routerConfig struct {
	middlewares []func(http.Handler) http.Handler
	errHandler  OapiErrorHandler
}

// WithMiddleware adds middleware to the router.
func WithMiddleware(mw func(http.Handler) http.Handler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.middlewares = append(cfg.middlewares, mw)
	}
}

// WithErrorHandler sets a custom error handler for the router.
// If not set, OapiOapiDefaultErrorHandler is used.
func WithErrorHandler(h OapiErrorHandler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.errHandler = h
	}
}

// NewRouter creates a new chi.Router with the given service implementation.
func NewRouter(svc ServiceInterface, opts ...RouterOption) chi.Router {
	cfg := &routerConfig{}
	for _, opt := range opts {
		opt(cfg)
	}

	r := chi.NewRouter()
	for _, mw := range cfg.middlewares {
		r.Use(mw)
	}
	adapter := NewHTTPAdapter(svc, cfg.errHandler)
	r.Method("GET", "/users", http.HandlerFunc(adapter.ListUsers))
	r.Method("GET", "/users/{id}", http.HandlerFunc(adapter.GetUser))
	r.Method("GET", "/users/{id}/avatar", http.HandlerFunc(adapter.GetUserAvatar))
	r.Method("GET", "/users/{id}/profile", http.HandlerFunc(adapter.GetUserProfile))
	r.Method("GET", "/users/export", http.HandlerFunc(adapter.ExportUsers))
	r.Method("GET", "/users/{id}/config", http.HandlerFunc(adapter.GetUserConfig))
	r.Method("GET", "/users/{id}/api-data", http.HandlerFunc(adapter.GetUserAPIData))
	r.Method("GET", "/users/{id}/hal", http.HandlerFunc(adapter.GetUserHal))
	r.Method("GET", "/users/{id}/problem", http.HandlerFunc(adapter.GetUserProblem))
	r.Method("GET", "/users/stream", http.HandlerFunc(adapter.StreamUsers))
	r.Method("GET", "/users/{id}/pdf", http.HandlerFunc(adapter.GetUserPdf))

	return r
}

// ============================================================================
// Connexions Service Registration
// ============================================================================

//go:embed setup/config.yml
var configSrc []byte

//go:embed setup/openapi.*
var openapiSpecFS embed.FS

//go:embed setup/codegen.yml
var codegenConfigSrc []byte

//go:embed setup/context.yml
var contextSrc []byte

var cfg *config.ServiceConfig

func init() {
	var err error
	cfg, err = config.NewServiceConfigFromBytes(configSrc)
	if err != nil {
		slog.Error("Failed to parse service config", "error", err)
		return
	}
	loader.Register(cfg.Name, RegisterAPIRouter)
}

// Register registers the service with the central router.
func RegisterAPIRouter(router *api.Router) {
	serviceName := cfg.Name

	// Read OpenAPI spec from embedded FS
	openapiSpec, err := readFirstEmbeddedFile(openapiSpecFS)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to read OpenAPI spec for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}

	// Load codegen config
	var codegenCfg oapicodegen.Configuration
	if err := yamlv4.Unmarshal(codegenConfigSrc, &codegenCfg); err != nil {
		slog.Error(fmt.Sprintf("Failed to parse codegen config for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}
	codegenCfg = codegenCfg.Merge(oapicodegen.NewDefaultConfiguration())

	// Create the typedef registry from the OpenAPI spec
	registry := typedef.NewRegistryFromSpec(openapiSpec, codegenCfg, cfg.SpecOptions)

	// Create the generator with service contexts
	orderedCtx := generator.LoadServiceContext(contextSrc, router.GetContexts())
	gen, err := generator.NewGenerator(orderedCtx)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to create generator for %s", serviceName),
			"error", err,
			"service", serviceName,
		)
		return
	}

	// Register with connexions using handler factory
	router.RegisterHTTPHandler(cfg, func(serviceDB db.DB) api.Handler {
		userSvc := newService(&api.ServiceParams{
			AppConfig:     router.Config(),
			ServiceConfig: cfg,
			DB:            serviceDB,
		})
		genSvc := &generatorService{service: userSvc, generator: gen, registry: registry}
		return newServiceHandler(genSvc, gen, registry)
	}, api.WithMiddleware(getMiddleware()))

	slog.Info(fmt.Sprintf("Registered %s service", serviceName),
		"service", serviceName,
	)
}

// readFirstEmbeddedFile reads the first file from an embedded filesystem.
func readFirstEmbeddedFile(fsys embed.FS) ([]byte, error) {
	entries, err := fsys.ReadDir("setup")
	if err != nil {
		return nil, fmt.Errorf("reading embedded directory: %w", err)
	}
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasPrefix(entry.Name(), "openapi.") {
			return fsys.ReadFile(path.Join("setup", entry.Name()))
		}
	}
	return nil, errors.New("no openapi spec file found in embedded filesystem")
}

// ============================================================================
// Service Handler
// ============================================================================

// serviceHandler wraps the chi router and service to implement api.Handler.
type serviceHandler struct {
	router   chi.Router
	service  ServiceInterface
	gen      generator.Generate
	registry typedef.OperationRegistry
}

// newServiceHandler creates a new serviceHandler.
func newServiceHandler(svc ServiceInterface, gen generator.Generate, registry typedef.OperationRegistry) api.Handler {
	return &serviceHandler{
		router:   NewRouter(svc),
		service:  svc,
		gen:      gen,
		registry: registry,
	}
}

func (h *serviceHandler) Routes() api.RouteDescriptions {
	routes := h.router.Routes()
	descriptions := make(api.RouteDescriptions, 0, len(routes))
	for _, route := range routes {
		for method := range route.Handlers {
			descriptions = append(descriptions, &api.RouteDescription{
				Method: method,
				Path:   route.Pattern,
			})
		}
	}
	return descriptions
}

func (h *serviceHandler) RegisterRoutes(router chi.Router) {
	router.Mount("/", h.router)
}

func (h *serviceHandler) Generate(w http.ResponseWriter, r *http.Request) {
	var req api.GenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		message := err.Error()
		if errors.Is(err, io.EOF) {
			message = "request body is empty or incomplete"
		}
		slog.Error("Failed to decode request", "error", err)
		http.Error(w, message, http.StatusBadRequest)
		return
	}

	op := h.registry.FindOperation(req.Path, req.Method)
	res := h.gen.Request(&req, op)
	api.NewJSONResponse(w).Send(res)
}

// ============================================================================
// Generator Service (fallback to mock responses)
// ============================================================================

// generatorService implements ServiceInterface with generator fallback.
// It delegates to the user's service first; if that returns nil, it generates a mock response.
type generatorService struct {
	service   *service
	generator generator.Generate
	registry  typedef.OperationRegistry
}

// Ensure generatorService implements ServiceInterface.
var _ ServiceInterface = (*generatorService)(nil)

// ListUsers handles GET /users
func (s *generatorService) ListUsers(ctx context.Context) (*ListUsersResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ListUsers(ctx); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users", "GET")
	if respSchema == nil {
		return NewListUsersResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body ListUsersResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json", &body); err != nil {
		return nil, err
	}
	return NewListUsersResponseData(&body).WithHeaders(res.Headers), nil
}

// GetUser handles GET /users/{id}
func (s *generatorService) GetUser(ctx context.Context, opts *GetUserServiceRequestOptions) (*GetUserResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUser(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/{id}", "GET")
	if respSchema == nil {
		return NewGetUserResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetUserResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/json; charset=utf-8", &body); err != nil {
		return nil, err
	}
	return NewGetUserResponseData(&body).WithHeaders(res.Headers), nil
}

// GetUserAvatar handles GET /users/{id}/avatar
func (s *generatorService) GetUserAvatar(ctx context.Context, opts *GetUserAvatarServiceRequestOptions) (*GetUserAvatarResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUserAvatar(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/{id}/avatar", "GET")
	if respSchema == nil {
		return NewGetUserAvatarResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewGetUserAvatarResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetUserProfile handles GET /users/{id}/profile
func (s *generatorService) GetUserProfile(ctx context.Context, opts *GetUserProfileServiceRequestOptions) (*GetUserProfileResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUserProfile(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/{id}/profile", "GET")
	if respSchema == nil {
		return NewGetUserProfileResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetUserProfileResponse
	if err := api.UnmarshalResponseInto(res.Body, "text/html; charset=utf-8", &body); err != nil {
		return nil, err
	}
	return NewGetUserProfileResponseData(&body).WithHeaders(res.Headers), nil
}

// ExportUsers handles GET /users/export
func (s *generatorService) ExportUsers(ctx context.Context) (*ExportUsersResponseData, error) {
	// Call user's service first
	if resp, err := s.service.ExportUsers(ctx); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/export", "GET")
	if respSchema == nil {
		return NewExportUsersResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewExportUsersResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetUserConfig handles GET /users/{id}/config
func (s *generatorService) GetUserConfig(ctx context.Context, opts *GetUserConfigServiceRequestOptions) (*GetUserConfigResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUserConfig(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/{id}/config", "GET")
	if respSchema == nil {
		return NewGetUserConfigResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewGetUserConfigResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetUserAPIData handles GET /users/{id}/api-data
func (s *generatorService) GetUserAPIData(ctx context.Context, opts *GetUserAPIDataServiceRequestOptions) (*GetUserAPIDataResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUserAPIData(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/{id}/api-data", "GET")
	if respSchema == nil {
		return NewGetUserAPIDataResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetUserAPIDataResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/vnd.api+json", &body); err != nil {
		return nil, err
	}
	return NewGetUserAPIDataResponseData(&body).WithHeaders(res.Headers), nil
}

// GetUserHal handles GET /users/{id}/hal
func (s *generatorService) GetUserHal(ctx context.Context, opts *GetUserHalServiceRequestOptions) (*GetUserHalResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUserHal(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/{id}/hal", "GET")
	if respSchema == nil {
		return NewGetUserHalResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetUserHalResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/hal+json", &body); err != nil {
		return nil, err
	}
	return NewGetUserHalResponseData(&body).WithHeaders(res.Headers), nil
}

// GetUserProblem handles GET /users/{id}/problem
func (s *generatorService) GetUserProblem(ctx context.Context, opts *GetUserProblemServiceRequestOptions) (*GetUserProblemResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUserProblem(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/{id}/problem", "GET")
	if respSchema == nil {
		return NewGetUserProblemResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	var body GetUserProblemResponse
	if err := api.UnmarshalResponseInto(res.Body, "application/problem+json", &body); err != nil {
		return nil, err
	}
	return NewGetUserProblemResponseData(&body).WithHeaders(res.Headers), nil
}

// StreamUsers handles GET /users/stream
func (s *generatorService) StreamUsers(ctx context.Context) (*StreamUsersResponseData, error) {
	// Call user's service first
	if resp, err := s.service.StreamUsers(ctx); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/stream", "GET")
	if respSchema == nil {
		return NewStreamUsersResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewStreamUsersResponseData(res.Body).WithHeaders(res.Headers), nil
}

// GetUserPdf handles GET /users/{id}/pdf
func (s *generatorService) GetUserPdf(ctx context.Context, opts *GetUserPdfServiceRequestOptions) (*GetUserPdfResponseData, error) {
	// Call user's service first
	if resp, err := s.service.GetUserPdf(ctx, opts); resp != nil || err != nil {
		return resp, err
	}

	// Fallback to generator
	respSchema := s.registry.GetResponseSchema("/users/{id}/pdf", "GET")
	if respSchema == nil {
		return NewGetUserPdfResponseData(nil), nil
	}

	res := s.generator.Response(respSchema)
	return NewGetUserPdfResponseData(res.Body).WithHeaders(res.Headers), nil
}

type GetUserPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetUserAvatarPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserAvatarPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetUserProfilePath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserProfilePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetUserConfigPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserConfigPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetUserAPIDataPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserAPIDataPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetUserHalPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserHalPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetUserProblemPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserProblemPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetUserPdfPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserPdfPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

// ListUsersResponseData wraps the success response with optional headers and status override.
type ListUsersResponseData struct {
	Body    *ListUsersResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewListUsersResponseData creates a new ListUsersResponseData with the given body.
func NewListUsersResponseData(body *ListUsersResponse) *ListUsersResponseData {
	return &ListUsersResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ListUsersResponseData) WithHeaders(h http.Header) *ListUsersResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ListUsersResponseData) WithStatus(code int) *ListUsersResponseData {
	r.Status = code
	return r
}

// GetUserResponseData wraps the success response with optional headers and status override.
type GetUserResponseData struct {
	Body    *GetUserResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserResponseData creates a new GetUserResponseData with the given body.
func NewGetUserResponseData(body *GetUserResponse) *GetUserResponseData {
	return &GetUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserResponseData) WithHeaders(h http.Header) *GetUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserResponseData) WithStatus(code int) *GetUserResponseData {
	r.Status = code
	return r
}

// GetUserAvatarResponseData wraps the success response with optional headers and status override.
type GetUserAvatarResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserAvatarResponseData creates a new GetUserAvatarResponseData with the given body.
func NewGetUserAvatarResponseData(body []byte) *GetUserAvatarResponseData {
	return &GetUserAvatarResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserAvatarResponseData) WithHeaders(h http.Header) *GetUserAvatarResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserAvatarResponseData) WithStatus(code int) *GetUserAvatarResponseData {
	r.Status = code
	return r
}

// GetUserProfileResponseData wraps the success response with optional headers and status override.
type GetUserProfileResponseData struct {
	Body    *GetUserProfileResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserProfileResponseData creates a new GetUserProfileResponseData with the given body.
func NewGetUserProfileResponseData(body *GetUserProfileResponse) *GetUserProfileResponseData {
	return &GetUserProfileResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserProfileResponseData) WithHeaders(h http.Header) *GetUserProfileResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserProfileResponseData) WithStatus(code int) *GetUserProfileResponseData {
	r.Status = code
	return r
}

// ExportUsersResponseData wraps the success response with optional headers and status override.
type ExportUsersResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewExportUsersResponseData creates a new ExportUsersResponseData with the given body.
func NewExportUsersResponseData(body []byte) *ExportUsersResponseData {
	return &ExportUsersResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ExportUsersResponseData) WithHeaders(h http.Header) *ExportUsersResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ExportUsersResponseData) WithStatus(code int) *ExportUsersResponseData {
	r.Status = code
	return r
}

// GetUserConfigResponseData wraps the success response with optional headers and status override.
type GetUserConfigResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserConfigResponseData creates a new GetUserConfigResponseData with the given body.
func NewGetUserConfigResponseData(body []byte) *GetUserConfigResponseData {
	return &GetUserConfigResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserConfigResponseData) WithHeaders(h http.Header) *GetUserConfigResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserConfigResponseData) WithStatus(code int) *GetUserConfigResponseData {
	r.Status = code
	return r
}

// GetUserAPIDataResponseData wraps the success response with optional headers and status override.
type GetUserAPIDataResponseData struct {
	Body    *GetUserAPIDataResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserAPIDataResponseData creates a new GetUserAPIDataResponseData with the given body.
func NewGetUserAPIDataResponseData(body *GetUserAPIDataResponse) *GetUserAPIDataResponseData {
	return &GetUserAPIDataResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserAPIDataResponseData) WithHeaders(h http.Header) *GetUserAPIDataResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserAPIDataResponseData) WithStatus(code int) *GetUserAPIDataResponseData {
	r.Status = code
	return r
}

// GetUserHalResponseData wraps the success response with optional headers and status override.
type GetUserHalResponseData struct {
	Body    *GetUserHalResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserHalResponseData creates a new GetUserHalResponseData with the given body.
func NewGetUserHalResponseData(body *GetUserHalResponse) *GetUserHalResponseData {
	return &GetUserHalResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserHalResponseData) WithHeaders(h http.Header) *GetUserHalResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserHalResponseData) WithStatus(code int) *GetUserHalResponseData {
	r.Status = code
	return r
}

// GetUserProblemResponseData wraps the success response with optional headers and status override.
type GetUserProblemResponseData struct {
	Body    *GetUserProblemResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserProblemResponseData creates a new GetUserProblemResponseData with the given body.
func NewGetUserProblemResponseData(body *GetUserProblemResponse) *GetUserProblemResponseData {
	return &GetUserProblemResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserProblemResponseData) WithHeaders(h http.Header) *GetUserProblemResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserProblemResponseData) WithStatus(code int) *GetUserProblemResponseData {
	r.Status = code
	return r
}

// StreamUsersResponseData wraps the success response with optional headers and status override.
type StreamUsersResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewStreamUsersResponseData creates a new StreamUsersResponseData with the given body.
func NewStreamUsersResponseData(body []byte) *StreamUsersResponseData {
	return &StreamUsersResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *StreamUsersResponseData) WithHeaders(h http.Header) *StreamUsersResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *StreamUsersResponseData) WithStatus(code int) *StreamUsersResponseData {
	r.Status = code
	return r
}

// GetUserPdfResponseData wraps the success response with optional headers and status override.
type GetUserPdfResponseData struct {
	Body    []byte
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserPdfResponseData creates a new GetUserPdfResponseData with the given body.
func NewGetUserPdfResponseData(body []byte) *GetUserPdfResponseData {
	return &GetUserPdfResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserPdfResponseData) WithHeaders(h http.Header) *GetUserPdfResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserPdfResponseData) WithStatus(code int) *GetUserPdfResponseData {
	r.Status = code
	return r
}

type ListUsersResponse []User

func (l ListUsersResponse) Validate() error {
	if l == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range l {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetUserResponse = User

type GetUserAvatarResponse = []byte

type GetUserProfileResponse = string

type ExportUsersResponse = []byte

type GetUserConfigResponse = []byte

type GetUserAPIDataResponse = User

type GetUserHalResponse = User

type GetUserProblemResponse = User

type StreamUsersResponse = []byte

type GetUserPdfResponse = []byte

// GetUserServiceRequestOptions holds all parameters for the GetUser operation.
type GetUserServiceRequestOptions struct {
	PathParams *GetUserPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserAvatarServiceRequestOptions holds all parameters for the GetUserAvatar operation.
type GetUserAvatarServiceRequestOptions struct {
	PathParams *GetUserAvatarPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserAvatarServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserProfileServiceRequestOptions holds all parameters for the GetUserProfile operation.
type GetUserProfileServiceRequestOptions struct {
	PathParams *GetUserProfilePath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserProfileServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserConfigServiceRequestOptions holds all parameters for the GetUserConfig operation.
type GetUserConfigServiceRequestOptions struct {
	PathParams *GetUserConfigPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserConfigServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserAPIDataServiceRequestOptions holds all parameters for the GetUserAPIData operation.
type GetUserAPIDataServiceRequestOptions struct {
	PathParams *GetUserAPIDataPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserAPIDataServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserHalServiceRequestOptions holds all parameters for the GetUserHal operation.
type GetUserHalServiceRequestOptions struct {
	PathParams *GetUserHalPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserHalServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserProblemServiceRequestOptions holds all parameters for the GetUserProblem operation.
type GetUserProblemServiceRequestOptions struct {
	PathParams *GetUserProblemPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserProblemServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserPdfServiceRequestOptions holds all parameters for the GetUserPdf operation.
type GetUserPdfServiceRequestOptions struct {
	PathParams *GetUserPdfPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserPdfServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

type User struct {
	ID    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Email *string `json:"email,omitempty"`
}

type UserConfig struct {
	Theme         *string `json:"theme,omitempty"`
	Language      *string `json:"language,omitempty"`
	Notifications *bool   `json:"notifications,omitempty"`
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
