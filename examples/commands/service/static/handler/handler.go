// Code generated by connexions. DO NOT EDIT.

package handler

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"github.com/cubahno/connexions/v2/examples/commands/service/static/types"
	"github.com/cubahno/connexions/v2/pkg/api"
	"github.com/cubahno/connexions/v2/pkg/config"
	"github.com/cubahno/connexions/v2/pkg/typedef"
	"github.com/go-chi/chi/v5"
)

// Handler implements HTTP handlers for the API.
type Handler struct {
	service   serviceInterface
	config    *config.HandlerConfig
	routeList api.RouteDescriptions
}

// New creates a new handler instance.
// The operations and responseSchemas are built from the typedef registry at runtime.
// Only operations that have generated handlers (filtered by codegen config) are included.
func New(contextsSrc []byte, defaultContexts []map[string]map[string]any, cfg *config.HandlerConfig, registry typedef.OperationRegistry) (*Handler, error) {
	svc, err := newService(contextsSrc, defaultContexts, registry)
	if err != nil {
		return nil, err
	}

	// Build route list from registry's route info
	routeInfo := registry.GetRouteInfo()

	// Filter to only routes that have handlers generated
	handlerOps := map[string]bool{
		"POST:/foo/bar": true,
	}

	routes := make(api.RouteDescriptions, 0, len(handlerOps))
	for _, ri := range routeInfo {
		key := ri.Method + ":" + ri.Path
		if handlerOps[key] {
			routes = append(routes, &api.RouteDescription{
				ID:     ri.ID,
				Method: ri.Method,
				Path:   ri.Path,
			})
		}
	}
	routes.Sort()

	return &Handler{
		service:   svc,
		config:    cfg,
		routeList: routes,
	}, nil
}

// Type returns the route type.
func (h *Handler) Type() api.RouteType {
	return api.RouteTypeOpenAPI
}

// Routes returns all route descriptions for operations that have handlers.
func (h *Handler) Routes() api.RouteDescriptions {
	return h.routeList
}

// RegisterRoutes registers all HTTP handlers with the provided Chi router.
func (h *Handler) RegisterRoutes(router chi.Router) {
	prefix := "/" + strings.TrimPrefix(h.config.SelfPrefix, "/")
	router.Post(prefix, h.Generate)
	router.MethodFunc("POST", "/foo/bar", h.postFooBar)
}

// Generate generates a valid request from the OpenAPI spec.
func (h *Handler) Generate(w http.ResponseWriter, r *http.Request) {
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in Generate handler", "panic", rec)
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		}
	}()

	var req api.GenerateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		slog.Error("Failed to decode request", "error", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	req.Method = strings.ToUpper(req.Method)

	res := h.service.generateRequest(&req, nil)
	slog.Debug("Generated request", "request", string(res))
	w.Header().Set("Content-Type", "application/json")
	w.Write(res)
}

func (h *Handler) getError(path, method string, err error) []byte {
	return h.service.generateError(path, method, err.Error())
}

// postFooBar implements POST /foo/bar
func (h *Handler) postFooBar(w http.ResponseWriter, r *http.Request) {
	const opPath = "/foo/bar"
	const opMethod = "POST"
	start := time.Now()
	opAttrs := slog.Group("operation", "id", "PostFooBar", "method", opMethod, "path", opPath, "url", r.URL.String())
	defer func() {
		if rec := recover(); rec != nil {
			slog.Error("Panic in handler", opAttrs, "panic", rec, "duration", time.Since(start))
			http.Error(w, fmt.Sprintf("Internal server error: %v", rec), http.StatusInternalServerError)
		} else {
			slog.Info("Request completed", opAttrs, "duration", time.Since(start))
		}
	}()

	if h.config.Validate.Request {
		if err := api.ValidateRequest[struct{}](r); err != nil {
			slog.Warn("Request processing failed", opAttrs, "error", err)
			http.Error(w, string(h.getError(opPath, opMethod, err)), http.StatusBadRequest)
			return
		}
	}

	res, _ := h.service.postFooBar(opPath, opMethod)
	if res == nil {
		http.Error(w, "operation not found", http.StatusInternalServerError)
		return
	}

	resValue := res.Body
	statusCode := res.Status
	if statusCode == 0 {
		statusCode = 200
	}
	slog.Debug("generated response", "body", string(res.Body), "status", statusCode)

	if res.IsError {
		statusCode = http.StatusBadRequest
	} else if h.config.Validate.Response {
		if err := api.ValidateResponse[types.PostFooBarResponse](res.Body, "application/json"); err != nil {
			slog.Warn("Response validation failed", opAttrs, "error", err)
			resValue = h.getError(opPath, opMethod, fmt.Errorf("validation error: %w", err))
		}
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	w.Write(resValue)
}
